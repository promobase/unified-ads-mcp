// Code generated by codegen. DO NOT EDIT.

package common

import (
	"context"
	"fmt"
	"net/url"
	"reflect"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
)

// ConvertArgsToParams converts a struct to a map[string]string for API requests
func ConvertArgsToParams(args interface{}) map[string]string {
	params := make(map[string]string)

	v := reflect.ValueOf(args)
	if v.Kind() == reflect.Ptr {
		v = v.Elem()
	}

	if v.Kind() != reflect.Struct {
		return params
	}

	t := v.Type()
	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldType := t.Field(i)

		// Get JSON tag
		jsonTag := fieldType.Tag.Get("json")
		if jsonTag == "" || jsonTag == "-" {
			continue
		}

		// Parse JSON tag
		tagParts := strings.Split(jsonTag, ",")
		fieldName := tagParts[0]

		// Skip if field is zero value and omitempty is set
		if len(tagParts) > 1 && strings.Contains(tagParts[1], "omitempty") {
			if isZeroValue(field) {
				continue
			}
		}

		// Convert field value to string
		if !isZeroValue(field) {
			params[fieldName] = fmt.Sprintf("%v", field.Interface())
		}
	}

	return params
}

// isZeroValue checks if a reflect.Value is a zero value
func isZeroValue(v reflect.Value) bool {
	switch v.Kind() {
	case reflect.String:
		return v.String() == ""
	case reflect.Bool:
		return !v.Bool()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0
	case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:
		return v.IsNil()
	case reflect.Struct:
		// For struct, check if all fields are zero
		for i := 0; i < v.NumField(); i++ {
			if !isZeroValue(v.Field(i)) {
				return false
			}
		}
		return true
	default:
		return false
	}
}

// HandleBindError returns an MCP error result for binding errors
func HandleBindError(err error) (*mcp.CallToolResult, error) {
	return mcp.NewToolResultErrorf("Failed to parse arguments: %v", err), nil
}

// HandleAPIError returns an MCP error result for API errors
func HandleAPIError(err error) (*mcp.CallToolResult, error) {
	return mcp.NewToolResultErrorf("API request failed: %v", err), nil
}

// MakeGraphAPIRequest makes a request to the Facebook Graph API
func MakeGraphAPIRequest(ctx context.Context, method, endpoint string, params map[string]string, body interface{}) ([]byte, error) {
	// Build URL with query parameters
	u, err := url.Parse(endpoint)
	if err != nil {
		return nil, fmt.Errorf("invalid endpoint: %w", err)
	}

	// Add query parameters for GET requests
	if method == "GET" && len(params) > 0 {
		q := u.Query()
		for k, v := range params {
			q.Set(k, v)
		}
		u.RawQuery = q.Encode()
	}

	// Convert body to map if needed
	var bodyMap map[string]interface{}
	if body != nil {
		// If body is already a map, use it
		if m, ok := body.(map[string]interface{}); ok {
			bodyMap = m
		} else if method != "GET" {
			// For non-GET requests, merge params into body
			bodyMap = make(map[string]interface{})
			for k, v := range params {
				bodyMap[k] = v
			}
		}
	} else if method != "GET" && len(params) > 0 {
		// For non-GET requests with no body, use params as body
		bodyMap = make(map[string]interface{})
		for k, v := range params {
			bodyMap[k] = v
		}
	}

	// Make the request
	return makeGraphRequest(method, u.String(), bodyMap)
}
