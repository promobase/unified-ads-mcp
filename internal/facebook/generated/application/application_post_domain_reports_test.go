// Code generated by Facebook Business API codegen. DO NOT EDIT.

package application

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strings"
	"testing"
)

func TestApplication_post_domain_reports_URLConstruction(t *testing.T) {
	accessToken := "test-token"

	tests := []struct {
		name        string
		args        map[string]interface{}
		wantBaseURL string
		wantParams  map[string]string
	}{
		{
			name:        "basic request with required params",
			args:        map[string]interface{}{},
			wantBaseURL: "https://graph.facebook.com/v23.0/domain_reports",
			wantParams: map[string]string{
				"access_token": accessToken,
			},
		},
		{
			name: "request with fields parameter",
			args: map[string]interface{}{

				"fields": "id,name,status,created_time,updated_time",
			},
			wantBaseURL: "https://graph.facebook.com/v23.0/domain_reports",
			wantParams: map[string]string{
				"access_token": accessToken,
				"fields":       "id,name,status,created_time,updated_time",
			},
		},
		{
			name: "request with pagination",
			args: map[string]interface{}{

				"limit": 10,
				"after": "cursor123",
			},
			wantBaseURL: "https://graph.facebook.com/v23.0/domain_reports",
			wantParams: map[string]string{
				"access_token": accessToken,
				"limit":        "10",
				"after":        "cursor123",
			},
		},

		{
			name: "request with complex params object",
			args: map[string]interface{}{

				"params": map[string]interface{}{},
			},
			wantBaseURL: "https://graph.facebook.com/v23.0/domain_reports",
			wantParams: map[string]string{
				"access_token": accessToken,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Get the base URL
			var baseURL string

			baseURL = FacebookGraphAPIBaseURL + "/domain_reports"

			// Check base URL
			if baseURL != tt.wantBaseURL {
				t.Errorf("baseURL = %v, want %v", baseURL, tt.wantBaseURL)
			}

			// Build URL parameters
			skipParams := []string{}
			urlParams := buildURLParamsApplication_post_domain_reports(accessToken, tt.args, skipParams...)

			// Check all expected parameters
			for key, expectedValue := range tt.wantParams {
				actualValue := urlParams.Get(key)
				if actualValue != expectedValue {
					t.Errorf("param %s = %v, want %v", key, actualValue, expectedValue)
				}
			}

			// Check no unexpected parameters
			for key := range urlParams {
				if _, exists := tt.wantParams[key]; !exists {
					t.Errorf("unexpected param %s = %v", key, urlParams.Get(key))
				}
			}
		})
	}
}

func TestApplication_post_domain_reports_BodyConstruction(t *testing.T) {
	tests := []struct {
		name     string
		args     map[string]interface{}
		wantBody map[string]interface{}
	}{

		{
			name: "basic POST request",
			args: map[string]interface{}{

				"name":   "Test",
				"status": "ACTIVE",
			},
			wantBody: map[string]interface{}{
				"name":   "Test",
				"status": "ACTIVE",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Build body parameters
			skipParams := []string{}

			bodyParams := buildBodyParamsApplication_post_domain_reports(tt.args, skipParams...)

			// Check all expected parameters
			for key, expectedValue := range tt.wantBody {
				actualValue := bodyParams.Get(key)
				if actualValue != expectedValue {
					t.Errorf("body param %s = %v, want %v", key, actualValue, expectedValue)
				}
			}

			// Check no unexpected parameters
			for key := range bodyParams {
				if _, exists := tt.wantBody[key]; !exists {
					t.Errorf("unexpected body param %s = %v", key, bodyParams.Get(key))
				}
			}
		})
	}
}

// Helper function to simulate body parameter building (for testing)
func buildBodyParamsApplication_post_domain_reports(args map[string]interface{}, skipParams ...string) url.Values {
	params := url.Values{}

	skipMap := make(map[string]bool)
	for _, param := range skipParams {
		skipMap[param] = true
	}

	for key, value := range args {
		if skipMap[key] {
			continue
		}

		switch v := value.(type) {
		case string:
			params.Set(key, v)
		case int, int64, float64:
			params.Set(key, fmt.Sprintf("%v", v))
		case bool:
			params.Set(key, fmt.Sprintf("%v", v))
		case []interface{}, map[string]interface{}:
			jsonBytes, _ := json.Marshal(v)
			params.Set(key, string(jsonBytes))
		case []string:
			jsonBytes, _ := json.Marshal(v)
			params.Set(key, string(jsonBytes))
		case []map[string]interface{}:
			jsonBytes, _ := json.Marshal(v)
			params.Set(key, string(jsonBytes))
		default:
			params.Set(key, fmt.Sprintf("%v", v))
		}
	}

	return params
}

// Helper function to simulate BuildURLParams (for testing)
func buildURLParamsApplication_post_domain_reports(accessToken string, args map[string]interface{}, skipParams ...string) url.Values {
	params := url.Values{}
	params.Set("access_token", accessToken)

	skipMap := make(map[string]bool)
	for _, param := range skipParams {
		skipMap[param] = true
	}

	for key, value := range args {
		if skipMap[key] {
			continue
		}

		// Handle params object
		if key == "params" {
			if paramsObj, ok := value.(map[string]interface{}); ok {
				for pKey, pValue := range paramsObj {
					switch v := pValue.(type) {
					case string:
						params.Set(pKey, v)
					case []string:
						jsonBytes, _ := json.Marshal(v)
						params.Set(pKey, string(jsonBytes))
					case []interface{}, map[string]interface{}, []map[string]interface{}, map[string]string:
						jsonBytes, _ := json.Marshal(v)
						params.Set(pKey, string(jsonBytes))
					default:
						params.Set(pKey, fmt.Sprintf("%v", v))
					}
				}
			}
			continue
		}

		// Handle regular parameters
		switch v := value.(type) {
		case string:
			params.Set(key, v)
		case int, int64, float64:
			params.Set(key, fmt.Sprintf("%v", v))
		case []string:
			// Fields should be comma-separated
			if key == "fields" {
				params.Set(key, strings.Join(v, ","))
			} else {
				jsonBytes, _ := json.Marshal(v)
				params.Set(key, string(jsonBytes))
			}
		default:
			params.Set(key, fmt.Sprintf("%v", v))
		}
	}

	return params
}
