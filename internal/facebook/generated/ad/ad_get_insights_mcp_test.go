// Code generated by Facebook Business API codegen. DO NOT EDIT.

package ad

import (
	"context"
	"strings"
	"testing"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/shared"
)

func TestToolAd_get_insights_Definition(t *testing.T) {
	// Test tool definition
	tool := ToolAd_get_insights()
	if tool.Name != "ad_get_insights" {
		t.Errorf("expected tool name ad_get_insights, got %s", tool.Name)
	}
}

func TestToolAd_get_insights_ValidationErrors(t *testing.T) {
	tests := []struct {
		name          string
		arguments     map[string]interface{}
		setupContext  func() context.Context
		expectedError bool
		errorContains string
	}{
		{
			name: "missing access token",
			arguments: map[string]interface{}{

				"ad_id": "123456789",
			},
			setupContext: func() context.Context {
				return context.Background() // No token
			},
			expectedError: true,
			errorContains: "access token not found",
		},
		{
			name:      "missing required ID parameter",
			arguments: map[string]interface{}{
				// Missing required ID
			},
			setupContext: func() context.Context {
				return context.WithValue(context.Background(), shared.FacebookAccessTokenKey, "test-token")
			},
			expectedError: true,
			errorContains: "missing required parameter",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup context
			ctx := tt.setupContext()

			// Create request
			params := mcp.CallToolParams{
				Name:      "ad_get_insights",
				Arguments: tt.arguments,
			}
			request := mcp.CallToolRequest{
				Params: params,
			}

			// Call handler
			result, err := HandleAd_get_insights(ctx, request)

			// Check expectations
			if tt.expectedError {
				if err != nil {
					t.Fatalf("unexpected error type: %v", err)
				}
				if result == nil || !result.IsError {
					t.Fatal("expected error result")
				}

				// Check error message contains expected text
				if tt.errorContains != "" && len(result.Content) > 0 {
					// Try to extract text from content
					errorText := ""
					for _, content := range result.Content {
						if textContent, ok := content.(mcp.TextContent); ok {
							errorText = textContent.Text
							break
						}
					}
					if errorText != "" && !strings.Contains(errorText, tt.errorContains) {
						t.Errorf("error %q does not contain %q", errorText, tt.errorContains)
					}
				}
			}
		})
	}
}
