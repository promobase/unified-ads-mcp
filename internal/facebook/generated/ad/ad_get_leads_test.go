// Code generated by Facebook Business API codegen. DO NOT EDIT.

package ad

import (
	"fmt"
	"net/url"
	"testing"
)

func TestAd_get_leads_URLConstruction(t *testing.T) {
	accessToken := "test-token"

	tests := []struct {
		name        string
		args        map[string]interface{}
		wantBaseURL string
		wantParams  map[string]string
	}{
		{
			name: "basic request with required params",
			args: map[string]interface{}{

				"ad_id": "123456789",
			},
			wantBaseURL: "https://graph.facebook.com/v23.0/123456789/leads",
			wantParams: map[string]string{
				"access_token": accessToken,
			},
		},
		{
			name: "request with fields parameter",
			args: map[string]interface{}{

				"ad_id": "123456789",

				"fields": "id,name,status",
			},
			wantBaseURL: "https://graph.facebook.com/v23.0/123456789/leads",
			wantParams: map[string]string{
				"access_token": accessToken,
				"fields":       "id,name,status",
			},
		},
		{
			name: "request with pagination",
			args: map[string]interface{}{

				"ad_id": "123456789",

				"limit": 10,
				"after": "cursor123",
			},
			wantBaseURL: "https://graph.facebook.com/v23.0/123456789/leads",
			wantParams: map[string]string{
				"access_token": accessToken,
				"limit":        "10",
				"after":        "cursor123",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Get the base URL
			var baseURL string

			adId := tt.args["ad_id"].(string)

			baseURL = fmt.Sprintf("%s/%s/leads", FacebookGraphAPIBaseURL, adId)

			// Check base URL
			if baseURL != tt.wantBaseURL {
				t.Errorf("baseURL = %v, want %v", baseURL, tt.wantBaseURL)
			}

			// Build URL parameters
			skipParams := []string{

				"ad_id",
			}
			urlParams := buildURLParamsAd_get_leads(accessToken, tt.args, skipParams...)

			// Check all expected parameters
			for key, expectedValue := range tt.wantParams {
				actualValue := urlParams.Get(key)
				if actualValue != expectedValue {
					t.Errorf("param %s = %v, want %v", key, actualValue, expectedValue)
				}
			}

			// Check no unexpected parameters
			for key := range urlParams {
				if _, exists := tt.wantParams[key]; !exists {
					t.Errorf("unexpected param %s = %v", key, urlParams.Get(key))
				}
			}
		})
	}
}

// Helper function to simulate BuildURLParams (for testing)
func buildURLParamsAd_get_leads(accessToken string, args map[string]interface{}, skipParams ...string) url.Values {
	params := url.Values{}
	params.Set("access_token", accessToken)

	skipMap := make(map[string]bool)
	for _, param := range skipParams {
		skipMap[param] = true
	}

	for key, value := range args {
		if skipMap[key] {
			continue
		}
		if key == "params" {
			continue
		}
		params.Set(key, fmt.Sprintf("%v", value))
	}

	return params
}
