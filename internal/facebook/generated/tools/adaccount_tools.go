// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetAdAccountTools returns MCP tools for AdAccount
func GetAdAccountTools() []mcp.Tool {
	var tools []mcp.Tool

	// adaccount_get_account_controls tool
	// Available fields for AdAccountBusinessConstraints: audience_controls, campaigns_with_error, placement_controls, status
	adaccount_get_account_controlsTool := mcp.NewTool("adaccount_get_account_controls",
		mcp.WithDescription("GET account_controls for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountBusinessConstraints objects. Available fields: audience_controls, campaigns_with_error, placement_controls, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_account_controlsTool)

	// adaccount_post_account_controls tool
	// Params object accepts: audience_controls (Object), placement_controls (Object)
	adaccount_post_account_controlsTool := mcp.NewTool("adaccount_post_account_controls",
		mcp.WithDescription("POST account_controls for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"audience_controls": map[string]any{
					"type":        "object",
					"description": "audience_controls parameter",
					"required":    true,
				},
				"placement_controls": map[string]any{
					"type":        "object",
					"description": "placement_controls parameter",
				},
			}),
			mcp.Description("Parameters object containing: audience_controls (object) [required], placement_controls (object)"),
		),
	)
	tools = append(tools, adaccount_post_account_controlsTool)

	// adaccount_get_activities tool
	// Available fields for AdActivity: actor_id, actor_name, application_id, application_name, date_time_in_timezone, event_time, event_type, extra_data, object_id, object_name, object_type, translated_event_type
	// Params object accepts: add_children (bool), after (string), business_id (string), category (adaccountactivities_category_enum_param), data_source (adaccountactivities_data_source_enum_param), extra_oids (list<string>), limit (int), oid (string), since (datetime), uid (int), until (datetime)
	adaccount_get_activitiesTool := mcp.NewTool("adaccount_get_activities",
		mcp.WithDescription("GET activities for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"add_children": map[string]any{
					"type":        "boolean",
					"description": "add_children parameter",
				},
				"after": map[string]any{
					"type":        "string",
					"description": "after parameter",
				},
				"business_id": map[string]any{
					"type":        "string",
					"description": "business_id parameter",
				},
				"category": map[string]any{
					"type":        "string",
					"description": "category parameter",
					"enum":        []string{"ACCOUNT", "AD", "AD_KEYWORDS", "AD_SET", "AUDIENCE", "BID", "BUDGET", "CAMPAIGN", "DATE", "STATUS", "TARGETING"},
				},
				"data_source": map[string]any{
					"type":        "string",
					"description": "data_source parameter",
					"enum":        []string{"CALYPSO", "TAO", "TAO_AD_ACCOUNT", "TAO_AD_STATUS"},
				},
				"extra_oids": map[string]any{
					"type":        "array",
					"description": "extra_oids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"limit": map[string]any{
					"type":        "integer",
					"description": "limit parameter",
				},
				"oid": map[string]any{
					"type":        "string",
					"description": "oid parameter",
				},
				"since": map[string]any{
					"type":        "string",
					"description": "since parameter",
				},
				"uid": map[string]any{
					"type":        "integer",
					"description": "uid parameter",
				},
				"until": map[string]any{
					"type":        "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: add_children (boolean), after (string), business_id (string), category (enum) [ACCOUNT, AD, AD_KEYWORDS, AD_SET, AUDIENCE, ...], data_source (enum) [CALYPSO, TAO, TAO_AD_ACCOUNT, TAO_AD_STATUS], extra_oids (array<string>), limit (integer), oid (string), since (datetime), uid (integer), until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdActivity objects. Available fields: actor_id, actor_name, application_id, application_name, date_time_in_timezone, event_time, event_type, extra_data, object_id, object_name, object_type, translated_event_type"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_activitiesTool)

	// adaccount_get_ad_place_page_sets tool
	// Available fields for AdPlacePageSet: account_id, id, location_types, name, pages_count, parent_page
	adaccount_get_ad_place_page_setsTool := mcp.NewTool("adaccount_get_ad_place_page_sets",
		mcp.WithDescription("GET ad_place_page_sets for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdPlacePageSet objects. Available fields: account_id, id, location_types, name, pages_count, parent_page"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_ad_place_page_setsTool)

	// adaccount_post_ad_place_page_sets tool
	// Params object accepts: location_types (list<adaccountad_place_page_sets_location_types_enum_param>), name (string), parent_page (string), targeted_area_type (adaccountad_place_page_sets_targeted_area_type_enum_param)
	adaccount_post_ad_place_page_setsTool := mcp.NewTool("adaccount_post_ad_place_page_sets",
		mcp.WithDescription("POST ad_place_page_sets for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"location_types": map[string]any{
					"type":        "array",
					"description": "location_types parameter",
					"enum":        []string{"home", "recent"},
					"items":       map[string]any{"type": "string"},
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"parent_page": map[string]any{
					"type":        "string",
					"description": "parent_page parameter",
					"required":    true,
				},
				"targeted_area_type": map[string]any{
					"type":        "string",
					"description": "targeted_area_type parameter",
					"enum":        []string{"CUSTOM_RADIUS", "MARKETING_AREA", "NONE"},
				},
			}),
			mcp.Description("Parameters object containing: location_types (array<enum>) [home, recent], name (string) [required], parent_page (string) [required], targeted_area_type (enum) [CUSTOM_RADIUS, MARKETING_AREA, NONE]"),
		),
	)
	tools = append(tools, adaccount_post_ad_place_page_setsTool)

	// adaccount_post_ad_place_page_sets_async tool
	// Params object accepts: location_types (list<adaccountad_place_page_sets_async_location_types_enum_param>), name (string), parent_page (string), targeted_area_type (adaccountad_place_page_sets_async_targeted_area_type_enum_param)
	adaccount_post_ad_place_page_sets_asyncTool := mcp.NewTool("adaccount_post_ad_place_page_sets_async",
		mcp.WithDescription("POST ad_place_page_sets_async for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"location_types": map[string]any{
					"type":        "array",
					"description": "location_types parameter",
					"enum":        []string{"home", "recent"},
					"items":       map[string]any{"type": "string"},
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"parent_page": map[string]any{
					"type":        "string",
					"description": "parent_page parameter",
					"required":    true,
				},
				"targeted_area_type": map[string]any{
					"type":        "string",
					"description": "targeted_area_type parameter",
					"enum":        []string{"CUSTOM_RADIUS", "MARKETING_AREA", "NONE"},
				},
			}),
			mcp.Description("Parameters object containing: location_types (array<enum>) [home, recent], name (string) [required], parent_page (string) [required], targeted_area_type (enum) [CUSTOM_RADIUS, MARKETING_AREA, NONE]"),
		),
	)
	tools = append(tools, adaccount_post_ad_place_page_sets_asyncTool)

	// adaccount_get_ad_saved_keywords tool
	// Available fields for AdSavedKeywords: account, id, keywords, name, run_status, time_created, time_updated
	// Params object accepts: fields (list<string>)
	adaccount_get_ad_saved_keywordsTool := mcp.NewTool("adaccount_get_ad_saved_keywords",
		mcp.WithDescription("GET ad_saved_keywords for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"fields": map[string]any{
					"type":        "array",
					"description": "fields parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: fields (array<string>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdSavedKeywords objects. Available fields: account, id, keywords, name, run_status, time_created, time_updated"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_ad_saved_keywordsTool)

	// adaccount_get_ad_studies tool
	// Available fields for AdStudy: business, canceled_time, client_business, cooldown_start_time, created_by, created_time, description, end_time, id, measurement_contact, name, observation_end_time, results_first_available_date, sales_contact, start_time, type, updated_by, updated_time
	adaccount_get_ad_studiesTool := mcp.NewTool("adaccount_get_ad_studies",
		mcp.WithDescription("GET ad_studies for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdStudy objects. Available fields: business, canceled_time, client_business, cooldown_start_time, created_by, created_time, description, end_time, id, measurement_contact, name, observation_end_time, results_first_available_date, sales_contact, start_time (and 3 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_ad_studiesTool)

	// adaccount_get_adcloudplayables tool
	// Available fields for CloudGame: id, name, owner, playable_ad_file_size, playable_ad_orientation, playable_ad_package_name, playable_ad_reject_reason, playable_ad_status, playable_ad_upload_time
	adaccount_get_adcloudplayablesTool := mcp.NewTool("adaccount_get_adcloudplayables",
		mcp.WithDescription("GET adcloudplayables for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CloudGame objects. Available fields: id, name, owner, playable_ad_file_size, playable_ad_orientation, playable_ad_package_name, playable_ad_reject_reason, playable_ad_status, playable_ad_upload_time"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adcloudplayablesTool)

	// adaccount_get_adcreatives tool
	// Available fields for AdCreative: account_id, actor_id, ad_disclaimer_spec, adlabels, applink_treatment, asset_feed_spec, authorization_category, auto_update, body, branded_content, branded_content_sponsor_page_id, bundle_folder_id, call_to_action, call_to_action_type, categorization_criteria, category_media_source, collaborative_ads_lsb_image_bank_id, contextual_multi_ads, creative_sourcing_spec, degrees_of_freedom_spec, destination_set_id, dynamic_ad_voice, effective_authorization_category, effective_instagram_media_id, effective_object_story_id, enable_direct_install, enable_launch_instant_app, facebook_branded_content, id, image_crops, image_hash, image_url, instagram_branded_content, instagram_permalink_url, instagram_user_id, interactive_components_spec, link_deep_link_url, link_destination_display_url, link_og_id, link_url, messenger_sponsored_message, name, object_id, object_store_url, object_story_id, object_story_spec, object_type, object_url, omnichannel_link_spec, page_welcome_message, photo_album_source_object_story_id, place_page_set_id, platform_customizations, playable_asset_id, portrait_customizations, product_data, product_set_id, recommender_settings, regional_regulation_disclaimer_spec, source_facebook_post_id, source_instagram_media_id, status, template_url, template_url_spec, thumbnail_id, thumbnail_url, title, url_tags, use_page_actor_override, video_id
	adaccount_get_adcreativesTool := mcp.NewTool("adaccount_get_adcreatives",
		mcp.WithDescription("GET adcreatives for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdCreative objects. Available fields: account_id, actor_id, ad_disclaimer_spec, adlabels, applink_treatment, asset_feed_spec, authorization_category, auto_update, body, branded_content, branded_content_sponsor_page_id, bundle_folder_id, call_to_action, call_to_action_type, categorization_criteria (and 55 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adcreativesTool)

	// adaccount_post_adcreatives tool
	// Params object accepts: actor_id (unsigned int), ad_disclaimer_spec (map), adlabels (list<Object>), applink_treatment (adaccountadcreatives_applink_treatment_enum_param), asset_feed_spec (Object), authorization_category (adaccountadcreatives_authorization_category_enum_param), body (string), branded_content (map), branded_content_sponsor_page_id (string), bundle_folder_id (string), call_to_action (Object), categorization_criteria (adaccountadcreatives_categorization_criteria_enum_param), category_media_source (adaccountadcreatives_category_media_source_enum_param), contextual_multi_ads (map), creative_sourcing_spec (map), degrees_of_freedom_spec (map), destination_set_id (string), dynamic_ad_voice (adaccountadcreatives_dynamic_ad_voice_enum_param), enable_launch_instant_app (bool), facebook_branded_content (map), image_crops (map), image_file (string), image_hash (string), image_url (string), instagram_branded_content (map), instagram_permalink_url (string), instagram_user_id (string), interactive_components_spec (map), is_dco_internal (bool), link_og_id (string), link_url (string), name (string), object_id (unsigned int), object_story_id (string), object_story_spec (AdCreativeObjectStorySpec), object_type (string), object_url (string), omnichannel_link_spec (map), page_welcome_message (string), place_page_set_id (string), platform_customizations (Object), playable_asset_id (string), portrait_customizations (map), product_set_id (string), recommender_settings (map), regional_regulation_disclaimer_spec (map), source_instagram_media_id (string), template_url (string), template_url_spec (string), thumbnail_url (string), title (string), url_tags (string), use_page_actor_override (bool)
	adaccount_post_adcreativesTool := mcp.NewTool("adaccount_post_adcreatives",
		mcp.WithDescription("POST adcreatives for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"actor_id": map[string]any{
					"type":        "integer",
					"description": "actor_id parameter",
				},
				"ad_disclaimer_spec": map[string]any{
					"type":        "object",
					"description": "ad_disclaimer_spec parameter",
				},
				"adlabels": map[string]any{
					"type":        "array",
					"description": "adlabels parameter",
					"items":       map[string]any{"type": "object"},
				},
				"applink_treatment": map[string]any{
					"type":        "string",
					"description": "applink_treatment parameter",
					"enum":        []string{"automatic", "deeplink_with_appstore_fallback", "deeplink_with_web_fallback", "web_only"},
				},
				"asset_feed_spec": map[string]any{
					"type":        "object",
					"description": "asset_feed_spec parameter",
				},
				"authorization_category": map[string]any{
					"type":        "string",
					"description": "authorization_category parameter",
					"enum":        []string{"NONE", "POLITICAL", "POLITICAL_WITH_DIGITALLY_CREATED_MEDIA"},
				},
				"body": map[string]any{
					"type":        "string",
					"description": "body parameter",
				},
				"branded_content": map[string]any{
					"type":        "object",
					"description": "branded_content parameter",
				},
				"branded_content_sponsor_page_id": map[string]any{
					"type":        "string",
					"description": "branded_content_sponsor_page_id parameter",
				},
				"bundle_folder_id": map[string]any{
					"type":        "string",
					"description": "bundle_folder_id parameter",
				},
				"call_to_action": map[string]any{
					"type":        "object",
					"description": "call_to_action parameter",
				},
				"categorization_criteria": map[string]any{
					"type":        "string",
					"description": "categorization_criteria parameter",
					"enum":        []string{"brand", "category", "product_type"},
				},
				"category_media_source": map[string]any{
					"type":        "string",
					"description": "category_media_source parameter",
					"enum":        []string{"CATEGORY", "MIXED", "PRODUCTS_COLLAGE", "PRODUCTS_SLIDESHOW"},
				},
				"contextual_multi_ads": map[string]any{
					"type":        "object",
					"description": "contextual_multi_ads parameter",
				},
				"creative_sourcing_spec": map[string]any{
					"type":        "object",
					"description": "creative_sourcing_spec parameter",
				},
				"degrees_of_freedom_spec": map[string]any{
					"type":        "object",
					"description": "degrees_of_freedom_spec parameter",
				},
				"destination_set_id": map[string]any{
					"type":        "string",
					"description": "destination_set_id parameter",
				},
				"dynamic_ad_voice": map[string]any{
					"type":        "string",
					"description": "dynamic_ad_voice parameter",
					"enum":        []string{"DYNAMIC", "STORY_OWNER"},
				},
				"enable_launch_instant_app": map[string]any{
					"type":        "boolean",
					"description": "enable_launch_instant_app parameter",
				},
				"facebook_branded_content": map[string]any{
					"type":        "object",
					"description": "facebook_branded_content parameter",
				},
				"image_crops": map[string]any{
					"type":        "object",
					"description": "image_crops parameter",
				},
				"image_file": map[string]any{
					"type":        "string",
					"description": "image_file parameter",
				},
				"image_hash": map[string]any{
					"type":        "string",
					"description": "image_hash parameter",
				},
				"image_url": map[string]any{
					"type":        "string",
					"description": "image_url parameter",
				},
				"instagram_branded_content": map[string]any{
					"type":        "object",
					"description": "instagram_branded_content parameter",
				},
				"instagram_permalink_url": map[string]any{
					"type":        "string",
					"description": "instagram_permalink_url parameter",
				},
				"instagram_user_id": map[string]any{
					"type":        "string",
					"description": "instagram_user_id parameter",
				},
				"interactive_components_spec": map[string]any{
					"type":        "object",
					"description": "interactive_components_spec parameter",
				},
				"is_dco_internal": map[string]any{
					"type":        "boolean",
					"description": "is_dco_internal parameter",
				},
				"link_og_id": map[string]any{
					"type":        "string",
					"description": "link_og_id parameter",
				},
				"link_url": map[string]any{
					"type":        "string",
					"description": "link_url parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"object_id": map[string]any{
					"type":        "integer",
					"description": "object_id parameter",
				},
				"object_story_id": map[string]any{
					"type":        "string",
					"description": "object_story_id parameter",
				},
				"object_story_spec": map[string]any{
					"type":        "string",
					"description": "object_story_spec parameter",
				},
				"object_type": map[string]any{
					"type":        "string",
					"description": "object_type parameter",
				},
				"object_url": map[string]any{
					"type":        "string",
					"description": "object_url parameter",
				},
				"omnichannel_link_spec": map[string]any{
					"type":        "object",
					"description": "omnichannel_link_spec parameter",
				},
				"page_welcome_message": map[string]any{
					"type":        "string",
					"description": "page_welcome_message parameter",
				},
				"place_page_set_id": map[string]any{
					"type":        "string",
					"description": "place_page_set_id parameter",
				},
				"platform_customizations": map[string]any{
					"type":        "object",
					"description": "platform_customizations parameter",
				},
				"playable_asset_id": map[string]any{
					"type":        "string",
					"description": "playable_asset_id parameter",
				},
				"portrait_customizations": map[string]any{
					"type":        "object",
					"description": "portrait_customizations parameter",
				},
				"product_set_id": map[string]any{
					"type":        "string",
					"description": "product_set_id parameter",
				},
				"recommender_settings": map[string]any{
					"type":        "object",
					"description": "recommender_settings parameter",
				},
				"regional_regulation_disclaimer_spec": map[string]any{
					"type":        "object",
					"description": "regional_regulation_disclaimer_spec parameter",
				},
				"source_instagram_media_id": map[string]any{
					"type":        "string",
					"description": "source_instagram_media_id parameter",
				},
				"template_url": map[string]any{
					"type":        "string",
					"description": "template_url parameter",
				},
				"template_url_spec": map[string]any{
					"type":        "string",
					"description": "template_url_spec parameter",
				},
				"thumbnail_url": map[string]any{
					"type":        "string",
					"description": "thumbnail_url parameter",
				},
				"title": map[string]any{
					"type":        "string",
					"description": "title parameter",
				},
				"url_tags": map[string]any{
					"type":        "string",
					"description": "url_tags parameter",
				},
				"use_page_actor_override": map[string]any{
					"type":        "boolean",
					"description": "use_page_actor_override parameter",
				},
			}),
			mcp.Description("Parameters object containing: actor_id (integer), ad_disclaimer_spec (object), adlabels (array<object>), applink_treatment (enum) [automatic, deeplink_with_appstore_fallback, deeplink_with_web_fallback, web_only], asset_feed_spec (object), authorization_category (enum) [NONE, POLITICAL, POLITICAL_WITH_DIGITALLY_CREATED_MEDIA], body (string), branded_content (object), branded_content_sponsor_page_id (string), bundle_folder_id (string), call_to_action (object), categorization_criteria (enum) [brand, category, product_type], category_media_source (enum) [CATEGORY, MIXED, PRODUCTS_COLLAGE, PRODUCTS_SLIDESHOW], contextual_multi_ads (object), creative_sourcing_spec (object), degrees_of_freedom_spec (object), destination_set_id (string), dynamic_ad_voice (enum) [DYNAMIC, STORY_OWNER], enable_launch_instant_app (boolean), facebook_branded_content (object), image_crops (object), image_file (string), image_hash (string), image_url (string), instagram_branded_content (object), instagram_permalink_url (string), instagram_user_id (string), interactive_components_spec (object), is_dco_internal (boolean), link_og_id (string), link_url (string), name (string), object_id (integer), object_story_id (string), object_story_spec (AdCreativeObjectStorySpec), object_type (string), object_url (string), omnichannel_link_spec (object), page_welcome_message (string), place_page_set_id (string), platform_customizations (object), playable_asset_id (string), portrait_customizations (object), product_set_id (string), recommender_settings (object), regional_regulation_disclaimer_spec (object), source_instagram_media_id (string), template_url (string), template_url_spec (string), thumbnail_url (string), title (string), url_tags (string), use_page_actor_override (boolean)"),
		),
	)
	tools = append(tools, adaccount_post_adcreativesTool)

	// adaccount_get_adcreativesbylabels tool
	// Available fields for AdCreative: account_id, actor_id, ad_disclaimer_spec, adlabels, applink_treatment, asset_feed_spec, authorization_category, auto_update, body, branded_content, branded_content_sponsor_page_id, bundle_folder_id, call_to_action, call_to_action_type, categorization_criteria, category_media_source, collaborative_ads_lsb_image_bank_id, contextual_multi_ads, creative_sourcing_spec, degrees_of_freedom_spec, destination_set_id, dynamic_ad_voice, effective_authorization_category, effective_instagram_media_id, effective_object_story_id, enable_direct_install, enable_launch_instant_app, facebook_branded_content, id, image_crops, image_hash, image_url, instagram_branded_content, instagram_permalink_url, instagram_user_id, interactive_components_spec, link_deep_link_url, link_destination_display_url, link_og_id, link_url, messenger_sponsored_message, name, object_id, object_store_url, object_story_id, object_story_spec, object_type, object_url, omnichannel_link_spec, page_welcome_message, photo_album_source_object_story_id, place_page_set_id, platform_customizations, playable_asset_id, portrait_customizations, product_data, product_set_id, recommender_settings, regional_regulation_disclaimer_spec, source_facebook_post_id, source_instagram_media_id, status, template_url, template_url_spec, thumbnail_id, thumbnail_url, title, url_tags, use_page_actor_override, video_id
	// Params object accepts: ad_label_ids (list<string>), operator (adaccountadcreativesbylabels_operator_enum_param)
	adaccount_get_adcreativesbylabelsTool := mcp.NewTool("adaccount_get_adcreativesbylabels",
		mcp.WithDescription("GET adcreativesbylabels for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"ad_label_ids": map[string]any{
					"type":        "array",
					"description": "ad_label_ids parameter",
					"required":    true,
					"items":       map[string]any{"type": "string"},
				},
				"operator": map[string]any{
					"type":        "string",
					"description": "operator parameter",
					"enum":        []string{"ALL", "ANY"},
				},
			}),
			mcp.Description("Parameters object containing: ad_label_ids (array<string>) [required], operator (enum) [ALL, ANY]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdCreative objects. Available fields: account_id, actor_id, ad_disclaimer_spec, adlabels, applink_treatment, asset_feed_spec, authorization_category, auto_update, body, branded_content, branded_content_sponsor_page_id, bundle_folder_id, call_to_action, call_to_action_type, categorization_criteria (and 55 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adcreativesbylabelsTool)

	// adaccount_delete_adimages tool
	// Params object accepts: hash (string)
	adaccount_delete_adimagesTool := mcp.NewTool("adaccount_delete_adimages",
		mcp.WithDescription("DELETE adimages for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"hash": map[string]any{
					"type":        "string",
					"description": "hash parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: hash (string) [required]"),
		),
	)
	tools = append(tools, adaccount_delete_adimagesTool)

	// adaccount_get_adimages tool
	// Available fields for AdImage: account_id, created_time, creatives, hash, height, id, is_associated_creatives_in_adgroups, name, original_height, original_width, owner_business, permalink_url, status, updated_time, url, url_128, width
	// Params object accepts: biz_tag_id (unsigned int), business_id (string), hashes (list<string>), minheight (unsigned int), minwidth (unsigned int), name (string), selected_hashes (list<string>)
	adaccount_get_adimagesTool := mcp.NewTool("adaccount_get_adimages",
		mcp.WithDescription("GET adimages for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"biz_tag_id": map[string]any{
					"type":        "integer",
					"description": "biz_tag_id parameter",
				},
				"business_id": map[string]any{
					"type":        "string",
					"description": "business_id parameter",
				},
				"hashes": map[string]any{
					"type":        "array",
					"description": "hashes parameter",
					"items":       map[string]any{"type": "string"},
				},
				"minheight": map[string]any{
					"type":        "integer",
					"description": "minheight parameter",
				},
				"minwidth": map[string]any{
					"type":        "integer",
					"description": "minwidth parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"selected_hashes": map[string]any{
					"type":        "array",
					"description": "selected_hashes parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: biz_tag_id (integer), business_id (string), hashes (array<string>), minheight (integer), minwidth (integer), name (string), selected_hashes (array<string>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdImage objects. Available fields: account_id, created_time, creatives, hash, height, id, is_associated_creatives_in_adgroups, name, original_height, original_width, owner_business, permalink_url, status, updated_time, url (and 2 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adimagesTool)

	// adaccount_post_adimages tool
	// Params object accepts: bytes (string), copy_from (Object)
	adaccount_post_adimagesTool := mcp.NewTool("adaccount_post_adimages",
		mcp.WithDescription("POST adimages for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"bytes": map[string]any{
					"type":        "string",
					"description": "bytes parameter",
				},
				"copy_from": map[string]any{
					"type":        "object",
					"description": "copy_from parameter",
				},
			}),
			mcp.Description("Parameters object containing: bytes (string), copy_from (object)"),
		),
	)
	tools = append(tools, adaccount_post_adimagesTool)

	// adaccount_get_adlabels tool
	// Available fields for AdLabel: account, created_time, id, name, updated_time
	adaccount_get_adlabelsTool := mcp.NewTool("adaccount_get_adlabels",
		mcp.WithDescription("GET adlabels for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdLabel objects. Available fields: account, created_time, id, name, updated_time"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adlabelsTool)

	// adaccount_post_adlabels tool
	// Params object accepts: name (string)
	adaccount_post_adlabelsTool := mcp.NewTool("adaccount_post_adlabels",
		mcp.WithDescription("POST adlabels for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: name (string) [required]"),
		),
	)
	tools = append(tools, adaccount_post_adlabelsTool)

	// adaccount_get_adplayables tool
	// Available fields for PlayableContent: id, name, owner
	adaccount_get_adplayablesTool := mcp.NewTool("adaccount_get_adplayables",
		mcp.WithDescription("GET adplayables for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PlayableContent objects. Available fields: id, name, owner"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adplayablesTool)

	// adaccount_post_adplayables tool
	// Params object accepts: app_id (string), name (string), session_id (string), source (file), source_url (string), source_zip (file)
	adaccount_post_adplayablesTool := mcp.NewTool("adaccount_post_adplayables",
		mcp.WithDescription("POST adplayables for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"app_id": map[string]any{
					"type":        "string",
					"description": "app_id parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"session_id": map[string]any{
					"type":        "string",
					"description": "session_id parameter",
				},
				"source": map[string]any{
					"type":        "string",
					"description": "source parameter",
				},
				"source_url": map[string]any{
					"type":        "string",
					"description": "source_url parameter",
				},
				"source_zip": map[string]any{
					"type":        "string",
					"description": "source_zip parameter",
				},
			}),
			mcp.Description("Parameters object containing: app_id (string), name (string) [required], session_id (string), source (file), source_url (string), source_zip (file)"),
		),
	)
	tools = append(tools, adaccount_post_adplayablesTool)

	// adaccount_get_adrules_history tool
	// Available fields for AdAccountAdRulesHistory: evaluation_spec, exception_code, exception_message, execution_spec, is_manual, results, rule_id, schedule_spec, timestamp
	// Params object accepts: action (adaccountadrules_history_action_enum_param), evaluation_type (adaccountadrules_history_evaluation_type_enum_param), hide_no_changes (bool), object_id (string)
	adaccount_get_adrules_historyTool := mcp.NewTool("adaccount_get_adrules_history",
		mcp.WithDescription("GET adrules_history for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"action": map[string]any{
					"type":        "string",
					"description": "action parameter",
					"enum":        []string{"BUDGET_NOT_REDISTRIBUTED", "CHANGED_BID", "CHANGED_BUDGET", "CONSOLIDATE_ASC_FRAGMENTATION", "CONSOLIDATE_FRAGMENTATION", "CONVERT_ASC_CP_SINGLE_INSTANCE", "EMAIL", "ENABLE_ADVANTAGE_CAMPAIGN_BUDGET", "ENABLE_ADVANTAGE_PLUS_AUDIENCE", "ENABLE_ADVANTAGE_PLUS_CREATIVE", "ENABLE_ADVANTAGE_PLUS_PLACEMENTS", "ENABLE_AUTOFLOW", "ENABLE_GEN_UNCROP", "ENABLE_LANDING_PAGE_VIEWS", "ENABLE_MUSIC", "ENABLE_REELS_PLACEMENTS", "ENABLE_SEMANTIC_BASED_AUDIENCE_EXPANSION", "ENABLE_SHOPS_ADS", "ENDPOINT_PINGED", "ERROR", "FACEBOOK_NOTIFICATION_SENT", "MESSAGE_SENT", "NOT_CHANGED", "PAUSED", "UNPAUSED"},
				},
				"evaluation_type": map[string]any{
					"type":        "string",
					"description": "evaluation_type parameter",
					"enum":        []string{"SCHEDULE", "TRIGGER"},
				},
				"hide_no_changes": map[string]any{
					"type":        "boolean",
					"description": "hide_no_changes parameter",
				},
				"object_id": map[string]any{
					"type":        "string",
					"description": "object_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: action (enum) [BUDGET_NOT_REDISTRIBUTED, CHANGED_BID, CHANGED_BUDGET, CONSOLIDATE_ASC_FRAGMENTATION, CONSOLIDATE_FRAGMENTATION, ...], evaluation_type (enum) [SCHEDULE, TRIGGER], hide_no_changes (boolean), object_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountAdRulesHistory objects. Available fields: evaluation_spec, exception_code, exception_message, execution_spec, is_manual, results, rule_id, schedule_spec, timestamp"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adrules_historyTool)

	// adaccount_get_adrules_library tool
	// Available fields for AdRule: account_id, created_by, created_time, disable_error_code, evaluation_spec, execution_spec, id, name, schedule_spec, status, updated_time
	adaccount_get_adrules_libraryTool := mcp.NewTool("adaccount_get_adrules_library",
		mcp.WithDescription("GET adrules_library for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdRule objects. Available fields: account_id, created_by, created_time, disable_error_code, evaluation_spec, execution_spec, id, name, schedule_spec, status, updated_time"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adrules_libraryTool)

	// adaccount_post_adrules_library tool
	// Params object accepts: account_id (string), evaluation_spec (Object), execution_spec (Object), name (string), schedule_spec (Object), status (adaccountadrules_library_status_enum_param), ui_creation_source (adaccountadrules_library_ui_creation_source_enum_param)
	adaccount_post_adrules_libraryTool := mcp.NewTool("adaccount_post_adrules_library",
		mcp.WithDescription("POST adrules_library for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"account_id": map[string]any{
					"type":        "string",
					"description": "account_id parameter",
				},
				"evaluation_spec": map[string]any{
					"type":        "object",
					"description": "evaluation_spec parameter",
					"required":    true,
				},
				"execution_spec": map[string]any{
					"type":        "object",
					"description": "execution_spec parameter",
					"required":    true,
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"schedule_spec": map[string]any{
					"type":        "object",
					"description": "schedule_spec parameter",
				},
				"status": map[string]any{
					"type":        "string",
					"description": "status parameter",
					"enum":        []string{"DELETED", "DISABLED", "ENABLED", "HAS_ISSUES"},
				},
				"ui_creation_source": map[string]any{
					"type":        "string",
					"description": "ui_creation_source parameter",
					"enum":        []string{"AM_ACCOUNT_OVERVIEW_RECOMMENDATIONS", "AM_ACTIVITY_HISTORY_TABLE", "AM_AD_OBJECT_NAME_CARD", "AM_AMFE_L3_RECOMMENDATION", "AM_AUTOFLOW_GUIDANCE_CARD", "AM_AUTO_APPLY_WIDGET", "AM_EDITOR_CARD", "AM_INFO_CARD", "AM_NAME_CELL_DROPDOWN", "AM_OPTIMIZATION_TIP_GUIDANCE_CARD", "AM_PERFORMANCE_SUMMARY", "AM_RULE_LANDING_PAGE_BANNER", "AM_SYD_RESOLUTION_FLOW", "AM_SYD_RESOLUTION_FLOW_MODAL", "AM_TABLE_DELIVERY_COLUMN_POPOVER", "AM_TABLE_MORE_RULES_DROPDOWN", "AM_TABLE_TOGGLE_POPOVER", "AM_TOOLBAR_CREATE_RULE_DROPDOWN", "PE_CAMPAIGN_STRUCTURE_MENU", "PE_EDITOR_CARD", "PE_INFO_CARD", "PE_TOOLBAR_CREATE_RULE_DROPDOWN", "RULES_MANAGEMENT_PAGE_ACTION_DROPDOWN", "RULES_MANAGEMENT_PAGE_RULE_GROUP", "RULES_MANAGEMENT_PAGE_RULE_NAME", "RULES_MANAGEMENT_PAGE_TOP_NAV", "RULES_VIEW_ACTIVE_RULES_DIALOG", "RULE_CREATION_SUCCESS_DIALOG", "RULE_SYD_REDIRECT", "RULE_TEMPLATES_DIALOG"},
				},
			}),
			mcp.Description("Parameters object containing: account_id (string), evaluation_spec (object) [required], execution_spec (object) [required], name (string) [required], schedule_spec (object), status (enum) [DELETED, DISABLED, ENABLED, HAS_ISSUES], ui_creation_source (enum) [AM_ACCOUNT_OVERVIEW_RECOMMENDATIONS, AM_ACTIVITY_HISTORY_TABLE, AM_AD_OBJECT_NAME_CARD, AM_AMFE_L3_RECOMMENDATION, AM_AUTOFLOW_GUIDANCE_CARD, ...]"),
		),
	)
	tools = append(tools, adaccount_post_adrules_libraryTool)

	// adaccount_get_ads tool
	// Available fields for Ad: account_id, ad_active_time, ad_review_feedback, ad_schedule_end_time, ad_schedule_start_time, adlabels, adset, adset_id, bid_amount, bid_info, bid_type, campaign, campaign_id, configured_status, conversion_domain, conversion_specs, created_time, creative, creative_asset_groups_spec, demolink_hash, display_sequence, effective_status, engagement_audience, failed_delivery_checks, id, issues_info, last_updated_by_app_id, name, placement, preview_shareable_link, priority, recommendations, source_ad, source_ad_id, status, targeting, tracking_and_conversion_with_defaults, tracking_specs, updated_time
	// Params object accepts: date_preset (adaccountads_date_preset_enum_param), effective_status (list<string>), time_range (map), updated_since (int)
	adaccount_get_adsTool := mcp.NewTool("adaccount_get_ads",
		mcp.WithDescription("GET ads for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"date_preset": map[string]any{
					"type":        "string",
					"description": "date_preset parameter",
					"enum":        []string{"data_maximum", "last_14d", "last_28d", "last_30d", "last_3d", "last_7d", "last_90d", "last_month", "last_quarter", "last_week_mon_sun", "last_week_sun_sat", "last_year", "maximum", "this_month", "this_quarter", "this_week_mon_today", "this_week_sun_today", "this_year", "today", "yesterday"},
				},
				"effective_status": map[string]any{
					"type":        "array",
					"description": "effective_status parameter",
					"items":       map[string]any{"type": "string"},
				},
				"time_range": map[string]any{
					"type":        "object",
					"description": "time_range parameter",
				},
				"updated_since": map[string]any{
					"type":        "integer",
					"description": "updated_since parameter",
				},
			}),
			mcp.Description("Parameters object containing: date_preset (enum) [data_maximum, last_14d, last_28d, last_30d, last_3d, ...], effective_status (array<string>), time_range (object), updated_since (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Ad objects. Available fields: account_id, ad_active_time, ad_review_feedback, ad_schedule_end_time, ad_schedule_start_time, adlabels, adset, adset_id, bid_amount, bid_info, bid_type, campaign, campaign_id, configured_status, conversion_domain (and 24 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adsTool)

	// adaccount_post_ads tool
	// Params object accepts: ad_schedule_end_time (datetime), ad_schedule_start_time (datetime), adlabels (list<Object>), adset_id (unsigned int), adset_spec (AdSet), audience_id (string), bid_amount (int), conversion_domain (string), creative (AdCreative), creative_asset_groups_spec (Object), date_format (string), display_sequence (unsigned int), draft_adgroup_id (string), engagement_audience (bool), execution_options (list<adaccountads_execution_options_enum_param>), include_demolink_hashes (bool), name (string), priority (unsigned int), source_ad_id (string), status (adaccountads_status_enum_param), tracking_specs (Object)
	adaccount_post_adsTool := mcp.NewTool("adaccount_post_ads",
		mcp.WithDescription("POST ads for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"ad_schedule_end_time": map[string]any{
					"type":        "string",
					"description": "ad_schedule_end_time parameter",
				},
				"ad_schedule_start_time": map[string]any{
					"type":        "string",
					"description": "ad_schedule_start_time parameter",
				},
				"adlabels": map[string]any{
					"type":        "array",
					"description": "adlabels parameter",
					"items":       map[string]any{"type": "object"},
				},
				"adset_id": map[string]any{
					"type":        "integer",
					"description": "adset_id parameter",
				},
				"adset_spec": map[string]any{
					"type":        "string",
					"description": "adset_spec parameter",
				},
				"audience_id": map[string]any{
					"type":        "string",
					"description": "audience_id parameter",
				},
				"bid_amount": map[string]any{
					"type":        "integer",
					"description": "bid_amount parameter",
				},
				"conversion_domain": map[string]any{
					"type":        "string",
					"description": "conversion_domain parameter",
				},
				"creative": map[string]any{
					"type":        "string",
					"description": "creative parameter",
					"required":    true,
				},
				"creative_asset_groups_spec": map[string]any{
					"type":        "object",
					"description": "creative_asset_groups_spec parameter",
				},
				"date_format": map[string]any{
					"type":        "string",
					"description": "date_format parameter",
				},
				"display_sequence": map[string]any{
					"type":        "integer",
					"description": "display_sequence parameter",
				},
				"draft_adgroup_id": map[string]any{
					"type":        "string",
					"description": "draft_adgroup_id parameter",
				},
				"engagement_audience": map[string]any{
					"type":        "boolean",
					"description": "engagement_audience parameter",
				},
				"execution_options": map[string]any{
					"type":        "array",
					"description": "execution_options parameter",
					"enum":        []string{"include_recommendations", "synchronous_ad_review", "validate_only"},
					"items":       map[string]any{"type": "string"},
				},
				"include_demolink_hashes": map[string]any{
					"type":        "boolean",
					"description": "include_demolink_hashes parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"priority": map[string]any{
					"type":        "integer",
					"description": "priority parameter",
				},
				"source_ad_id": map[string]any{
					"type":        "string",
					"description": "source_ad_id parameter",
				},
				"status": map[string]any{
					"type":        "string",
					"description": "status parameter",
					"enum":        []string{"ACTIVE", "ARCHIVED", "DELETED", "PAUSED"},
				},
				"tracking_specs": map[string]any{
					"type":        "object",
					"description": "tracking_specs parameter",
				},
			}),
			mcp.Description("Parameters object containing: ad_schedule_end_time (datetime), ad_schedule_start_time (datetime), adlabels (array<object>), adset_id (integer), adset_spec (AdSet), audience_id (string), bid_amount (integer), conversion_domain (string), creative (AdCreative) [required], creative_asset_groups_spec (object), date_format (string), display_sequence (integer), draft_adgroup_id (string), engagement_audience (boolean), execution_options (array<enum>) [include_recommendations, synchronous_ad_review, validate_only], include_demolink_hashes (boolean), name (string) [required], priority (integer), source_ad_id (string), status (enum) [ACTIVE, ARCHIVED, DELETED, PAUSED], tracking_specs (object)"),
		),
	)
	tools = append(tools, adaccount_post_adsTool)

	// adaccount_get_ads_reporting_mmm_reports tool
	// Available fields for AdsReportBuilderMMMReport: async_status, export_format, export_name, export_type, has_seen, id, mmm_status, time_start
	// Params object accepts: filtering (list<map>)
	adaccount_get_ads_reporting_mmm_reportsTool := mcp.NewTool("adaccount_get_ads_reporting_mmm_reports",
		mcp.WithDescription("GET ads_reporting_mmm_reports for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"filtering": map[string]any{
					"type":        "array",
					"description": "filtering parameter",
					"items":       map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: filtering (array<object>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdsReportBuilderMMMReport objects. Available fields: async_status, export_format, export_name, export_type, has_seen, id, mmm_status, time_start"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_ads_reporting_mmm_reportsTool)

	// adaccount_get_ads_reporting_mmm_schedulers tool
	// Available fields for AdsReportBuilderMMMReportScheduler: ad_account_ids, filtering, id, report_name, schedule_frequency
	adaccount_get_ads_reporting_mmm_schedulersTool := mcp.NewTool("adaccount_get_ads_reporting_mmm_schedulers",
		mcp.WithDescription("GET ads_reporting_mmm_schedulers for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdsReportBuilderMMMReportScheduler objects. Available fields: ad_account_ids, filtering, id, report_name, schedule_frequency"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_ads_reporting_mmm_schedulersTool)

	// adaccount_get_ads_volume tool
	// Available fields for AdAccountAdVolume: actor_id, actor_name, ad_limit_scope_business, ad_limit_scope_business_manager_id, ad_limit_set_by_page_admin, ads_running_or_in_review_count, ads_running_or_in_review_count_subject_to_limit_set_by_page, current_account_ads_running_or_in_review_count, future_limit_activation_date, future_limit_on_ads_running_or_in_review, limit_on_ads_running_or_in_review, recommendations
	// Params object accepts: page_id (string), recommendation_type (adaccountads_volume_recommendation_type_enum_param), show_breakdown_by_actor (bool)
	adaccount_get_ads_volumeTool := mcp.NewTool("adaccount_get_ads_volume",
		mcp.WithDescription("GET ads_volume for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"page_id": map[string]any{
					"type":        "string",
					"description": "page_id parameter",
				},
				"recommendation_type": map[string]any{
					"type":        "string",
					"description": "recommendation_type parameter",
					"enum":        []string{"AAC_CREATION_PACKAGE", "AB_TEST", "ACCOUNT_ERROR", "ACCOUNT_NEEDS_CREDIT", "ACCOUNT_SPEND_LIMIT", "ACCOUNT_SPEND_LIMIT_DUPLICATION", "ACO_TOGGLE", "ADSET_BUDGET_SHARING", "ADS_REPORTING", "ADS_STATUS", "ADVANCED_CAMPAIGN_BUDGET", "ADVANTAGE_APP_CAMPAIGN", "ADVANTAGE_CAMPAIGN_BUDGET_DUPLICATION", "ADVANTAGE_CUSTOM_AUDIENCE", "ADVANTAGE_CUSTOM_AUDIENCE_DUPLICATION", "ADVANTAGE_CUSTOM_AUDIENCE_UPSELL", "ADVANTAGE_DETAILED_TARGETING", "ADVANTAGE_LOOKALIKE_AUDIENCE", "ADVANTAGE_LOOKALIKE_DUPLICATION", "ADVANTAGE_PLUS_APP_CAMPAIGN", "ADVANTAGE_PLUS_APP_CAMPAIGN_PRECREATE", "ADVANTAGE_PLUS_AUDIENCE", "ADVANTAGE_PLUS_AUDIENCE_DUPLICATION", "ADVANTAGE_PLUS_AUDIENCE_FRICTION", "ADVANTAGE_PLUS_AUDIENCE_TOGGLE", "ADVANTAGE_PLUS_CAMPAIGN_BUDGET", "ADVANTAGE_PLUS_CATALOG_ADS", "ADVANTAGE_PLUS_CREATIVE", "ADVANTAGE_PLUS_CREATIVE_CATALOG", "ADVANTAGE_PLUS_CREATIVE_SE", "ADVANTAGE_PLUS_LEAD_CAMPAIGN", "ADVANTAGE_PLUS_PLACEMENTS_DUPLICATION", "ADVANTAGE_PLUS_PLACEMENTS_FRICTION", "ADVANTAGE_PLUS_PLACEMENTS_V2_DUPLICATION", "ADVANTAGE_SHOPPING_CAMPAIGN", "ADVANTAGE_SHOPPING_CAMPAIGN_FRAGMENTATION", "AD_ACCOUNT_PLACEMENT_CONTROLS_UPSELL", "AD_LIFT_RECALL_GOAL", "AD_LIFT_RECALL_GOAL_PRECREATE", "AD_LIFT_RECALL_OPTIMIZATION_GOAL", "AD_OBJECTIVE", "AD_SET_BUDGET_SHARING_GUIDANCE", "AEM_V2_INELIGIBLE", "AGGREGATED_BID_LIMITED", "AGGREGATED_BUDGET_LIMITED", "AGGREGATED_COST_LIMITED", "APLUSC_ADD_OVERLAYS", "APLUSC_DYNAMIC_DESCRIPTION", "APLUSC_IMAGE_BACKGROUND_GENERATION", "APLUSC_MUSIC", "APLUSC_RELEVANT_COMMENTS", "APLUSC_STANDARD_ENHANCEMENTS_BUNDLE", "APLUSC_TEXT_IMPROVEMENTS", "APLUSC_VISUAL_TOUCHUPS", "APLUS_C_CATALOG_DUPLICATION", "APP_AEM_V2_INSTALLATION_PROMOTION", "APP_ENGAGED_VIEW_CONVERSIONS_DUPLICATION", "ASC_AUTOMATION", "ASC_BUDGET_OPTIMIZATION", "ASC_CREATION_PACKAGE", "ASC_FRAGMENTATION_V2", "ASC_PRECREATE", "ASPECT_RATIO", "ATLEAST_6_PLACEMENTS", "AUCTION_OVERLAP", "AUCTION_OVERLAP_CONSOLIDATION", "AUDIENCE_EXPANSION", "AUDIENCE_EXPANSION_GEORADIUS", "AUDIENCE_EXPANSION_LOOKALIKE", "AUDIENCE_EXPANSION_RETARGETING", "AUDIENCE_LEARNING_LIMITED", "AUTOBID_TO_MANUAL_BID", "AUTOFLOW_OPT_IN", "AUTOFLOW_OPT_IN_FALLBACK_DUPLICATION_FLOW", "AUTOFLOW_OPT_IN_V2", "AUTOMATIC_PLACEMENTS", "AUTOMATIC_PLACEMENTS_V2", "AUTO_BID", "AUTO_CAT_SELECTION_ENHANCEMENT", "BACKGROUND_GENERATION", "BID_LIMITED_SENSITIVE", "BID_LIMITED_STARVING", "BLENDED_ADS", "BLENDED_ADS_DUPLICATION", "BLENDED_ADS_FOR_SHOPS_ADS_DUPLICATION", "BPBAA_WITH_CAPI_UPSELL", "BROADGEO_AM_UPSELL_GUIDANCE", "BROAD_TARGETING", "BUDGET_AMORTIZATION", "BUDGET_LIMITED", "BUDGET_REALLOCATION", "CALL_ADS_DAYPARTING_L3_RECOMMENDATION", "CAMPAIGN_GUIDANCE_NAVIGATOR_REELS_TIPS", "CAPI", "CAPI_CRM_FUNNEL", "CAPI_CRM_GUIDANCE", "CAPI_CRM_SETUP", "CAPI_EVENT_COVERAGE", "CAPI_PENETRATION", "CAPI_PERFORMANCE_MATCH_KEY", "CAPI_PERFORMANCE_MATCH_KEY_V2", "CASH_REWARDS_OPT_IN", "CATALOG_DYNAMIC_MEDIA", "CATALOG_MATCH_RATE", "COMMERCE_SHOPS_ADS_DUPLICATION", "CONNECTED_SOURCES", "CONNECTED_SOURCES_DUPLICATION", "CONNECT_FACEBOOK_PAGE_TO_INSTAGRAM", "CONNECT_FACEBOOK_PAGE_TO_WHATSAPP", "CONVERSION_LEADS_OPTIMIZATION", "CONVERSION_LEADS_OPTIMIZATION_DUPLICATION", "CONVERSION_LEAD_ADS", "COST_GOAL", "COST_GOAL_BUDGET_LIMITED", "COST_GOAL_CPA_LIMITED", "COST_PER_RESULT", "CREATION_PACKAGE_UPGRADE_TO_ASC", "CREATION_PACKAGE_UPGRADE_TO_CTX", "CREATION_PACKAGE_UPGRADE_TO_TLA", "CREATION_PACKAGE_UPGRADE_TO_TMC", "CREATIVE_BADGE", "CREATIVE_DIVERSITY", "CREATIVE_FATIGUE", "CREATIVE_FATIGUE_DUPLICATION", "CREATIVE_FATIGUE_HOURLY", "CREATIVE_LIMITED", "CREATIVE_LIMITED_DUPLICATION", "CREATIVE_LIMITED_HOURLY", "CREATOR_ADS_PA_CONVERSION", "CTA", "CTM_AD_OBJECTIVE_GROWTH", "CTM_LEADS_OPTIMIZATION_UPSELL", "CTX_BUDGET_OPTIMIZATION", "CTX_CREATION_PACKAGE", "CTX_CTA_UPGRADE_IN_DUPLICATION", "CTX_CTMPO_UPGRADE", "CTX_CTWAPO_UPGRADE", "CTX_GUIDANCE", "CTX_HVS", "CTX_MULTI_MESSAGE_DESTINATION", "CTX_PRECREATE", "CTX_PRODUCT_EXTENSION_DUPLICATION", "CTX_SABR_CBO", "CTX_SABR_NON_CBO", "CTX_SMART_DEFAULTING", "CTX_ZO_CBO", "CTX_ZO_NON_CBO", "CUSTOM_AUDIENCE_RELAXATION", "DA_ADVANTAGE_PLUS_CREATIVE_INFO_LABELS", "DA_DUPLICATION_PRODUCT_TAGS", "DEAD_LINK", "DEFRAGMENTATION_ACB", "DEFRAGMENTATION_ACB_DUPLICATION", "DEFRAGMENTATION_USING_VALUE_RULES_TEST_V2", "DELIVERY_ERROR", "DELIVERY_WARNING", "DYNAMIC_ADVANTAGE_CAMPAIGN_BUDGET", "ECOSYSTEM_BID_REDUCE_L1_CARDINALITY", "ENABLE_WHATS_APP_ADS_DATA_SHARING", "ENGAGED_VIEW_CONVERSIONS_CREATION", "EVC_APP_DUPLICATION_UPGRADE", "EVC_WEB_DUPLICATION_UPGRADE", "FRAGMENTATION", "FRAGMENTATION_RESOLUTION_UPDATE", "FRAGMENTATION_V2", "GENERATIVE_UNCROP_DUPLICATION", "GEN_AI_MVP", "GES_TEST", "GUIDANCE_CENTER_CODE_GEN", "HEURISTIC_DEFAULT_DURATION", "HIGH_COST", "HISTORICAL_BENCHMARK", "IAA_ROAS_OPTIMIZATION", "IG_MULTI_ADS", "IG_SURFACES_MANUAL_PLACEMENTS", "INCREMENTAL_ATTRIBUTION", "INSTANT_FORMS_LEADS", "LANDING_PAGE_VIEW", "LANDING_PAGE_VIEW_OPTIMIZATION_GOAL", "LANDING_PAGE_VIEW_PRECREATE", "LEAD_ADS_GUIDANCE", "LEARNING_LIMITED", "LEARNING_PAUSE_FRICTION", "LEARNING_PHASE_BUDGET_EDITS", "LOW_BUDGET_UTILIZATION", "LOW_OUTCOME", "MERLIN_GUIDANCE", "MESSAGING_EVENTS", "MESSAGING_EVENTS_PRECREATE", "MESSAGING_PARTNERS", "MESSAGING_PARTNERS_PRECREATE", "META_VERIFIED_ADS_PERFORMANCE_GUIDANCE", "MISSING_OR_INVALID_PARAMETERS", "MIXED_FORMATS", "MIXED_PA_COMBINE_ADSETS", "MMT_CAROUSEL_TO_VIDEO", "MOBILE_FIRST_CREATIVE", "MOBILE_FIRST_VIDEO", "MR_AEMV2SUB_KCONSOLIDATION", "MULTI_ADVERTISER_ADS", "MULTI_TEXT", "MUSIC", "NOT_APPLICABLE", "NO_DELIVERY_STATUS", "OFFSITE_CONVERSION", "OFFSITE_CONVERSION_BASED_ON_SIGNALS", "OPTIMAL_BAU", "OUTCOME_FORECASTER_BUDGET_RECOMMENDATION", "OUTCOME_FORECASTER_SHADOW_LOGGING", "PAYMENT_METHOD", "PERFORMANT_CREATIVE_REELS_OPT_IN", "PFR_L1_INLINE_MMT", "PIXELLESS_LPV_OPTIMIZATION_GOAL", "PIXEL_OPTIMIZATION_AAM", "PIXEL_OPTIMIZATION_AAM_PRECREATE", "PIXEL_OPTIMIZATION_HIE", "PIXEL_OPTIMIZATION_HIE_PRECREATE", "PIXEL_SETUP", "PIXEL_SETUP_PRECREATE", "PIXEL_UPSELL", "PLACEMENTS_LIQUIDITY_AUTOMATIC_GUIDANCE", "PREDICTIVE_CREATIVE_LIMITED", "PREDICTIVE_CREATIVE_LIMITED_HOURLY", "PREPARING_STATUS", "PRODUCT_SET_BOOSTING", "PROMO_ADS_UPSELL_GUIDANCE", "PURCHASE_OPTIMIZATION", "RAPID_LEARNING_LIMITED", "RAPID_LEARNING_PHASE", "REACH_OPTIMIZATION_GOAL", "REACH_OPTIMIZATION_GOAL_PRECREATE", "REELS_DUPLICATION_UPSELL", "REELS_MUSIC_DUPLICATION", "REELS_PC_AND_MOBILE_FIRST_CREATIVE", "REELS_PC_RECOMMENDATION", "REELS_PERFORMANT_CREATIVE", "REELS_PLACEMENT", "REVERT", "REVIEW_CREATIVE_DUPLICATED_REJECTED_ADS", "SABR_DEFAULT_DURATION", "SALES_CONVERSION", "SAVED_AUDIENCE", "SCALE_GOOD_CAMPAIGN", "SCALE_GOOD_CAMPAIGN_DUPLICATION", "SCALE_GOOD_CAMPAIGN_SMB", "SCALE_GOOD_CTX_CAMPAIGN", "SEASONAL_CAMPAIGNS", "SEMANTIC_BASED_AUDIENCE_DUPLICATION", "SEMANTIC_BASED_AUDIENCE_EXPANSION", "SETUP_PIXEL", "SHOPS_ADS", "SHOPS_ADS_DUPLICATION", "SHOPS_ADS_SAOFF", "SHOPS_ADS_TRAFFIC_CAP_SETTINGS", "SHOP_ADS_V2", "SIGNALS_DOWN_FUNNEL_EVENT_OPTIMIZATION", "SIGNALS_GROWTH_CAPI", "SIGNALS_GROWTH_CAPI_PRECREATE", "SIGNALS_GROWTH_CAPI_TABLE", "SIGNALS_GROWTH_CAPI_V2", "SIMILAR_ADVERTISER_BUDGET_RECOMMENDATION", "SITE_EXTENSIONS_DUPLICATION", "SIX_PLUS_MANUAL_PLACEMENTS", "SIX_PLUS_PLACEMENTS_DUPLICATION", "SPEND_LIMIT", "SYD_TEST_MODE", "TAILORED_LEAD_AD_CAMPAIGN", "TAILORED_MESSAGES_CAMPAIGN", "TARGETING_CREATIVE_FRAGMENTATION", "TLA_CREATION_PACKAGE", "TOP_ADSETS_WITH_ADS_UNDER_CAP", "TOP_CAMPAIGNS_WITH_ADS_UNDER_CAP", "TWO_P_GUIDANCE_CARD_AAA", "TWO_P_GUIDANCE_CARD_AUTO_PLACEMENT", "TWO_P_GUIDANCE_CARD_CBO_OFF", "TWO_P_GUIDANCE_CARD_CTM_PREFLIGHT", "UNCROP_IMAGE", "UNECONOMICAL_ADS_THROTTLING", "UNIFIED_INBOX", "UNUSED_BUDGET", "VALUE_DIAGNOSTICS_GUIDANCE", "VALUE_OPTIMIZATION_GOAL", "VALUE_RULES_GUIDANCE", "VIDEO_LENGTH", "VIDEO_VIEWS_UPSELL", "VIDEO_VIEWS_UPSELL_PRECREATE", "VO_VT_1D_DEFAULTING", "WA_MESSAGING_PARTNERS", "WA_MESSAGING_PARTNERS_PRECREATE", "WEB_ENGAGED_VIEW_CONVERSIONS", "WTWA_UPSELL_IN_DUPLICATION", "ZERO_CONVERSION", "ZERO_IMPRESSION", "ZERO_OUTCOME_BUDGET"},
				},
				"show_breakdown_by_actor": map[string]any{
					"type":        "boolean",
					"description": "show_breakdown_by_actor parameter",
				},
			}),
			mcp.Description("Parameters object containing: page_id (string), recommendation_type (enum) [AAC_CREATION_PACKAGE, AB_TEST, ACCOUNT_ERROR, ACCOUNT_NEEDS_CREDIT, ACCOUNT_SPEND_LIMIT, ...], show_breakdown_by_actor (boolean)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountAdVolume objects. Available fields: actor_id, actor_name, ad_limit_scope_business, ad_limit_scope_business_manager_id, ad_limit_set_by_page_admin, ads_running_or_in_review_count, ads_running_or_in_review_count_subject_to_limit_set_by_page, current_account_ads_running_or_in_review_count, future_limit_activation_date, future_limit_on_ads_running_or_in_review, limit_on_ads_running_or_in_review, recommendations"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_ads_volumeTool)

	// adaccount_get_adsbylabels tool
	// Available fields for Ad: account_id, ad_active_time, ad_review_feedback, ad_schedule_end_time, ad_schedule_start_time, adlabels, adset, adset_id, bid_amount, bid_info, bid_type, campaign, campaign_id, configured_status, conversion_domain, conversion_specs, created_time, creative, creative_asset_groups_spec, demolink_hash, display_sequence, effective_status, engagement_audience, failed_delivery_checks, id, issues_info, last_updated_by_app_id, name, placement, preview_shareable_link, priority, recommendations, source_ad, source_ad_id, status, targeting, tracking_and_conversion_with_defaults, tracking_specs, updated_time
	// Params object accepts: ad_label_ids (list<string>), operator (adaccountadsbylabels_operator_enum_param)
	adaccount_get_adsbylabelsTool := mcp.NewTool("adaccount_get_adsbylabels",
		mcp.WithDescription("GET adsbylabels for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"ad_label_ids": map[string]any{
					"type":        "array",
					"description": "ad_label_ids parameter",
					"required":    true,
					"items":       map[string]any{"type": "string"},
				},
				"operator": map[string]any{
					"type":        "string",
					"description": "operator parameter",
					"enum":        []string{"ALL", "ANY"},
				},
			}),
			mcp.Description("Parameters object containing: ad_label_ids (array<string>) [required], operator (enum) [ALL, ANY]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Ad objects. Available fields: account_id, ad_active_time, ad_review_feedback, ad_schedule_end_time, ad_schedule_start_time, adlabels, adset, adset_id, bid_amount, bid_info, bid_type, campaign, campaign_id, configured_status, conversion_domain (and 24 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adsbylabelsTool)

	// adaccount_get_adsets tool
	// Available fields for AdSet: account_id, adlabels, adset_schedule, asset_feed_id, attribution_spec, bid_adjustments, bid_amount, bid_constraints, bid_info, bid_strategy, billing_event, brand_safety_config, budget_remaining, campaign, campaign_active_time, campaign_attribution, campaign_id, configured_status, created_time, creative_sequence, creative_sequence_repetition_pattern, daily_budget, daily_min_spend_target, daily_spend_cap, destination_type, dsa_beneficiary, dsa_payor, effective_status, end_time, existing_customer_budget_percentage, frequency_control_specs, full_funnel_exploration_mode, id, instagram_user_id, is_ba_skip_delayed_eligible, is_budget_schedule_enabled, is_dynamic_creative, is_incremental_attribution_enabled, issues_info, learning_stage_info, lifetime_budget, lifetime_imps, lifetime_min_spend_target, lifetime_spend_cap, max_budget_spend_percentage, min_budget_spend_percentage, multi_optimization_goal_weight, name, optimization_goal, optimization_sub_event, pacing_type, promoted_object, recommendations, recurring_budget_semantics, regional_regulated_categories, regional_regulation_identities, review_feedback, rf_prediction_id, source_adset, source_adset_id, start_time, status, targeting, targeting_optimization_types, time_based_ad_rotation_id_blocks, time_based_ad_rotation_intervals, updated_time, use_new_app_click
	// Params object accepts: date_preset (adaccountadsets_date_preset_enum_param), effective_status (list<adaccountadsets_effective_status_enum_param>), is_completed (bool), time_range (map), updated_since (int)
	adaccount_get_adsetsTool := mcp.NewTool("adaccount_get_adsets",
		mcp.WithDescription("GET adsets for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"date_preset": map[string]any{
					"type":        "string",
					"description": "date_preset parameter",
					"enum":        []string{"DATA_MAXIMUM", "LAST_14D", "LAST_28D", "LAST_30D", "LAST_3D", "LAST_7D", "LAST_90D", "LAST_MONTH", "LAST_QUARTER", "LAST_WEEK_MON_SUN", "LAST_WEEK_SUN_SAT", "LAST_YEAR", "MAXIMUM", "THIS_MONTH", "THIS_QUARTER", "THIS_WEEK_MON_TODAY", "THIS_WEEK_SUN_TODAY", "THIS_YEAR", "TODAY", "YESTERDAY"},
				},
				"effective_status": map[string]any{
					"type":        "array",
					"description": "effective_status parameter",
					"enum":        []string{"ACTIVE", "ADSET_PAUSED", "ARCHIVED", "CAMPAIGN_PAUSED", "DELETED", "DISAPPROVED", "IN_PROCESS", "PAUSED", "PENDING_BILLING_INFO", "PENDING_REVIEW", "PREAPPROVED", "WITH_ISSUES"},
					"items":       map[string]any{"type": "string"},
				},
				"is_completed": map[string]any{
					"type":        "boolean",
					"description": "is_completed parameter",
				},
				"time_range": map[string]any{
					"type":        "object",
					"description": "time_range parameter",
				},
				"updated_since": map[string]any{
					"type":        "integer",
					"description": "updated_since parameter",
				},
			}),
			mcp.Description("Parameters object containing: date_preset (enum) [DATA_MAXIMUM, LAST_14D, LAST_28D, LAST_30D, LAST_3D, ...], effective_status (array<enum>) [ACTIVE, ADSET_PAUSED, ARCHIVED, CAMPAIGN_PAUSED, DELETED, ...], is_completed (boolean), time_range (object), updated_since (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdSet objects. Available fields: account_id, adlabels, adset_schedule, asset_feed_id, attribution_spec, bid_adjustments, bid_amount, bid_constraints, bid_info, bid_strategy, billing_event, brand_safety_config, budget_remaining, campaign, campaign_active_time (and 53 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adsetsTool)

	// adaccount_post_adsets tool
	// Params object accepts: adlabels (list<Object>), adset_schedule (list<Object>), attribution_spec (list<map>), bid_adjustments (Object), bid_amount (int), bid_constraints (map<string, Object>), bid_strategy (adaccountadsets_bid_strategy_enum_param), billing_event (adaccountadsets_billing_event_enum_param), budget_source (adaccountadsets_budget_source_enum_param), budget_split_set_id (string), campaign_attribution (Object), campaign_id (string), campaign_spec (Object), creative_sequence (list<string>), creative_sequence_repetition_pattern (adaccountadsets_creative_sequence_repetition_pattern_enum_param), daily_budget (unsigned int), daily_imps (unsigned int), daily_min_spend_target (unsigned int), daily_spend_cap (unsigned int), date_format (string), destination_type (adaccountadsets_destination_type_enum_param), dsa_beneficiary (string), dsa_payor (string), end_time (datetime), execution_options (list<adaccountadsets_execution_options_enum_param>), existing_customer_budget_percentage (unsigned int), frequency_control_specs (list<Object>), full_funnel_exploration_mode (adaccountadsets_full_funnel_exploration_mode_enum_param), is_ba_skip_delayed_eligible (bool), is_dynamic_creative (bool), is_incremental_attribution_enabled (bool), is_sac_cfca_terms_certified (bool), lifetime_budget (unsigned int), lifetime_imps (unsigned int), lifetime_min_spend_target (unsigned int), lifetime_spend_cap (unsigned int), line_number (unsigned int), max_budget_spend_percentage (unsigned int), min_budget_spend_percentage (unsigned int), multi_optimization_goal_weight (adaccountadsets_multi_optimization_goal_weight_enum_param), name (string), optimization_goal (adaccountadsets_optimization_goal_enum_param), optimization_sub_event (adaccountadsets_optimization_sub_event_enum_param), pacing_type (list<string>), promoted_object (Object), rb_prediction_id (string), regional_regulated_categories (list<adaccountadsets_regional_regulated_categories_enum_param>), regional_regulation_identities (map), rf_prediction_id (string), source_adset_id (string), start_time (datetime), status (adaccountadsets_status_enum_param), targeting (Targeting), time_based_ad_rotation_id_blocks (list<list<unsigned int>>), time_based_ad_rotation_intervals (list<unsigned int>), time_start (datetime), time_stop (datetime), topline_id (string), tune_for_category (adaccountadsets_tune_for_category_enum_param)
	adaccount_post_adsetsTool := mcp.NewTool("adaccount_post_adsets",
		mcp.WithDescription("POST adsets for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"adlabels": map[string]any{
					"type":        "array",
					"description": "adlabels parameter",
					"items":       map[string]any{"type": "object"},
				},
				"adset_schedule": map[string]any{
					"type":        "array",
					"description": "adset_schedule parameter",
					"items":       map[string]any{"type": "object"},
				},
				"attribution_spec": map[string]any{
					"type":        "array",
					"description": "attribution_spec parameter",
					"items":       map[string]any{"type": "object"},
				},
				"bid_adjustments": map[string]any{
					"type":        "object",
					"description": "bid_adjustments parameter",
				},
				"bid_amount": map[string]any{
					"type":        "integer",
					"description": "bid_amount parameter",
				},
				"bid_constraints": map[string]any{
					"type":        "string",
					"description": "bid_constraints parameter",
				},
				"bid_strategy": map[string]any{
					"type":        "string",
					"description": "bid_strategy parameter",
					"enum":        []string{"COST_CAP", "LOWEST_COST_WITHOUT_CAP", "LOWEST_COST_WITH_BID_CAP", "LOWEST_COST_WITH_MIN_ROAS"},
				},
				"billing_event": map[string]any{
					"type":        "string",
					"description": "billing_event parameter",
					"enum":        []string{"APP_INSTALLS", "CLICKS", "IMPRESSIONS", "LINK_CLICKS", "LISTING_INTERACTION", "NONE", "OFFER_CLAIMS", "PAGE_LIKES", "POST_ENGAGEMENT", "PURCHASE", "THRUPLAY"},
				},
				"budget_source": map[string]any{
					"type":        "string",
					"description": "budget_source parameter",
					"enum":        []string{"NONE", "RMN"},
				},
				"budget_split_set_id": map[string]any{
					"type":        "string",
					"description": "budget_split_set_id parameter",
				},
				"campaign_attribution": map[string]any{
					"type":        "object",
					"description": "campaign_attribution parameter",
				},
				"campaign_id": map[string]any{
					"type":        "string",
					"description": "campaign_id parameter",
				},
				"campaign_spec": map[string]any{
					"type":        "object",
					"description": "campaign_spec parameter",
				},
				"creative_sequence": map[string]any{
					"type":        "array",
					"description": "creative_sequence parameter",
					"items":       map[string]any{"type": "string"},
				},
				"creative_sequence_repetition_pattern": map[string]any{
					"type":        "string",
					"description": "creative_sequence_repetition_pattern parameter",
					"enum":        []string{"FULL_SEQUENCE", "LAST_AD"},
				},
				"daily_budget": map[string]any{
					"type":        "integer",
					"description": "daily_budget parameter",
				},
				"daily_imps": map[string]any{
					"type":        "integer",
					"description": "daily_imps parameter",
				},
				"daily_min_spend_target": map[string]any{
					"type":        "integer",
					"description": "daily_min_spend_target parameter",
				},
				"daily_spend_cap": map[string]any{
					"type":        "integer",
					"description": "daily_spend_cap parameter",
				},
				"date_format": map[string]any{
					"type":        "string",
					"description": "date_format parameter",
				},
				"destination_type": map[string]any{
					"type":        "string",
					"description": "destination_type parameter",
					"enum":        []string{"APP", "APPLINKS_AUTOMATIC", "FACEBOOK", "FACEBOOK_LIVE", "FACEBOOK_PAGE", "IMAGINE", "INSTAGRAM_DIRECT", "INSTAGRAM_LIVE", "INSTAGRAM_PROFILE", "INSTAGRAM_PROFILE_AND_FACEBOOK_PAGE", "MESSAGING_INSTAGRAM_DIRECT_MESSENGER", "MESSAGING_INSTAGRAM_DIRECT_MESSENGER_WHATSAPP", "MESSAGING_INSTAGRAM_DIRECT_WHATSAPP", "MESSAGING_MESSENGER_WHATSAPP", "MESSENGER", "ON_AD", "ON_EVENT", "ON_PAGE", "ON_POST", "ON_VIDEO", "SHOP_AUTOMATIC", "WEBSITE", "WHATSAPP"},
				},
				"dsa_beneficiary": map[string]any{
					"type":        "string",
					"description": "dsa_beneficiary parameter",
				},
				"dsa_payor": map[string]any{
					"type":        "string",
					"description": "dsa_payor parameter",
				},
				"end_time": map[string]any{
					"type":        "string",
					"description": "end_time parameter",
				},
				"execution_options": map[string]any{
					"type":        "array",
					"description": "execution_options parameter",
					"enum":        []string{"include_recommendations", "validate_only"},
					"items":       map[string]any{"type": "string"},
				},
				"existing_customer_budget_percentage": map[string]any{
					"type":        "integer",
					"description": "existing_customer_budget_percentage parameter",
				},
				"frequency_control_specs": map[string]any{
					"type":        "array",
					"description": "frequency_control_specs parameter",
					"items":       map[string]any{"type": "object"},
				},
				"full_funnel_exploration_mode": map[string]any{
					"type":        "string",
					"description": "full_funnel_exploration_mode parameter",
					"enum":        []string{"EXTENDED_EXPLORATION", "LIMITED_EXPLORATION", "NONE_EXPLORATION"},
				},
				"is_ba_skip_delayed_eligible": map[string]any{
					"type":        "boolean",
					"description": "is_ba_skip_delayed_eligible parameter",
				},
				"is_dynamic_creative": map[string]any{
					"type":        "boolean",
					"description": "is_dynamic_creative parameter",
				},
				"is_incremental_attribution_enabled": map[string]any{
					"type":        "boolean",
					"description": "is_incremental_attribution_enabled parameter",
				},
				"is_sac_cfca_terms_certified": map[string]any{
					"type":        "boolean",
					"description": "is_sac_cfca_terms_certified parameter",
				},
				"lifetime_budget": map[string]any{
					"type":        "integer",
					"description": "lifetime_budget parameter",
				},
				"lifetime_imps": map[string]any{
					"type":        "integer",
					"description": "lifetime_imps parameter",
				},
				"lifetime_min_spend_target": map[string]any{
					"type":        "integer",
					"description": "lifetime_min_spend_target parameter",
				},
				"lifetime_spend_cap": map[string]any{
					"type":        "integer",
					"description": "lifetime_spend_cap parameter",
				},
				"line_number": map[string]any{
					"type":        "integer",
					"description": "line_number parameter",
				},
				"max_budget_spend_percentage": map[string]any{
					"type":        "integer",
					"description": "max_budget_spend_percentage parameter",
				},
				"min_budget_spend_percentage": map[string]any{
					"type":        "integer",
					"description": "min_budget_spend_percentage parameter",
				},
				"multi_optimization_goal_weight": map[string]any{
					"type":        "string",
					"description": "multi_optimization_goal_weight parameter",
					"enum":        []string{"BALANCED", "PREFER_EVENT", "PREFER_INSTALL", "UNDEFINED"},
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"optimization_goal": map[string]any{
					"type":        "string",
					"description": "optimization_goal parameter",
					"enum":        []string{"ADVERTISER_SILOED_VALUE", "AD_RECALL_LIFT", "APP_INSTALLS", "APP_INSTALLS_AND_OFFSITE_CONVERSIONS", "CONVERSATIONS", "DERIVED_EVENTS", "ENGAGED_USERS", "EVENT_RESPONSES", "IMPRESSIONS", "IN_APP_VALUE", "LANDING_PAGE_VIEWS", "LEAD_GENERATION", "LINK_CLICKS", "MEANINGFUL_CALL_ATTEMPT", "MESSAGING_APPOINTMENT_CONVERSION", "MESSAGING_PURCHASE_CONVERSION", "NONE", "OFFSITE_CONVERSIONS", "PAGE_LIKES", "POST_ENGAGEMENT", "PROFILE_AND_PAGE_ENGAGEMENT", "PROFILE_VISIT", "QUALITY_CALL", "QUALITY_LEAD", "REACH", "REMINDERS_SET", "SUBSCRIBERS", "THRUPLAY", "VALUE", "VISIT_INSTAGRAM_PROFILE"},
				},
				"optimization_sub_event": map[string]any{
					"type":        "string",
					"description": "optimization_sub_event parameter",
					"enum":        []string{"NONE", "TRAVEL_INTENT", "TRAVEL_INTENT_BUCKET_01", "TRAVEL_INTENT_BUCKET_02", "TRAVEL_INTENT_BUCKET_03", "TRAVEL_INTENT_BUCKET_04", "TRAVEL_INTENT_BUCKET_05", "TRAVEL_INTENT_NO_DESTINATION_INTENT", "TRIP_CONSIDERATION", "VIDEO_SOUND_ON"},
				},
				"pacing_type": map[string]any{
					"type":        "array",
					"description": "pacing_type parameter",
					"items":       map[string]any{"type": "string"},
				},
				"promoted_object": map[string]any{
					"type":        "object",
					"description": "promoted_object parameter",
				},
				"rb_prediction_id": map[string]any{
					"type":        "string",
					"description": "rb_prediction_id parameter",
				},
				"regional_regulated_categories": map[string]any{
					"type":        "array",
					"description": "regional_regulated_categories parameter",
					"enum":        []string{"0", "1", "2", "3", "4", "5", "6"},
					"items":       map[string]any{"type": "string"},
				},
				"regional_regulation_identities": map[string]any{
					"type":        "object",
					"description": "regional_regulation_identities parameter",
				},
				"rf_prediction_id": map[string]any{
					"type":        "string",
					"description": "rf_prediction_id parameter",
				},
				"source_adset_id": map[string]any{
					"type":        "string",
					"description": "source_adset_id parameter",
				},
				"start_time": map[string]any{
					"type":        "string",
					"description": "start_time parameter",
				},
				"status": map[string]any{
					"type":        "string",
					"description": "status parameter",
					"enum":        []string{"ACTIVE", "ARCHIVED", "DELETED", "PAUSED"},
				},
				"targeting": map[string]any{
					"type":        "string",
					"description": "targeting parameter",
				},
				"time_based_ad_rotation_id_blocks": map[string]any{
					"type":        "array",
					"description": "time_based_ad_rotation_id_blocks parameter",
					"items":       map[string]any{"type": "array"},
				},
				"time_based_ad_rotation_intervals": map[string]any{
					"type":        "array",
					"description": "time_based_ad_rotation_intervals parameter",
					"items":       map[string]any{"type": "integer"},
				},
				"time_start": map[string]any{
					"type":        "string",
					"description": "time_start parameter",
				},
				"time_stop": map[string]any{
					"type":        "string",
					"description": "time_stop parameter",
				},
				"topline_id": map[string]any{
					"type":        "string",
					"description": "topline_id parameter",
				},
				"tune_for_category": map[string]any{
					"type":        "string",
					"description": "tune_for_category parameter",
					"enum":        []string{"CREDIT", "EMPLOYMENT", "FINANCIAL_PRODUCTS_SERVICES", "HOUSING", "ISSUES_ELECTIONS_POLITICS", "NONE", "ONLINE_GAMBLING_AND_GAMING"},
				},
			}),
			mcp.Description("Parameters object containing: adlabels (array<object>), adset_schedule (array<object>), attribution_spec (array<object>), bid_adjustments (object), bid_amount (integer), bid_constraints (map<string, Object>), bid_strategy (enum) [COST_CAP, LOWEST_COST_WITHOUT_CAP, LOWEST_COST_WITH_BID_CAP, LOWEST_COST_WITH_MIN_ROAS], billing_event (enum) [APP_INSTALLS, CLICKS, IMPRESSIONS, LINK_CLICKS, LISTING_INTERACTION, ...], budget_source (enum) [NONE, RMN], budget_split_set_id (string), campaign_attribution (object), campaign_id (string), campaign_spec (object), creative_sequence (array<string>), creative_sequence_repetition_pattern (enum) [FULL_SEQUENCE, LAST_AD], daily_budget (integer), daily_imps (integer), daily_min_spend_target (integer), daily_spend_cap (integer), date_format (string), destination_type (enum) [APP, APPLINKS_AUTOMATIC, FACEBOOK, FACEBOOK_LIVE, FACEBOOK_PAGE, ...], dsa_beneficiary (string), dsa_payor (string), end_time (datetime), execution_options (array<enum>) [include_recommendations, validate_only], existing_customer_budget_percentage (integer), frequency_control_specs (array<object>), full_funnel_exploration_mode (enum) [EXTENDED_EXPLORATION, LIMITED_EXPLORATION, NONE_EXPLORATION], is_ba_skip_delayed_eligible (boolean), is_dynamic_creative (boolean), is_incremental_attribution_enabled (boolean), is_sac_cfca_terms_certified (boolean), lifetime_budget (integer), lifetime_imps (integer), lifetime_min_spend_target (integer), lifetime_spend_cap (integer), line_number (integer), max_budget_spend_percentage (integer), min_budget_spend_percentage (integer), multi_optimization_goal_weight (enum) [BALANCED, PREFER_EVENT, PREFER_INSTALL, UNDEFINED], name (string) [required], optimization_goal (enum) [ADVERTISER_SILOED_VALUE, AD_RECALL_LIFT, APP_INSTALLS, APP_INSTALLS_AND_OFFSITE_CONVERSIONS, CONVERSATIONS, ...], optimization_sub_event (enum) [NONE, TRAVEL_INTENT, TRAVEL_INTENT_BUCKET_01, TRAVEL_INTENT_BUCKET_02, TRAVEL_INTENT_BUCKET_03, ...], pacing_type (array<string>), promoted_object (object), rb_prediction_id (string), regional_regulated_categories (array<enum>) [0, 1, 2, 3, 4, ...], regional_regulation_identities (object), rf_prediction_id (string), source_adset_id (string), start_time (datetime), status (enum) [ACTIVE, ARCHIVED, DELETED, PAUSED], targeting (Targeting), time_based_ad_rotation_id_blocks (array<array<integer>>), time_based_ad_rotation_intervals (array<integer>), time_start (datetime), time_stop (datetime), topline_id (string), tune_for_category (enum) [CREDIT, EMPLOYMENT, FINANCIAL_PRODUCTS_SERVICES, HOUSING, ISSUES_ELECTIONS_POLITICS, ...]"),
		),
	)
	tools = append(tools, adaccount_post_adsetsTool)

	// adaccount_get_adsetsbylabels tool
	// Available fields for AdSet: account_id, adlabels, adset_schedule, asset_feed_id, attribution_spec, bid_adjustments, bid_amount, bid_constraints, bid_info, bid_strategy, billing_event, brand_safety_config, budget_remaining, campaign, campaign_active_time, campaign_attribution, campaign_id, configured_status, created_time, creative_sequence, creative_sequence_repetition_pattern, daily_budget, daily_min_spend_target, daily_spend_cap, destination_type, dsa_beneficiary, dsa_payor, effective_status, end_time, existing_customer_budget_percentage, frequency_control_specs, full_funnel_exploration_mode, id, instagram_user_id, is_ba_skip_delayed_eligible, is_budget_schedule_enabled, is_dynamic_creative, is_incremental_attribution_enabled, issues_info, learning_stage_info, lifetime_budget, lifetime_imps, lifetime_min_spend_target, lifetime_spend_cap, max_budget_spend_percentage, min_budget_spend_percentage, multi_optimization_goal_weight, name, optimization_goal, optimization_sub_event, pacing_type, promoted_object, recommendations, recurring_budget_semantics, regional_regulated_categories, regional_regulation_identities, review_feedback, rf_prediction_id, source_adset, source_adset_id, start_time, status, targeting, targeting_optimization_types, time_based_ad_rotation_id_blocks, time_based_ad_rotation_intervals, updated_time, use_new_app_click
	// Params object accepts: ad_label_ids (list<string>), operator (adaccountadsetsbylabels_operator_enum_param)
	adaccount_get_adsetsbylabelsTool := mcp.NewTool("adaccount_get_adsetsbylabels",
		mcp.WithDescription("GET adsetsbylabels for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"ad_label_ids": map[string]any{
					"type":        "array",
					"description": "ad_label_ids parameter",
					"required":    true,
					"items":       map[string]any{"type": "string"},
				},
				"operator": map[string]any{
					"type":        "string",
					"description": "operator parameter",
					"enum":        []string{"ALL", "ANY"},
				},
			}),
			mcp.Description("Parameters object containing: ad_label_ids (array<string>) [required], operator (enum) [ALL, ANY]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdSet objects. Available fields: account_id, adlabels, adset_schedule, asset_feed_id, attribution_spec, bid_adjustments, bid_amount, bid_constraints, bid_info, bid_strategy, billing_event, brand_safety_config, budget_remaining, campaign, campaign_active_time (and 53 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adsetsbylabelsTool)

	// adaccount_get_adspixels tool
	// Available fields for AdsPixel: automatic_matching_fields, can_proxy, code, config, creation_time, creator, data_use_setting, description, duplicate_entries, enable_auto_assign_to_accounts, enable_automatic_matching, event_stats, event_time_max, event_time_min, first_party_cookie_status, has_1p_pixel_event, id, is_consolidated_container, is_created_by_business, is_crm, is_mta_use, is_restricted_use, is_unavailable, last_fired_time, last_upload_app, last_upload_app_changed_time, match_rate_approx, matched_entries, name, owner_ad_account, owner_business, usage, user_access_expire_time, valid_entries
	// Params object accepts: sort_by (adaccountadspixels_sort_by_enum_param)
	adaccount_get_adspixelsTool := mcp.NewTool("adaccount_get_adspixels",
		mcp.WithDescription("GET adspixels for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"sort_by": map[string]any{
					"type":        "string",
					"description": "sort_by parameter",
					"enum":        []string{"LAST_FIRED_TIME", "NAME"},
				},
			}),
			mcp.Description("Parameters object containing: sort_by (enum) [LAST_FIRED_TIME, NAME]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdsPixel objects. Available fields: automatic_matching_fields, can_proxy, code, config, creation_time, creator, data_use_setting, description, duplicate_entries, enable_auto_assign_to_accounts, enable_automatic_matching, event_stats, event_time_max, event_time_min, first_party_cookie_status (and 19 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_adspixelsTool)

	// adaccount_post_adspixels tool
	// Params object accepts: name (string)
	adaccount_post_adspixelsTool := mcp.NewTool("adaccount_post_adspixels",
		mcp.WithDescription("POST adspixels for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
			}),
			mcp.Description("Parameters object containing: name (string)"),
		),
	)
	tools = append(tools, adaccount_post_adspixelsTool)

	// adaccount_get_advertisable_applications tool
	// Available fields for Application: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline, auth_dialog_perms_explanation, auth_referral_default_activity_privacy, auth_referral_enabled, auth_referral_extended_perms, auth_referral_friend_perms, auth_referral_response_type, auth_referral_user_perms, auto_event_mapping_android, auto_event_mapping_ios, auto_event_setup_enabled, auto_log_app_events_default, auto_log_app_events_enabled, business, canvas_fluid_height, canvas_fluid_width, canvas_url, category, client_config, company, configured_ios_sso, contact_email, created_time, creator_uid, daily_active_users, daily_active_users_rank, deauth_callback_url, default_share_mode, description, enigma_config, financial_id, gdpv4_chrome_custom_tabs_enabled, gdpv4_enabled, gdpv4_nux_content, gdpv4_nux_enabled, has_messenger_product, hosting_url, icon_url, id, ios_bundle_id, ios_sdk_dialog_flows, ios_sdk_error_categories, ios_sfvc_attr, ios_supports_native_proxy_auth_flow, ios_supports_system_auth, ipad_app_store_id, iphone_app_store_id, latest_sdk_version, link, logging_token, logo_url, migrations, mobile_profile_section_url, mobile_web_url, monthly_active_users, monthly_active_users_rank, name, namespace, object_store_urls, owner_business, page_tab_default_name, page_tab_url, photo_url, privacy_policy_url, profile_section_url, property_id, protected_mode_rules, real_time_mode_devices, restrictions, restrictive_data_filter_params, restrictive_data_filter_rules, sdk_update_message, seamless_login, secure_canvas_url, secure_page_tab_url, server_ip_whitelist, smart_login_bookmark_icon_url, smart_login_menu_icon_url, social_discovery, subcategory, suggested_events_setting, supported_platforms, supports_apprequests_fast_app_switch, supports_attribution, supports_implicit_sdk_logging, suppress_native_ios_gdp, terms_of_service_url, url_scheme_suffix, user_support_email, user_support_url, website_url, weekly_active_users
	// Params object accepts: app_id (string), business_id (string)
	adaccount_get_advertisable_applicationsTool := mcp.NewTool("adaccount_get_advertisable_applications",
		mcp.WithDescription("GET advertisable_applications for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"app_id": map[string]any{
					"type":        "string",
					"description": "app_id parameter",
				},
				"business_id": map[string]any{
					"type":        "string",
					"description": "business_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: app_id (string), business_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Application objects. Available fields: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline (and 91 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_advertisable_applicationsTool)

	// adaccount_delete_advideos tool
	// Params object accepts: video_id (string)
	adaccount_delete_advideosTool := mcp.NewTool("adaccount_delete_advideos",
		mcp.WithDescription("DELETE advideos for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"video_id": map[string]any{
					"type":        "string",
					"description": "video_id parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: video_id (string) [required]"),
		),
	)
	tools = append(tools, adaccount_delete_advideosTool)

	// adaccount_get_advideos tool
	// Available fields for AdVideo: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html, embeddable, event, expiration, format, from, icon, id, is_crosspost_video, is_crossposting_eligible, is_episode, is_instagram_eligible, is_reference_only, length, live_audience_count, live_status, music_video_copyright, permalink_url, picture, place, post_id, post_views, premiere_living_room_status, privacy, published, scheduled_publish_time, source, spherical, status, title, universal_video_id, updated_time, views
	// Params object accepts: max_aspect_ratio (float), maxheight (unsigned int), maxlength (unsigned int), maxwidth (unsigned int), min_aspect_ratio (float), minheight (unsigned int), minlength (unsigned int), minwidth (unsigned int), title (string)
	adaccount_get_advideosTool := mcp.NewTool("adaccount_get_advideos",
		mcp.WithDescription("GET advideos for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"max_aspect_ratio": map[string]any{
					"type":        "number",
					"description": "max_aspect_ratio parameter",
				},
				"maxheight": map[string]any{
					"type":        "integer",
					"description": "maxheight parameter",
				},
				"maxlength": map[string]any{
					"type":        "integer",
					"description": "maxlength parameter",
				},
				"maxwidth": map[string]any{
					"type":        "integer",
					"description": "maxwidth parameter",
				},
				"min_aspect_ratio": map[string]any{
					"type":        "number",
					"description": "min_aspect_ratio parameter",
				},
				"minheight": map[string]any{
					"type":        "integer",
					"description": "minheight parameter",
				},
				"minlength": map[string]any{
					"type":        "integer",
					"description": "minlength parameter",
				},
				"minwidth": map[string]any{
					"type":        "integer",
					"description": "minwidth parameter",
				},
				"title": map[string]any{
					"type":        "string",
					"description": "title parameter",
				},
			}),
			mcp.Description("Parameters object containing: max_aspect_ratio (number), maxheight (integer), maxlength (integer), maxwidth (integer), min_aspect_ratio (number), minheight (integer), minlength (integer), minwidth (integer), title (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdVideo objects. Available fields: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html (and 32 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_advideosTool)

	// adaccount_post_advideos tool
	// Params object accepts: application_id (string), asked_fun_fact_prompt_id (unsigned int), audio_story_wave_animation_handle (string), chunk_session_id (string), composer_entry_picker (string), composer_entry_point (string), composer_entry_time (unsigned int), composer_session_events_log (string), composer_session_id (string), composer_source_surface (string), composer_type (string), container_type (adaccountadvideos_container_type_enum_param), content_category (adaccountadvideos_content_category_enum_param), creative_tools (string), description (string), embeddable (bool), end_offset (unsigned int), fbuploader_video_file_chunk (string), file_size (unsigned int), file_url (string), fisheye_video_cropped (bool), formatting (adaccountadvideos_formatting_enum_param), fov (unsigned int), front_z_rotation (float), fun_fact_prompt_id (string), fun_fact_toastee_id (unsigned int), guide (list<list<unsigned int>>), guide_enabled (bool), initial_heading (unsigned int), initial_pitch (unsigned int), instant_game_entry_point_data (string), is_boost_intended (bool), is_group_linking_post (bool), is_partnership_ad (bool), is_voice_clip (bool), location_source_id (string), name (string), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_suggestion_mechanism (string), original_fov (unsigned int), original_projection_type (adaccountadvideos_original_projection_type_enum_param), partnership_ad_ad_code (string), publish_event_id (unsigned int), referenced_sticker_id (string), replace_video_id (string), slideshow_spec (map), source (string), source_instagram_media_id (string), spherical (bool), start_offset (unsigned int), swap_mode (adaccountadvideos_swap_mode_enum_param), text_format_metadata (string), thumb (file), time_since_original_post (unsigned int), title (string), transcode_setting_properties (string), unpublished_content_type (adaccountadvideos_unpublished_content_type_enum_param), upload_phase (adaccountadvideos_upload_phase_enum_param), upload_session_id (string), upload_setting_properties (string), video_file_chunk (string), video_id_original (string), video_start_time_ms (unsigned int), waterfall_id (string)
	adaccount_post_advideosTool := mcp.NewTool("adaccount_post_advideos",
		mcp.WithDescription("POST advideos for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"application_id": map[string]any{
					"type":        "string",
					"description": "application_id parameter",
				},
				"asked_fun_fact_prompt_id": map[string]any{
					"type":        "integer",
					"description": "asked_fun_fact_prompt_id parameter",
				},
				"audio_story_wave_animation_handle": map[string]any{
					"type":        "string",
					"description": "audio_story_wave_animation_handle parameter",
				},
				"chunk_session_id": map[string]any{
					"type":        "string",
					"description": "chunk_session_id parameter",
				},
				"composer_entry_picker": map[string]any{
					"type":        "string",
					"description": "composer_entry_picker parameter",
				},
				"composer_entry_point": map[string]any{
					"type":        "string",
					"description": "composer_entry_point parameter",
				},
				"composer_entry_time": map[string]any{
					"type":        "integer",
					"description": "composer_entry_time parameter",
				},
				"composer_session_events_log": map[string]any{
					"type":        "string",
					"description": "composer_session_events_log parameter",
				},
				"composer_session_id": map[string]any{
					"type":        "string",
					"description": "composer_session_id parameter",
				},
				"composer_source_surface": map[string]any{
					"type":        "string",
					"description": "composer_source_surface parameter",
				},
				"composer_type": map[string]any{
					"type":        "string",
					"description": "composer_type parameter",
				},
				"container_type": map[string]any{
					"type":        "string",
					"description": "container_type parameter",
					"enum":        []string{"ACO_VIDEO_VARIATION", "ADS_AI_GENERATED", "AD_BREAK_PREVIEW", "AD_DERIVATIVE", "AD_LIBRARY_WATERMARK", "ALBUM_MULTIMEDIA_POST", "ALOHA_SUPERFRAME", "APP_REREVIEW_SCREENCAST", "APP_REVIEW_SCREENCAST", "ASSET_MANAGER", "ATLAS_VIDEO", "AUDIO_BROADCAST", "AUDIO_COMMENT", "BROADCAST", "CANVAS", "CMS_MEDIA_MANAGER", "CONTAINED_POST_ATTACHMENT", "CONTAINED_POST_AUDIO_BROADCAST", "CONTAINED_POST_COPYRIGHT_REFERENCE_BROADCAST", "COPYRIGHT_REFERENCE_BROADCAST", "COPYRIGHT_REFERENCE_IG_XPOST_VIDEO", "COPYRIGHT_REFERENCE_VIDEO", "CREATION_ML_PRECREATION", "CREATOR_FAN_CHALLENGE", "CREATOR_STOREFRONT_PERSONALIZED_VIDEO", "DATAGENIX_VIDEO", "DCO_AD_ASSET_FEED", "DCO_AUTOGEN_VIDEO", "DCO_TRIMMED_VIDEO", "DIM_SUM", "DIRECTED_POST_ATTACHMENT", "DIRECT_INBOX", "DROPS_SHOPPING_EVENT_PAGE", "DYNAMIC_ITEM_VIDEO", "DYNAMIC_TEMPLATE_VIDEO", "EVENT_COVER_VIDEO", "EVENT_TOUR", "FACECAST_DVR", "FB_AVATAR_ANIMATED_SATP", "FB_COLLECTIBLE_VIDEO", "FB_SHORTS", "FB_SHORTS_CONTENT_REMIXABLE", "FB_SHORTS_GROUP_POST", "FB_SHORTS_LINKED_PRODUCT", "FB_SHORTS_PMV_POST", "FB_SHORTS_POST", "FB_SHORTS_REMIX_POST", "FUNDRAISER_COVER_VIDEO", "GAME_CLIP", "GIF_TO_VIDEO", "GOODWILL_ANNIVERSARY_DEPRECATED", "GOODWILL_ANNIVERSARY_PROMOTION_DEPRECATED", "GOODWILL_VIDEO_CONTAINED_SHARE", "GOODWILL_VIDEO_PROMOTION", "GOODWILL_VIDEO_SHARE", "GOODWILL_VIDEO_TOKEN_REQUIRED", "GROUP_POST", "HEURISTIC_CLUSTER_VIDEO", "HIGHLIGHT_CLIP_VIDEO", "HORIZON_WORLDS_TV", "HUDDLE_BROADCAST", "IG_REELS_XPV", "IG_STORIES_READER", "INJECTABLE", "INSPIRATION_VIDEO", "INSTAGRAM_VIDEO_COPY", "INSTANT_APPLICATION_PREVIEW", "INSTANT_ARTICLE", "ISSUE_MODULE", "LEARN", "LEGACY", "LEGACY_CONTAINED_POST_BROADCAST", "LIVE_AUDIO_ROOM_BROADCAST", "LIVE_CLIP_PREVIEW", "LIVE_CLIP_WORKCHAT", "LIVE_CREATIVE_KIT_VIDEO", "LIVE_PHOTO", "LOOK_NOW_DEPRECATED", "MARKETPLACE_LISTING_VIDEO", "MARKETPLACE_PRE_RECORDED_VIDEO", "MOMENTS_VIDEO", "MUSIC_CLIP", "MUSIC_CLIP_IN_COMMENT", "MUSIC_CLIP_IN_LIGHTWEIGHT_STATUS", "MUSIC_CLIP_IN_MSGR_NOTE", "MUSIC_CLIP_IN_POLL_OPTION", "MUSIC_CLIP_ON_DATING_PROFILE", "NEO_ASYNC_GAME_VIDEO", "NEW_CONTAINED_POST_BROADCAST", "NO_STORY", "OCULUS_CREATOR_PORTAL", "OCULUS_VENUES_BROADCAST", "ORIGINALITY_SELF_ADVOCACY", "PAGES_COVER_VIDEO", "PAGE_REVIEW_SCREENCAST", "PAGE_SLIDESHOW_VIDEO", "PAID_CONTENT_PREVIEW", "PAID_CONTENT_VIDEO", "PAID_CONTENT_VIDEO__POST", "PIXELCLOUD", "PODCAST_HIGHLIGHT", "PODCAST_ML_PREVIEW", "PODCAST_ML_PREVIEW_NO_NEWSFEED_STORY", "PODCAST_RSS", "PODCAST_RSS_EPHEMERAL", "PODCAST_RSS_NO_NEWSFEED_STORY", "PODCAST_VOICES", "PODCAST_VOICES_NO_NEWSFEED_STORY", "PREMIERE_SOURCE", "PREMIUM_MUSIC_VIDEO_CLIP", "PREMIUM_MUSIC_VIDEO_CROPPED_CLIP", "PREMIUM_MUSIC_VIDEO_NO_NEWSFEED_STORY", "PREMIUM_MUSIC_VIDEO_WITH_NEWSFEED_STORY", "PRIVATE_GALLERY_VIDEO", "PRODUCT_VIDEO", "PROFILE_COVER_VIDEO", "PROFILE_INTRO_CARD", "PROFILE_VIDEO", "PROTON", "QUICK_CLIP_WORKPLACE_POST", "QUICK_PROMOTION", "REPLACE_VIDEO", "SALES_CLIENT_INTERACTION", "SHOWREEL_NATIVE_DUMMY_VIDEO", "SLIDESHOW_ANIMOTO", "SLIDESHOW_SHAKR", "SLIDESHOW_VARIATION_VIDEO", "SOUND_PLATFORM_STREAM", "SRT_ATTACHMENT", "STORIES_VIDEO", "STORYLINE", "STORYLINE_WITH_EXTERNAL_MUSIC", "STORY_ARCHIVE_VIDEO", "STORY_CARD_TEMPLATE", "STREAM_HIGHLIGHTS_VIDEO", "TAROT_DIGEST", "TEMPORARY_UNLISTED", "TEMP_VIDEO_COPYRIGHT_SCAN", "UNLISTED", "UNLISTED_OCULUS", "VIDEO_COMMENT", "VIDEO_COMPOSITION_VARIATION", "VIDEO_CREATIVE_EDITOR_AUTOGEN_AD_VIDEO", "VIDEO_SUPERRES", "VOICES_ARTICLE_VIDEO", "VU_GENERATED_VIDEO", "WOODHENGE", "WORK_KNOWLEDGE_VIDEO", "YOUR_DAY"},
				},
				"content_category": map[string]any{
					"type":        "string",
					"description": "content_category parameter",
					"enum":        []string{"BEAUTY_FASHION", "BUSINESS", "CARS_TRUCKS", "COMEDY", "CUTE_ANIMALS", "ENTERTAINMENT", "FAMILY", "FOOD_HEALTH", "HOME", "LIFESTYLE", "MUSIC", "NEWS", "OTHER", "POLITICS", "SCIENCE", "SPORTS", "TECHNOLOGY", "VIDEO_GAMING"},
				},
				"creative_tools": map[string]any{
					"type":        "string",
					"description": "creative_tools parameter",
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"embeddable": map[string]any{
					"type":        "boolean",
					"description": "embeddable parameter",
				},
				"end_offset": map[string]any{
					"type":        "integer",
					"description": "end_offset parameter",
				},
				"fbuploader_video_file_chunk": map[string]any{
					"type":        "string",
					"description": "fbuploader_video_file_chunk parameter",
				},
				"file_size": map[string]any{
					"type":        "integer",
					"description": "file_size parameter",
				},
				"file_url": map[string]any{
					"type":        "string",
					"description": "file_url parameter",
				},
				"fisheye_video_cropped": map[string]any{
					"type":        "boolean",
					"description": "fisheye_video_cropped parameter",
				},
				"formatting": map[string]any{
					"type":        "string",
					"description": "formatting parameter",
					"enum":        []string{"MARKDOWN", "PLAINTEXT"},
				},
				"fov": map[string]any{
					"type":        "integer",
					"description": "fov parameter",
				},
				"front_z_rotation": map[string]any{
					"type":        "number",
					"description": "front_z_rotation parameter",
				},
				"fun_fact_prompt_id": map[string]any{
					"type":        "string",
					"description": "fun_fact_prompt_id parameter",
				},
				"fun_fact_toastee_id": map[string]any{
					"type":        "integer",
					"description": "fun_fact_toastee_id parameter",
				},
				"guide": map[string]any{
					"type":        "array",
					"description": "guide parameter",
					"items":       map[string]any{"type": "array"},
				},
				"guide_enabled": map[string]any{
					"type":        "boolean",
					"description": "guide_enabled parameter",
				},
				"initial_heading": map[string]any{
					"type":        "integer",
					"description": "initial_heading parameter",
				},
				"initial_pitch": map[string]any{
					"type":        "integer",
					"description": "initial_pitch parameter",
				},
				"instant_game_entry_point_data": map[string]any{
					"type":        "string",
					"description": "instant_game_entry_point_data parameter",
				},
				"is_boost_intended": map[string]any{
					"type":        "boolean",
					"description": "is_boost_intended parameter",
				},
				"is_group_linking_post": map[string]any{
					"type":        "boolean",
					"description": "is_group_linking_post parameter",
				},
				"is_partnership_ad": map[string]any{
					"type":        "boolean",
					"description": "is_partnership_ad parameter",
				},
				"is_voice_clip": map[string]any{
					"type":        "boolean",
					"description": "is_voice_clip parameter",
				},
				"location_source_id": map[string]any{
					"type":        "string",
					"description": "location_source_id parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"og_action_type_id": map[string]any{
					"type":        "string",
					"description": "og_action_type_id parameter",
				},
				"og_icon_id": map[string]any{
					"type":        "string",
					"description": "og_icon_id parameter",
				},
				"og_object_id": map[string]any{
					"type":        "string",
					"description": "og_object_id parameter",
				},
				"og_phrase": map[string]any{
					"type":        "string",
					"description": "og_phrase parameter",
				},
				"og_suggestion_mechanism": map[string]any{
					"type":        "string",
					"description": "og_suggestion_mechanism parameter",
				},
				"original_fov": map[string]any{
					"type":        "integer",
					"description": "original_fov parameter",
				},
				"original_projection_type": map[string]any{
					"type":        "string",
					"description": "original_projection_type parameter",
					"enum":        []string{"cubemap", "equirectangular", "half_equirectangular"},
				},
				"partnership_ad_ad_code": map[string]any{
					"type":        "string",
					"description": "partnership_ad_ad_code parameter",
				},
				"publish_event_id": map[string]any{
					"type":        "integer",
					"description": "publish_event_id parameter",
				},
				"referenced_sticker_id": map[string]any{
					"type":        "string",
					"description": "referenced_sticker_id parameter",
				},
				"replace_video_id": map[string]any{
					"type":        "string",
					"description": "replace_video_id parameter",
				},
				"slideshow_spec": map[string]any{
					"type":        "object",
					"description": "slideshow_spec parameter",
				},
				"source": map[string]any{
					"type":        "string",
					"description": "source parameter",
				},
				"source_instagram_media_id": map[string]any{
					"type":        "string",
					"description": "source_instagram_media_id parameter",
				},
				"spherical": map[string]any{
					"type":        "boolean",
					"description": "spherical parameter",
				},
				"start_offset": map[string]any{
					"type":        "integer",
					"description": "start_offset parameter",
				},
				"swap_mode": map[string]any{
					"type":        "string",
					"description": "swap_mode parameter",
					"enum":        []string{"replace"},
				},
				"text_format_metadata": map[string]any{
					"type":        "string",
					"description": "text_format_metadata parameter",
				},
				"thumb": map[string]any{
					"type":        "string",
					"description": "thumb parameter",
				},
				"time_since_original_post": map[string]any{
					"type":        "integer",
					"description": "time_since_original_post parameter",
				},
				"title": map[string]any{
					"type":        "string",
					"description": "title parameter",
				},
				"transcode_setting_properties": map[string]any{
					"type":        "string",
					"description": "transcode_setting_properties parameter",
				},
				"unpublished_content_type": map[string]any{
					"type":        "string",
					"description": "unpublished_content_type parameter",
					"enum":        []string{"ADS_POST", "DRAFT", "INLINE_CREATED", "PUBLISHED", "REVIEWABLE_BRANDED_CONTENT", "SCHEDULED", "SCHEDULED_RECURRING"},
				},
				"upload_phase": map[string]any{
					"type":        "string",
					"description": "upload_phase parameter",
					"enum":        []string{"cancel", "finish", "start", "transfer"},
				},
				"upload_session_id": map[string]any{
					"type":        "string",
					"description": "upload_session_id parameter",
				},
				"upload_setting_properties": map[string]any{
					"type":        "string",
					"description": "upload_setting_properties parameter",
				},
				"video_file_chunk": map[string]any{
					"type":        "string",
					"description": "video_file_chunk parameter",
				},
				"video_id_original": map[string]any{
					"type":        "string",
					"description": "video_id_original parameter",
				},
				"video_start_time_ms": map[string]any{
					"type":        "integer",
					"description": "video_start_time_ms parameter",
				},
				"waterfall_id": map[string]any{
					"type":        "string",
					"description": "waterfall_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: application_id (string), asked_fun_fact_prompt_id (integer), audio_story_wave_animation_handle (string), chunk_session_id (string), composer_entry_picker (string), composer_entry_point (string), composer_entry_time (integer), composer_session_events_log (string), composer_session_id (string), composer_source_surface (string), composer_type (string), container_type (enum) [ACO_VIDEO_VARIATION, ADS_AI_GENERATED, AD_BREAK_PREVIEW, AD_DERIVATIVE, AD_LIBRARY_WATERMARK, ...], content_category (enum) [BEAUTY_FASHION, BUSINESS, CARS_TRUCKS, COMEDY, CUTE_ANIMALS, ...], creative_tools (string), description (string), embeddable (boolean), end_offset (integer), fbuploader_video_file_chunk (string), file_size (integer), file_url (string), fisheye_video_cropped (boolean), formatting (enum) [MARKDOWN, PLAINTEXT], fov (integer), front_z_rotation (number), fun_fact_prompt_id (string), fun_fact_toastee_id (integer), guide (array<array<integer>>), guide_enabled (boolean), initial_heading (integer), initial_pitch (integer), instant_game_entry_point_data (string), is_boost_intended (boolean), is_group_linking_post (boolean), is_partnership_ad (boolean), is_voice_clip (boolean), location_source_id (string), name (string), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_suggestion_mechanism (string), original_fov (integer), original_projection_type (enum) [cubemap, equirectangular, half_equirectangular], partnership_ad_ad_code (string), publish_event_id (integer), referenced_sticker_id (string), replace_video_id (string), slideshow_spec (object), source (string), source_instagram_media_id (string), spherical (boolean), start_offset (integer), swap_mode (enum) [replace], text_format_metadata (string), thumb (file), time_since_original_post (integer), title (string), transcode_setting_properties (string), unpublished_content_type (enum) [ADS_POST, DRAFT, INLINE_CREATED, PUBLISHED, REVIEWABLE_BRANDED_CONTENT, ...], upload_phase (enum) [cancel, finish, start, transfer], upload_session_id (string), upload_setting_properties (string), video_file_chunk (string), video_id_original (string), video_start_time_ms (integer), waterfall_id (string)"),
		),
	)
	tools = append(tools, adaccount_post_advideosTool)

	// adaccount_get_affectedadsets tool
	// Available fields for AdSet: account_id, adlabels, adset_schedule, asset_feed_id, attribution_spec, bid_adjustments, bid_amount, bid_constraints, bid_info, bid_strategy, billing_event, brand_safety_config, budget_remaining, campaign, campaign_active_time, campaign_attribution, campaign_id, configured_status, created_time, creative_sequence, creative_sequence_repetition_pattern, daily_budget, daily_min_spend_target, daily_spend_cap, destination_type, dsa_beneficiary, dsa_payor, effective_status, end_time, existing_customer_budget_percentage, frequency_control_specs, full_funnel_exploration_mode, id, instagram_user_id, is_ba_skip_delayed_eligible, is_budget_schedule_enabled, is_dynamic_creative, is_incremental_attribution_enabled, issues_info, learning_stage_info, lifetime_budget, lifetime_imps, lifetime_min_spend_target, lifetime_spend_cap, max_budget_spend_percentage, min_budget_spend_percentage, multi_optimization_goal_weight, name, optimization_goal, optimization_sub_event, pacing_type, promoted_object, recommendations, recurring_budget_semantics, regional_regulated_categories, regional_regulation_identities, review_feedback, rf_prediction_id, source_adset, source_adset_id, start_time, status, targeting, targeting_optimization_types, time_based_ad_rotation_id_blocks, time_based_ad_rotation_intervals, updated_time, use_new_app_click
	adaccount_get_affectedadsetsTool := mcp.NewTool("adaccount_get_affectedadsets",
		mcp.WithDescription("GET affectedadsets for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdSet objects. Available fields: account_id, adlabels, adset_schedule, asset_feed_id, attribution_spec, bid_adjustments, bid_amount, bid_constraints, bid_info, bid_strategy, billing_event, brand_safety_config, budget_remaining, campaign, campaign_active_time (and 53 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_affectedadsetsTool)

	// adaccount_delete_agencies tool
	// Params object accepts: business (string)
	adaccount_delete_agenciesTool := mcp.NewTool("adaccount_delete_agencies",
		mcp.WithDescription("DELETE agencies for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required]"),
		),
	)
	tools = append(tools, adaccount_delete_agenciesTool)

	// adaccount_get_agencies tool
	// Available fields for Business: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id, two_factor_type, updated_by, updated_time, user_access_expire_time, verification_status, vertical, vertical_id
	adaccount_get_agenciesTool := mcp.NewTool("adaccount_get_agencies",
		mcp.WithDescription("GET agencies for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Business objects. Available fields: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id (and 7 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_agenciesTool)

	// adaccount_post_agencies tool
	// Params object accepts: business (string), permitted_tasks (list<adaccountagencies_permitted_tasks_enum_param>)
	adaccount_post_agenciesTool := mcp.NewTool("adaccount_post_agencies",
		mcp.WithDescription("POST agencies for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
					"required":    true,
				},
				"permitted_tasks": map[string]any{
					"type":        "array",
					"description": "permitted_tasks parameter",
					"enum":        []string{"AA_ANALYZE", "ADVERTISE", "ANALYZE", "DRAFT", "MANAGE"},
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required], permitted_tasks (array<enum>) [AA_ANALYZE, ADVERTISE, ANALYZE, DRAFT, MANAGE]"),
		),
	)
	tools = append(tools, adaccount_post_agenciesTool)

	// adaccount_get_applications tool
	// Available fields for Application: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline, auth_dialog_perms_explanation, auth_referral_default_activity_privacy, auth_referral_enabled, auth_referral_extended_perms, auth_referral_friend_perms, auth_referral_response_type, auth_referral_user_perms, auto_event_mapping_android, auto_event_mapping_ios, auto_event_setup_enabled, auto_log_app_events_default, auto_log_app_events_enabled, business, canvas_fluid_height, canvas_fluid_width, canvas_url, category, client_config, company, configured_ios_sso, contact_email, created_time, creator_uid, daily_active_users, daily_active_users_rank, deauth_callback_url, default_share_mode, description, enigma_config, financial_id, gdpv4_chrome_custom_tabs_enabled, gdpv4_enabled, gdpv4_nux_content, gdpv4_nux_enabled, has_messenger_product, hosting_url, icon_url, id, ios_bundle_id, ios_sdk_dialog_flows, ios_sdk_error_categories, ios_sfvc_attr, ios_supports_native_proxy_auth_flow, ios_supports_system_auth, ipad_app_store_id, iphone_app_store_id, latest_sdk_version, link, logging_token, logo_url, migrations, mobile_profile_section_url, mobile_web_url, monthly_active_users, monthly_active_users_rank, name, namespace, object_store_urls, owner_business, page_tab_default_name, page_tab_url, photo_url, privacy_policy_url, profile_section_url, property_id, protected_mode_rules, real_time_mode_devices, restrictions, restrictive_data_filter_params, restrictive_data_filter_rules, sdk_update_message, seamless_login, secure_canvas_url, secure_page_tab_url, server_ip_whitelist, smart_login_bookmark_icon_url, smart_login_menu_icon_url, social_discovery, subcategory, suggested_events_setting, supported_platforms, supports_apprequests_fast_app_switch, supports_attribution, supports_implicit_sdk_logging, suppress_native_ios_gdp, terms_of_service_url, url_scheme_suffix, user_support_email, user_support_url, website_url, weekly_active_users
	adaccount_get_applicationsTool := mcp.NewTool("adaccount_get_applications",
		mcp.WithDescription("GET applications for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Application objects. Available fields: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline (and 91 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_applicationsTool)

	// adaccount_delete_assigned_users tool
	// Params object accepts: user (int)
	adaccount_delete_assigned_usersTool := mcp.NewTool("adaccount_delete_assigned_users",
		mcp.WithDescription("DELETE assigned_users for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"user": map[string]any{
					"type":        "integer",
					"description": "user parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: user (integer) [required]"),
		),
	)
	tools = append(tools, adaccount_delete_assigned_usersTool)

	// adaccount_get_assigned_users tool
	// Available fields for AssignedUser: business, id, name, user_type
	// Params object accepts: business (string)
	adaccount_get_assigned_usersTool := mcp.NewTool("adaccount_get_assigned_users",
		mcp.WithDescription("GET assigned_users for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AssignedUser objects. Available fields: business, id, name, user_type"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_assigned_usersTool)

	// adaccount_post_assigned_users tool
	// Params object accepts: tasks (list<adaccountassigned_users_tasks_enum_param>), user (int)
	adaccount_post_assigned_usersTool := mcp.NewTool("adaccount_post_assigned_users",
		mcp.WithDescription("POST assigned_users for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"tasks": map[string]any{
					"type":        "array",
					"description": "tasks parameter",
					"enum":        []string{"AA_ANALYZE", "ADVERTISE", "ANALYZE", "DRAFT", "MANAGE"},
					"items":       map[string]any{"type": "string"},
				},
				"user": map[string]any{
					"type":        "integer",
					"description": "user parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: tasks (array<enum>) [AA_ANALYZE, ADVERTISE, ANALYZE, DRAFT, MANAGE], user (integer) [required]"),
		),
	)
	tools = append(tools, adaccount_post_assigned_usersTool)

	// adaccount_post_async_batch_requests tool
	// Params object accepts: adbatch (list<Object>), name (string)
	adaccount_post_async_batch_requestsTool := mcp.NewTool("adaccount_post_async_batch_requests",
		mcp.WithDescription("POST async_batch_requests for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"adbatch": map[string]any{
					"type":        "array",
					"description": "adbatch parameter",
					"required":    true,
					"items":       map[string]any{"type": "object"},
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: adbatch (array<object>) [required], name (string) [required]"),
		),
	)
	tools = append(tools, adaccount_post_async_batch_requestsTool)

	// adaccount_get_async_requests tool
	// Available fields for AsyncRequest: id, result, status, type
	// Params object accepts: status (adaccountasync_requests_status_enum_param), type (adaccountasync_requests_type_enum_param)
	adaccount_get_async_requestsTool := mcp.NewTool("adaccount_get_async_requests",
		mcp.WithDescription("GET async_requests for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"status": map[string]any{
					"type":        "string",
					"description": "status parameter",
					"enum":        []string{"ERROR", "EXECUTING", "FINISHED", "INITIALIZED"},
				},
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"ASYNC_ADGROUP_CREATION", "BATCH_API", "DRAFTS"},
				},
			}),
			mcp.Description("Parameters object containing: status (enum) [ERROR, EXECUTING, FINISHED, INITIALIZED], type (enum) [ASYNC_ADGROUP_CREATION, BATCH_API, DRAFTS]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AsyncRequest objects. Available fields: id, result, status, type"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_async_requestsTool)

	// adaccount_get_asyncadcreatives tool
	// Available fields for AdAsyncRequestSet: canceled_count, created_time, error_count, id, in_progress_count, initial_count, is_completed, name, notification_mode, notification_result, notification_status, notification_uri, owner_id, success_count, total_count, updated_time
	// Params object accepts: is_completed (bool)
	adaccount_get_asyncadcreativesTool := mcp.NewTool("adaccount_get_asyncadcreatives",
		mcp.WithDescription("GET asyncadcreatives for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"is_completed": map[string]any{
					"type":        "boolean",
					"description": "is_completed parameter",
				},
			}),
			mcp.Description("Parameters object containing: is_completed (boolean)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAsyncRequestSet objects. Available fields: canceled_count, created_time, error_count, id, in_progress_count, initial_count, is_completed, name, notification_mode, notification_result, notification_status, notification_uri, owner_id, success_count, total_count (and 1 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_asyncadcreativesTool)

	// adaccount_post_asyncadcreatives tool
	// Params object accepts: creative_spec (AdCreative), name (string), notification_mode (adaccountasyncadcreatives_notification_mode_enum_param), notification_uri (string)
	adaccount_post_asyncadcreativesTool := mcp.NewTool("adaccount_post_asyncadcreatives",
		mcp.WithDescription("POST asyncadcreatives for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"creative_spec": map[string]any{
					"type":        "string",
					"description": "creative_spec parameter",
					"required":    true,
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"notification_mode": map[string]any{
					"type":        "string",
					"description": "notification_mode parameter",
					"enum":        []string{"OFF", "ON_COMPLETE"},
				},
				"notification_uri": map[string]any{
					"type":        "string",
					"description": "notification_uri parameter",
				},
			}),
			mcp.Description("Parameters object containing: creative_spec (AdCreative) [required], name (string) [required], notification_mode (enum) [OFF, ON_COMPLETE], notification_uri (string)"),
		),
	)
	tools = append(tools, adaccount_post_asyncadcreativesTool)

	// adaccount_get_asyncadrequestsets tool
	// Available fields for AdAsyncRequestSet: canceled_count, created_time, error_count, id, in_progress_count, initial_count, is_completed, name, notification_mode, notification_result, notification_status, notification_uri, owner_id, success_count, total_count, updated_time
	// Params object accepts: is_completed (bool)
	adaccount_get_asyncadrequestsetsTool := mcp.NewTool("adaccount_get_asyncadrequestsets",
		mcp.WithDescription("GET asyncadrequestsets for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"is_completed": map[string]any{
					"type":        "boolean",
					"description": "is_completed parameter",
				},
			}),
			mcp.Description("Parameters object containing: is_completed (boolean)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAsyncRequestSet objects. Available fields: canceled_count, created_time, error_count, id, in_progress_count, initial_count, is_completed, name, notification_mode, notification_result, notification_status, notification_uri, owner_id, success_count, total_count (and 1 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_asyncadrequestsetsTool)

	// adaccount_post_asyncadrequestsets tool
	// Params object accepts: ad_specs (list<map>), name (string), notification_mode (adaccountasyncadrequestsets_notification_mode_enum_param), notification_uri (string)
	adaccount_post_asyncadrequestsetsTool := mcp.NewTool("adaccount_post_asyncadrequestsets",
		mcp.WithDescription("POST asyncadrequestsets for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"ad_specs": map[string]any{
					"type":        "array",
					"description": "ad_specs parameter",
					"required":    true,
					"items":       map[string]any{"type": "object"},
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"notification_mode": map[string]any{
					"type":        "string",
					"description": "notification_mode parameter",
					"enum":        []string{"OFF", "ON_COMPLETE"},
				},
				"notification_uri": map[string]any{
					"type":        "string",
					"description": "notification_uri parameter",
				},
			}),
			mcp.Description("Parameters object containing: ad_specs (array<object>) [required], name (string) [required], notification_mode (enum) [OFF, ON_COMPLETE], notification_uri (string)"),
		),
	)
	tools = append(tools, adaccount_post_asyncadrequestsetsTool)

	// adaccount_get_audience_funnel tool
	// Available fields for AudienceFunnel: audience_type_param_name, audience_type_param_tags, custom_audience_groups_info
	adaccount_get_audience_funnelTool := mcp.NewTool("adaccount_get_audience_funnel",
		mcp.WithDescription("GET audience_funnel for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AudienceFunnel objects. Available fields: audience_type_param_name, audience_type_param_tags, custom_audience_groups_info"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_audience_funnelTool)

	// adaccount_post_block_list_drafts tool
	// Params object accepts: publisher_urls_file (file)
	adaccount_post_block_list_draftsTool := mcp.NewTool("adaccount_post_block_list_drafts",
		mcp.WithDescription("POST block_list_drafts for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"publisher_urls_file": map[string]any{
					"type":        "string",
					"description": "publisher_urls_file parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: publisher_urls_file (file) [required]"),
		),
	)
	tools = append(tools, adaccount_post_block_list_draftsTool)

	// adaccount_post_brand_safety_content_filter_levels tool
	// Params object accepts: brand_safety_content_filter_levels (list<adaccountbrand_safety_content_filter_levels_brand_safety_content_filter_levels_enum_param>), business_id (string)
	adaccount_post_brand_safety_content_filter_levelsTool := mcp.NewTool("adaccount_post_brand_safety_content_filter_levels",
		mcp.WithDescription("POST brand_safety_content_filter_levels for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"brand_safety_content_filter_levels": map[string]any{
					"type":        "array",
					"description": "brand_safety_content_filter_levels parameter",
					"required":    true,
					"enum":        []string{"AN_RELAXED", "AN_STANDARD", "AN_STRICT", "FACEBOOK_RELAXED", "FACEBOOK_STANDARD", "FACEBOOK_STRICT", "FEED_DNM", "FEED_RELAXED", "FEED_STANDARD", "FEED_STRICT", "UNINITIALIZED", "UNKNOWN"},
					"items":       map[string]any{"type": "string"},
				},
				"business_id": map[string]any{
					"type":        "string",
					"description": "business_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: brand_safety_content_filter_levels (array<enum>) [AN_RELAXED, AN_STANDARD, AN_STRICT, FACEBOOK_RELAXED, FACEBOOK_STANDARD, ...] [required], business_id (string)"),
		),
	)
	tools = append(tools, adaccount_post_brand_safety_content_filter_levelsTool)

	// adaccount_get_broadtargetingcategories tool
	// Available fields for BroadTargetingCategories: category_description, id, name, parent_category, path, size_lower_bound, size_upper_bound, source, type, type_name, untranslated_name, untranslated_parent_name
	// Params object accepts: custom_categories_only (bool)
	adaccount_get_broadtargetingcategoriesTool := mcp.NewTool("adaccount_get_broadtargetingcategories",
		mcp.WithDescription("GET broadtargetingcategories for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"custom_categories_only": map[string]any{
					"type":        "boolean",
					"description": "custom_categories_only parameter",
				},
			}),
			mcp.Description("Parameters object containing: custom_categories_only (boolean)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for BroadTargetingCategories objects. Available fields: category_description, id, name, parent_category, path, size_lower_bound, size_upper_bound, source, type, type_name, untranslated_name, untranslated_parent_name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_broadtargetingcategoriesTool)

	// adaccount_get_businessprojects tool
	// Available fields for BusinessProject: business, created_time, creator, id, name
	// Params object accepts: business (string)
	adaccount_get_businessprojectsTool := mcp.NewTool("adaccount_get_businessprojects",
		mcp.WithDescription("GET businessprojects for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
				},
			}),
			mcp.Description("Parameters object containing: business (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for BusinessProject objects. Available fields: business, created_time, creator, id, name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_businessprojectsTool)

	// adaccount_delete_campaigns tool
	// Params object accepts: before_date (datetime), delete_offset (unsigned int), delete_strategy (adaccountcampaigns_delete_strategy_enum_param), object_count (int)
	adaccount_delete_campaignsTool := mcp.NewTool("adaccount_delete_campaigns",
		mcp.WithDescription("DELETE campaigns for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"before_date": map[string]any{
					"type":        "string",
					"description": "before_date parameter",
				},
				"delete_offset": map[string]any{
					"type":        "integer",
					"description": "delete_offset parameter",
				},
				"delete_strategy": map[string]any{
					"type":        "string",
					"description": "delete_strategy parameter",
					"required":    true,
					"enum":        []string{"DELETE_ANY", "DELETE_ARCHIVED_BEFORE", "DELETE_OLDEST"},
				},
				"object_count": map[string]any{
					"type":        "integer",
					"description": "object_count parameter",
				},
			}),
			mcp.Description("Parameters object containing: before_date (datetime), delete_offset (integer), delete_strategy (enum) [DELETE_ANY, DELETE_ARCHIVED_BEFORE, DELETE_OLDEST] [required], object_count (integer)"),
		),
	)
	tools = append(tools, adaccount_delete_campaignsTool)

	// adaccount_get_campaigns tool
	// Available fields for Campaign: account_id, adlabels, advantage_state_info, bid_strategy, boosted_object_id, brand_lift_studies, budget_rebalance_flag, budget_remaining, buying_type, campaign_group_active_time, can_create_brand_lift_study, can_use_spend_cap, configured_status, created_time, daily_budget, effective_status, has_secondary_skadnetwork_reporting, id, is_budget_schedule_enabled, is_skadnetwork_attribution, issues_info, last_budget_toggling_time, lifetime_budget, name, objective, pacing_type, primary_attribution, promoted_object, recommendations, smart_promotion_type, source_campaign, source_campaign_id, source_recommendation_type, special_ad_categories, special_ad_category, special_ad_category_country, spend_cap, start_time, status, stop_time, topline_id, updated_time
	// Params object accepts: date_preset (adaccountcampaigns_date_preset_enum_param), effective_status (list<adaccountcampaigns_effective_status_enum_param>), is_completed (bool), time_range (map)
	adaccount_get_campaignsTool := mcp.NewTool("adaccount_get_campaigns",
		mcp.WithDescription("GET campaigns for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"date_preset": map[string]any{
					"type":        "string",
					"description": "date_preset parameter",
					"enum":        []string{"data_maximum", "last_14d", "last_28d", "last_30d", "last_3d", "last_7d", "last_90d", "last_month", "last_quarter", "last_week_mon_sun", "last_week_sun_sat", "last_year", "maximum", "this_month", "this_quarter", "this_week_mon_today", "this_week_sun_today", "this_year", "today", "yesterday"},
				},
				"effective_status": map[string]any{
					"type":        "array",
					"description": "effective_status parameter",
					"enum":        []string{"ACTIVE", "ADSET_PAUSED", "ARCHIVED", "CAMPAIGN_PAUSED", "DELETED", "DISAPPROVED", "IN_PROCESS", "PAUSED", "PENDING_BILLING_INFO", "PENDING_REVIEW", "PREAPPROVED", "WITH_ISSUES"},
					"items":       map[string]any{"type": "string"},
				},
				"is_completed": map[string]any{
					"type":        "boolean",
					"description": "is_completed parameter",
				},
				"time_range": map[string]any{
					"type":        "object",
					"description": "time_range parameter",
				},
			}),
			mcp.Description("Parameters object containing: date_preset (enum) [data_maximum, last_14d, last_28d, last_30d, last_3d, ...], effective_status (array<enum>) [ACTIVE, ADSET_PAUSED, ARCHIVED, CAMPAIGN_PAUSED, DELETED, ...], is_completed (boolean), time_range (object)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Campaign objects. Available fields: account_id, adlabels, advantage_state_info, bid_strategy, boosted_object_id, brand_lift_studies, budget_rebalance_flag, budget_remaining, buying_type, campaign_group_active_time, can_create_brand_lift_study, can_use_spend_cap, configured_status, created_time, daily_budget (and 27 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_campaignsTool)

	// adaccount_post_campaigns tool
	// Params object accepts: adlabels (list<Object>), bid_strategy (adaccountcampaigns_bid_strategy_enum_param), buying_type (string), daily_budget (unsigned int), execution_options (list<adaccountcampaigns_execution_options_enum_param>), is_skadnetwork_attribution (bool), iterative_split_test_configs (list<Object>), lifetime_budget (unsigned int), name (string), objective (adaccountcampaigns_objective_enum_param), pacing_type (list<string>), promoted_object (Object), smart_promotion_type (adaccountcampaigns_smart_promotion_type_enum_param), source_campaign_id (string), special_ad_categories (list<adaccountcampaigns_special_ad_categories_enum_param>), special_ad_category_country (list<adaccountcampaigns_special_ad_category_country_enum_param>), spend_cap (unsigned int), start_time (datetime), status (adaccountcampaigns_status_enum_param), stop_time (datetime), topline_id (string)
	adaccount_post_campaignsTool := mcp.NewTool("adaccount_post_campaigns",
		mcp.WithDescription("POST campaigns for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"adlabels": map[string]any{
					"type":        "array",
					"description": "adlabels parameter",
					"items":       map[string]any{"type": "object"},
				},
				"bid_strategy": map[string]any{
					"type":        "string",
					"description": "bid_strategy parameter",
					"enum":        []string{"COST_CAP", "LOWEST_COST_WITHOUT_CAP", "LOWEST_COST_WITH_BID_CAP", "LOWEST_COST_WITH_MIN_ROAS"},
				},
				"buying_type": map[string]any{
					"type":        "string",
					"description": "buying_type parameter",
				},
				"daily_budget": map[string]any{
					"type":        "integer",
					"description": "daily_budget parameter",
				},
				"execution_options": map[string]any{
					"type":        "array",
					"description": "execution_options parameter",
					"enum":        []string{"include_recommendations", "validate_only"},
					"items":       map[string]any{"type": "string"},
				},
				"is_skadnetwork_attribution": map[string]any{
					"type":        "boolean",
					"description": "is_skadnetwork_attribution parameter",
				},
				"iterative_split_test_configs": map[string]any{
					"type":        "array",
					"description": "iterative_split_test_configs parameter",
					"items":       map[string]any{"type": "object"},
				},
				"lifetime_budget": map[string]any{
					"type":        "integer",
					"description": "lifetime_budget parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"objective": map[string]any{
					"type":        "string",
					"description": "objective parameter",
					"enum":        []string{"APP_INSTALLS", "BRAND_AWARENESS", "CONVERSIONS", "EVENT_RESPONSES", "LEAD_GENERATION", "LINK_CLICKS", "LOCAL_AWARENESS", "MESSAGES", "OFFER_CLAIMS", "OUTCOME_APP_PROMOTION", "OUTCOME_AWARENESS", "OUTCOME_ENGAGEMENT", "OUTCOME_LEADS", "OUTCOME_SALES", "OUTCOME_TRAFFIC", "PAGE_LIKES", "POST_ENGAGEMENT", "PRODUCT_CATALOG_SALES", "REACH", "STORE_VISITS", "VIDEO_VIEWS"},
				},
				"pacing_type": map[string]any{
					"type":        "array",
					"description": "pacing_type parameter",
					"items":       map[string]any{"type": "string"},
				},
				"promoted_object": map[string]any{
					"type":        "object",
					"description": "promoted_object parameter",
				},
				"smart_promotion_type": map[string]any{
					"type":        "string",
					"description": "smart_promotion_type parameter",
					"enum":        []string{"GUIDED_CREATION", "SMART_APP_PROMOTION"},
				},
				"source_campaign_id": map[string]any{
					"type":        "string",
					"description": "source_campaign_id parameter",
				},
				"special_ad_categories": map[string]any{
					"type":        "array",
					"description": "special_ad_categories parameter",
					"required":    true,
					"enum":        []string{"CREDIT", "EMPLOYMENT", "FINANCIAL_PRODUCTS_SERVICES", "HOUSING", "ISSUES_ELECTIONS_POLITICS", "NONE", "ONLINE_GAMBLING_AND_GAMING"},
					"items":       map[string]any{"type": "string"},
				},
				"special_ad_category_country": map[string]any{
					"type":        "array",
					"description": "special_ad_category_country parameter",
					"enum":        []string{"AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "XK", "YE", "YT", "ZA", "ZM", "ZW"},
					"items":       map[string]any{"type": "string"},
				},
				"spend_cap": map[string]any{
					"type":        "integer",
					"description": "spend_cap parameter",
				},
				"start_time": map[string]any{
					"type":        "string",
					"description": "start_time parameter",
				},
				"status": map[string]any{
					"type":        "string",
					"description": "status parameter",
					"enum":        []string{"ACTIVE", "ARCHIVED", "DELETED", "PAUSED"},
				},
				"stop_time": map[string]any{
					"type":        "string",
					"description": "stop_time parameter",
				},
				"topline_id": map[string]any{
					"type":        "string",
					"description": "topline_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: adlabels (array<object>), bid_strategy (enum) [COST_CAP, LOWEST_COST_WITHOUT_CAP, LOWEST_COST_WITH_BID_CAP, LOWEST_COST_WITH_MIN_ROAS], buying_type (string), daily_budget (integer), execution_options (array<enum>) [include_recommendations, validate_only], is_skadnetwork_attribution (boolean), iterative_split_test_configs (array<object>), lifetime_budget (integer), name (string), objective (enum) [APP_INSTALLS, BRAND_AWARENESS, CONVERSIONS, EVENT_RESPONSES, LEAD_GENERATION, ...], pacing_type (array<string>), promoted_object (object), smart_promotion_type (enum) [GUIDED_CREATION, SMART_APP_PROMOTION], source_campaign_id (string), special_ad_categories (array<enum>) [CREDIT, EMPLOYMENT, FINANCIAL_PRODUCTS_SERVICES, HOUSING, ISSUES_ELECTIONS_POLITICS, ...] [required], special_ad_category_country (array<enum>) [AD, AE, AF, AG, AI, ...], spend_cap (integer), start_time (datetime), status (enum) [ACTIVE, ARCHIVED, DELETED, PAUSED], stop_time (datetime), topline_id (string)"),
		),
	)
	tools = append(tools, adaccount_post_campaignsTool)

	// adaccount_get_campaignsbylabels tool
	// Available fields for Campaign: account_id, adlabels, advantage_state_info, bid_strategy, boosted_object_id, brand_lift_studies, budget_rebalance_flag, budget_remaining, buying_type, campaign_group_active_time, can_create_brand_lift_study, can_use_spend_cap, configured_status, created_time, daily_budget, effective_status, has_secondary_skadnetwork_reporting, id, is_budget_schedule_enabled, is_skadnetwork_attribution, issues_info, last_budget_toggling_time, lifetime_budget, name, objective, pacing_type, primary_attribution, promoted_object, recommendations, smart_promotion_type, source_campaign, source_campaign_id, source_recommendation_type, special_ad_categories, special_ad_category, special_ad_category_country, spend_cap, start_time, status, stop_time, topline_id, updated_time
	// Params object accepts: ad_label_ids (list<string>), operator (adaccountcampaignsbylabels_operator_enum_param)
	adaccount_get_campaignsbylabelsTool := mcp.NewTool("adaccount_get_campaignsbylabels",
		mcp.WithDescription("GET campaignsbylabels for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"ad_label_ids": map[string]any{
					"type":        "array",
					"description": "ad_label_ids parameter",
					"required":    true,
					"items":       map[string]any{"type": "string"},
				},
				"operator": map[string]any{
					"type":        "string",
					"description": "operator parameter",
					"enum":        []string{"ALL", "ANY"},
				},
			}),
			mcp.Description("Parameters object containing: ad_label_ids (array<string>) [required], operator (enum) [ALL, ANY]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Campaign objects. Available fields: account_id, adlabels, advantage_state_info, bid_strategy, boosted_object_id, brand_lift_studies, budget_rebalance_flag, budget_remaining, buying_type, campaign_group_active_time, can_create_brand_lift_study, can_use_spend_cap, configured_status, created_time, daily_budget (and 27 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_campaignsbylabelsTool)

	// adaccount_get_connected_instagram_accounts tool
	// Available fields for IGUser: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url, shopping_product_tag_eligibility, shopping_review_status, username, website
	adaccount_get_connected_instagram_accountsTool := mcp.NewTool("adaccount_get_connected_instagram_accounts",
		mcp.WithDescription("GET connected_instagram_accounts for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGUser objects. Available fields: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_connected_instagram_accountsTool)

	// adaccount_get_connected_instagram_accounts_with_iabp tool
	// Available fields for IGUser: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url, shopping_product_tag_eligibility, shopping_review_status, username, website
	// Params object accepts: business_id (string)
	adaccount_get_connected_instagram_accounts_with_iabpTool := mcp.NewTool("adaccount_get_connected_instagram_accounts_with_iabp",
		mcp.WithDescription("GET connected_instagram_accounts_with_iabp for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"business_id": map[string]any{
					"type":        "string",
					"description": "business_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: business_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGUser objects. Available fields: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_connected_instagram_accounts_with_iabpTool)

	// adaccount_get_conversion_goals tool
	// Available fields for AdsConversionGoal: ad_account_id, conversion_event_value_source, description, goal_creation_method, id, name, performance_goal, update_status
	adaccount_get_conversion_goalsTool := mcp.NewTool("adaccount_get_conversion_goals",
		mcp.WithDescription("GET conversion_goals for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdsConversionGoal objects. Available fields: ad_account_id, conversion_event_value_source, description, goal_creation_method, id, name, performance_goal, update_status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_conversion_goalsTool)

	// adaccount_get_customaudiences tool
	// Available fields for CustomAudience: account_id, approximate_count_lower_bound, approximate_count_upper_bound, customer_file_source, data_source, data_source_types, datafile_custom_audience_uploading_status, delete_time, delivery_status, description, excluded_custom_audiences, external_event_source, household_audience, id, included_custom_audiences, is_eligible_for_sac_campaigns, is_household, is_snapshot, is_value_based, lookalike_audience_ids, lookalike_spec, name, operation_status, opt_out_link, owner_business, page_deletion_marked_delete_time, permission_for_actions, pixel_id, regulated_audience_spec, retention_days, rev_share_policy_id, rule, rule_aggregation, rule_v2, seed_audience, sharing_status, subtype, time_content_updated, time_created, time_updated
	// Params object accepts: business_id (string), fetch_primary_audience (bool), fields (list<string>), filtering (list<Object>), pixel_id (string)
	adaccount_get_customaudiencesTool := mcp.NewTool("adaccount_get_customaudiences",
		mcp.WithDescription("GET customaudiences for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"business_id": map[string]any{
					"type":        "string",
					"description": "business_id parameter",
				},
				"fetch_primary_audience": map[string]any{
					"type":        "boolean",
					"description": "fetch_primary_audience parameter",
				},
				"fields": map[string]any{
					"type":        "array",
					"description": "fields parameter",
					"items":       map[string]any{"type": "string"},
				},
				"filtering": map[string]any{
					"type":        "array",
					"description": "filtering parameter",
					"items":       map[string]any{"type": "object"},
				},
				"pixel_id": map[string]any{
					"type":        "string",
					"description": "pixel_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: business_id (string), fetch_primary_audience (boolean), fields (array<string>), filtering (array<object>), pixel_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CustomAudience objects. Available fields: account_id, approximate_count_lower_bound, approximate_count_upper_bound, customer_file_source, data_source, data_source_types, datafile_custom_audience_uploading_status, delete_time, delivery_status, description, excluded_custom_audiences, external_event_source, household_audience, id, included_custom_audiences (and 25 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_customaudiencesTool)

	// adaccount_post_customaudiences tool
	// Params object accepts: allowed_domains (list<string>), associated_audience_id (unsigned int), claim_objective (adaccountcustomaudiences_claim_objective_enum_param), content_type (adaccountcustomaudiences_content_type_enum_param), countries (string), creation_params (map), customer_file_source (adaccountcustomaudiences_customer_file_source_enum_param), dataset_id (string), description (string), enable_fetch_or_create (bool), event_source_group (string), event_sources (list<map>), exclusions (list<Object>), facebook_page_id (string), inclusions (list<Object>), is_snapshot (bool), is_value_based (bool), list_of_accounts (list<unsigned int>), lookalike_spec (string), marketing_message_channels (Object), name (string), opt_out_link (string), origin_audience_id (string), parent_audience_id (unsigned int), partner_reference_key (string), pixel_id (string), prefill (bool), product_set_id (string), regulated_audience_spec (string), retention_days (unsigned int), rev_share_policy_id (unsigned int), rule (string), rule_aggregation (string), subscription_info (list<adaccountcustomaudiences_subscription_info_enum_param>), subtype (adaccountcustomaudiences_subtype_enum_param), use_for_products (list<adaccountcustomaudiences_use_for_products_enum_param>), use_in_campaigns (bool), video_group_ids (list<string>), whats_app_business_phone_number_id (string)
	adaccount_post_customaudiencesTool := mcp.NewTool("adaccount_post_customaudiences",
		mcp.WithDescription("POST customaudiences for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"allowed_domains": map[string]any{
					"type":        "array",
					"description": "allowed_domains parameter",
					"items":       map[string]any{"type": "string"},
				},
				"associated_audience_id": map[string]any{
					"type":        "integer",
					"description": "associated_audience_id parameter",
				},
				"claim_objective": map[string]any{
					"type":        "string",
					"description": "claim_objective parameter",
					"enum":        []string{"AUTOMOTIVE_MODEL", "COLLABORATIVE_ADS", "HOME_LISTING", "MEDIA_TITLE", "PRODUCT", "TRAVEL", "VEHICLE", "VEHICLE_OFFER"},
				},
				"content_type": map[string]any{
					"type":        "string",
					"description": "content_type parameter",
					"enum":        []string{"AUTOMOTIVE_MODEL", "DESTINATION", "FLIGHT", "GENERIC", "HOME_LISTING", "HOTEL", "LOCAL_SERVICE_BUSINESS", "MEDIA_TITLE", "OFFLINE_PRODUCT", "PRODUCT", "VEHICLE", "VEHICLE_OFFER"},
				},
				"countries": map[string]any{
					"type":        "string",
					"description": "countries parameter",
				},
				"creation_params": map[string]any{
					"type":        "object",
					"description": "creation_params parameter",
				},
				"customer_file_source": map[string]any{
					"type":        "string",
					"description": "customer_file_source parameter",
					"enum":        []string{"BOTH_USER_AND_PARTNER_PROVIDED", "PARTNER_PROVIDED_ONLY", "USER_PROVIDED_ONLY"},
				},
				"dataset_id": map[string]any{
					"type":        "string",
					"description": "dataset_id parameter",
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"enable_fetch_or_create": map[string]any{
					"type":        "boolean",
					"description": "enable_fetch_or_create parameter",
				},
				"event_source_group": map[string]any{
					"type":        "string",
					"description": "event_source_group parameter",
				},
				"event_sources": map[string]any{
					"type":        "array",
					"description": "event_sources parameter",
					"items":       map[string]any{"type": "object"},
				},
				"exclusions": map[string]any{
					"type":        "array",
					"description": "exclusions parameter",
					"items":       map[string]any{"type": "object"},
				},
				"facebook_page_id": map[string]any{
					"type":        "string",
					"description": "facebook_page_id parameter",
				},
				"inclusions": map[string]any{
					"type":        "array",
					"description": "inclusions parameter",
					"items":       map[string]any{"type": "object"},
				},
				"is_snapshot": map[string]any{
					"type":        "boolean",
					"description": "is_snapshot parameter",
				},
				"is_value_based": map[string]any{
					"type":        "boolean",
					"description": "is_value_based parameter",
				},
				"list_of_accounts": map[string]any{
					"type":        "array",
					"description": "list_of_accounts parameter",
					"items":       map[string]any{"type": "integer"},
				},
				"lookalike_spec": map[string]any{
					"type":        "string",
					"description": "lookalike_spec parameter",
				},
				"marketing_message_channels": map[string]any{
					"type":        "object",
					"description": "marketing_message_channels parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"opt_out_link": map[string]any{
					"type":        "string",
					"description": "opt_out_link parameter",
				},
				"origin_audience_id": map[string]any{
					"type":        "string",
					"description": "origin_audience_id parameter",
				},
				"parent_audience_id": map[string]any{
					"type":        "integer",
					"description": "parent_audience_id parameter",
				},
				"partner_reference_key": map[string]any{
					"type":        "string",
					"description": "partner_reference_key parameter",
				},
				"pixel_id": map[string]any{
					"type":        "string",
					"description": "pixel_id parameter",
				},
				"prefill": map[string]any{
					"type":        "boolean",
					"description": "prefill parameter",
				},
				"product_set_id": map[string]any{
					"type":        "string",
					"description": "product_set_id parameter",
				},
				"regulated_audience_spec": map[string]any{
					"type":        "string",
					"description": "regulated_audience_spec parameter",
				},
				"retention_days": map[string]any{
					"type":        "integer",
					"description": "retention_days parameter",
				},
				"rev_share_policy_id": map[string]any{
					"type":        "integer",
					"description": "rev_share_policy_id parameter",
				},
				"rule": map[string]any{
					"type":        "string",
					"description": "rule parameter",
				},
				"rule_aggregation": map[string]any{
					"type":        "string",
					"description": "rule_aggregation parameter",
				},
				"subscription_info": map[string]any{
					"type":        "array",
					"description": "subscription_info parameter",
					"enum":        []string{"MESSENGER", "WHATSAPP"},
					"items":       map[string]any{"type": "string"},
				},
				"subtype": map[string]any{
					"type":        "string",
					"description": "subtype parameter",
					"enum":        []string{"APP", "BAG_OF_ACCOUNTS", "BIDDING", "CLAIM", "CUSTOM", "ENGAGEMENT", "EXCLUSION", "FOX", "LOOKALIKE", "MANAGED", "MEASUREMENT", "MESSENGER_SUBSCRIBER_LIST", "OFFLINE_CONVERSION", "PARTNER", "PRIMARY", "REGULATED_CATEGORIES_AUDIENCE", "STUDY_RULE_AUDIENCE", "VIDEO", "WEBSITE"},
				},
				"use_for_products": map[string]any{
					"type":        "array",
					"description": "use_for_products parameter",
					"enum":        []string{"ADS", "MARKETING_MESSAGES"},
					"items":       map[string]any{"type": "string"},
				},
				"use_in_campaigns": map[string]any{
					"type":        "boolean",
					"description": "use_in_campaigns parameter",
				},
				"video_group_ids": map[string]any{
					"type":        "array",
					"description": "video_group_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"whats_app_business_phone_number_id": map[string]any{
					"type":        "string",
					"description": "whats_app_business_phone_number_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: allowed_domains (array<string>), associated_audience_id (integer), claim_objective (enum) [AUTOMOTIVE_MODEL, COLLABORATIVE_ADS, HOME_LISTING, MEDIA_TITLE, PRODUCT, ...], content_type (enum) [AUTOMOTIVE_MODEL, DESTINATION, FLIGHT, GENERIC, HOME_LISTING, ...], countries (string), creation_params (object), customer_file_source (enum) [BOTH_USER_AND_PARTNER_PROVIDED, PARTNER_PROVIDED_ONLY, USER_PROVIDED_ONLY], dataset_id (string), description (string), enable_fetch_or_create (boolean), event_source_group (string), event_sources (array<object>), exclusions (array<object>), facebook_page_id (string), inclusions (array<object>), is_snapshot (boolean), is_value_based (boolean), list_of_accounts (array<integer>), lookalike_spec (string), marketing_message_channels (object), name (string), opt_out_link (string), origin_audience_id (string), parent_audience_id (integer), partner_reference_key (string), pixel_id (string), prefill (boolean), product_set_id (string), regulated_audience_spec (string), retention_days (integer), rev_share_policy_id (integer), rule (string), rule_aggregation (string), subscription_info (array<enum>) [MESSENGER, WHATSAPP], subtype (enum) [APP, BAG_OF_ACCOUNTS, BIDDING, CLAIM, CUSTOM, ...], use_for_products (array<enum>) [ADS, MARKETING_MESSAGES], use_in_campaigns (boolean), video_group_ids (array<string>), whats_app_business_phone_number_id (string)"),
		),
	)
	tools = append(tools, adaccount_post_customaudiencesTool)

	// adaccount_get_customaudiencestos tool
	// Available fields for CustomAudiencesTOS: content, id, type
	adaccount_get_customaudiencestosTool := mcp.NewTool("adaccount_get_customaudiencestos",
		mcp.WithDescription("GET customaudiencestos for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CustomAudiencesTOS objects. Available fields: content, id, type"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_customaudiencestosTool)

	// adaccount_post_customaudiencestos tool
	// Params object accepts: business_id (string), tos_id (string)
	adaccount_post_customaudiencestosTool := mcp.NewTool("adaccount_post_customaudiencestos",
		mcp.WithDescription("POST customaudiencestos for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business_id": map[string]any{
					"type":        "string",
					"description": "business_id parameter",
				},
				"tos_id": map[string]any{
					"type":        "string",
					"description": "tos_id parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: business_id (string), tos_id (string) [required]"),
		),
	)
	tools = append(tools, adaccount_post_customaudiencestosTool)

	// adaccount_get_customconversions tool
	// Available fields for CustomConversion: account_id, aggregation_rule, business, creation_time, custom_event_type, data_sources, default_conversion_value, description, event_source_type, first_fired_time, id, is_archived, is_unavailable, last_fired_time, name, offline_conversion_data_set, pixel, retention_days, rule
	adaccount_get_customconversionsTool := mcp.NewTool("adaccount_get_customconversions",
		mcp.WithDescription("GET customconversions for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CustomConversion objects. Available fields: account_id, aggregation_rule, business, creation_time, custom_event_type, data_sources, default_conversion_value, description, event_source_type, first_fired_time, id, is_archived, is_unavailable, last_fired_time, name (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_customconversionsTool)

	// adaccount_post_customconversions tool
	// Params object accepts: action_source_type (adaccountcustomconversions_action_source_type_enum_param), advanced_rule (string), custom_event_type (adaccountcustomconversions_custom_event_type_enum_param), default_conversion_value (float), description (string), event_source_id (string), name (string), rule (string)
	adaccount_post_customconversionsTool := mcp.NewTool("adaccount_post_customconversions",
		mcp.WithDescription("POST customconversions for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"action_source_type": map[string]any{
					"type":        "string",
					"description": "action_source_type parameter",
					"enum":        []string{"app", "business_messaging", "chat", "email", "other", "phone_call", "physical_store", "system_generated", "website"},
				},
				"advanced_rule": map[string]any{
					"type":        "string",
					"description": "advanced_rule parameter",
				},
				"custom_event_type": map[string]any{
					"type":        "string",
					"description": "custom_event_type parameter",
					"enum":        []string{"ADD_PAYMENT_INFO", "ADD_TO_CART", "ADD_TO_WISHLIST", "COMPLETE_REGISTRATION", "CONTACT", "CONTENT_VIEW", "CUSTOMIZE_PRODUCT", "DONATE", "FACEBOOK_SELECTED", "FIND_LOCATION", "INITIATED_CHECKOUT", "LEAD", "LISTING_INTERACTION", "OTHER", "PURCHASE", "SCHEDULE", "SEARCH", "START_TRIAL", "SUBMIT_APPLICATION", "SUBSCRIBE"},
				},
				"default_conversion_value": map[string]any{
					"type":        "number",
					"description": "default_conversion_value parameter",
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"event_source_id": map[string]any{
					"type":        "string",
					"description": "event_source_id parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"rule": map[string]any{
					"type":        "string",
					"description": "rule parameter",
				},
			}),
			mcp.Description("Parameters object containing: action_source_type (enum) [app, business_messaging, chat, email, other, ...], advanced_rule (string), custom_event_type (enum) [ADD_PAYMENT_INFO, ADD_TO_CART, ADD_TO_WISHLIST, COMPLETE_REGISTRATION, CONTACT, ...], default_conversion_value (number), description (string), event_source_id (string), name (string) [required], rule (string)"),
		),
	)
	tools = append(tools, adaccount_post_customconversionsTool)

	// adaccount_get_delivery_estimate tool
	// Available fields for AdAccountDeliveryEstimate: daily_outcomes_curve, estimate_dau, estimate_mau_lower_bound, estimate_mau_upper_bound, estimate_ready, targeting_optimization_types
	// Params object accepts: optimization_goal (adaccountdelivery_estimate_optimization_goal_enum_param), promoted_object (Object), targeting_spec (Targeting)
	adaccount_get_delivery_estimateTool := mcp.NewTool("adaccount_get_delivery_estimate",
		mcp.WithDescription("GET delivery_estimate for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"optimization_goal": map[string]any{
					"type":        "string",
					"description": "optimization_goal parameter",
					"required":    true,
					"enum":        []string{"ADVERTISER_SILOED_VALUE", "AD_RECALL_LIFT", "APP_INSTALLS", "APP_INSTALLS_AND_OFFSITE_CONVERSIONS", "CONVERSATIONS", "DERIVED_EVENTS", "ENGAGED_USERS", "EVENT_RESPONSES", "IMPRESSIONS", "IN_APP_VALUE", "LANDING_PAGE_VIEWS", "LEAD_GENERATION", "LINK_CLICKS", "MEANINGFUL_CALL_ATTEMPT", "MESSAGING_APPOINTMENT_CONVERSION", "MESSAGING_PURCHASE_CONVERSION", "NONE", "OFFSITE_CONVERSIONS", "PAGE_LIKES", "POST_ENGAGEMENT", "PROFILE_AND_PAGE_ENGAGEMENT", "PROFILE_VISIT", "QUALITY_CALL", "QUALITY_LEAD", "REACH", "REMINDERS_SET", "SUBSCRIBERS", "THRUPLAY", "VALUE", "VISIT_INSTAGRAM_PROFILE"},
				},
				"promoted_object": map[string]any{
					"type":        "object",
					"description": "promoted_object parameter",
				},
				"targeting_spec": map[string]any{
					"type":        "string",
					"description": "targeting_spec parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: optimization_goal (enum) [ADVERTISER_SILOED_VALUE, AD_RECALL_LIFT, APP_INSTALLS, APP_INSTALLS_AND_OFFSITE_CONVERSIONS, CONVERSATIONS, ...] [required], promoted_object (object), targeting_spec (Targeting) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountDeliveryEstimate objects. Available fields: daily_outcomes_curve, estimate_dau, estimate_mau_lower_bound, estimate_mau_upper_bound, estimate_ready, targeting_optimization_types"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_delivery_estimateTool)

	// adaccount_get_deprecatedtargetingadsets tool
	// Available fields for AdSet: account_id, adlabels, adset_schedule, asset_feed_id, attribution_spec, bid_adjustments, bid_amount, bid_constraints, bid_info, bid_strategy, billing_event, brand_safety_config, budget_remaining, campaign, campaign_active_time, campaign_attribution, campaign_id, configured_status, created_time, creative_sequence, creative_sequence_repetition_pattern, daily_budget, daily_min_spend_target, daily_spend_cap, destination_type, dsa_beneficiary, dsa_payor, effective_status, end_time, existing_customer_budget_percentage, frequency_control_specs, full_funnel_exploration_mode, id, instagram_user_id, is_ba_skip_delayed_eligible, is_budget_schedule_enabled, is_dynamic_creative, is_incremental_attribution_enabled, issues_info, learning_stage_info, lifetime_budget, lifetime_imps, lifetime_min_spend_target, lifetime_spend_cap, max_budget_spend_percentage, min_budget_spend_percentage, multi_optimization_goal_weight, name, optimization_goal, optimization_sub_event, pacing_type, promoted_object, recommendations, recurring_budget_semantics, regional_regulated_categories, regional_regulation_identities, review_feedback, rf_prediction_id, source_adset, source_adset_id, start_time, status, targeting, targeting_optimization_types, time_based_ad_rotation_id_blocks, time_based_ad_rotation_intervals, updated_time, use_new_app_click
	// Params object accepts: type (string)
	adaccount_get_deprecatedtargetingadsetsTool := mcp.NewTool("adaccount_get_deprecatedtargetingadsets",
		mcp.WithDescription("GET deprecatedtargetingadsets for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
				},
			}),
			mcp.Description("Parameters object containing: type (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdSet objects. Available fields: account_id, adlabels, adset_schedule, asset_feed_id, attribution_spec, bid_adjustments, bid_amount, bid_constraints, bid_info, bid_strategy, billing_event, brand_safety_config, budget_remaining, campaign, campaign_active_time (and 53 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_deprecatedtargetingadsetsTool)

	// adaccount_get_dsa_recommendations tool
	// Available fields for AdAccountDsaRecommendations: recommendations
	adaccount_get_dsa_recommendationsTool := mcp.NewTool("adaccount_get_dsa_recommendations",
		mcp.WithDescription("GET dsa_recommendations for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountDsaRecommendations objects. Available fields: recommendations"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_dsa_recommendationsTool)

	// adaccount_get_generatepreviews tool
	// Available fields for AdPreview: body, transformation_spec
	// Params object accepts: ad_format (adaccountgeneratepreviews_ad_format_enum_param), creative (AdCreative), creative_feature (adaccountgeneratepreviews_creative_feature_enum_param), dynamic_asset_label (string), dynamic_creative_spec (Object), dynamic_customization (Object), end_date (datetime), height (unsigned int), locale (string), place_page_id (int), post (Object), product_item_ids (list<string>), render_type (adaccountgeneratepreviews_render_type_enum_param), start_date (datetime), width (unsigned int)
	adaccount_get_generatepreviewsTool := mcp.NewTool("adaccount_get_generatepreviews",
		mcp.WithDescription("GET generatepreviews for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"ad_format": map[string]any{
					"type":        "string",
					"description": "ad_format parameter",
					"required":    true,
					"enum":        []string{"AUDIENCE_NETWORK_INSTREAM_VIDEO", "AUDIENCE_NETWORK_INSTREAM_VIDEO_MOBILE", "AUDIENCE_NETWORK_OUTSTREAM_VIDEO", "AUDIENCE_NETWORK_REWARDED_VIDEO", "BIZ_DISCO_FEED_MOBILE", "DESKTOP_FEED_STANDARD", "FACEBOOK_PROFILE_FEED_DESKTOP", "FACEBOOK_PROFILE_FEED_MOBILE", "FACEBOOK_PROFILE_REELS_MOBILE", "FACEBOOK_REELS_BANNER", "FACEBOOK_REELS_BANNER_DESKTOP", "FACEBOOK_REELS_BANNER_FULLSCREEN_IOS", "FACEBOOK_REELS_BANNER_FULLSCREEN_MOBILE", "FACEBOOK_REELS_MOBILE", "FACEBOOK_REELS_POSTLOOP", "FACEBOOK_REELS_STICKER", "FACEBOOK_STORY_MOBILE", "FACEBOOK_STORY_STICKER_MOBILE", "INSTAGRAM_EXPLORE_CONTEXTUAL", "INSTAGRAM_EXPLORE_GRID_HOME", "INSTAGRAM_EXPLORE_IMMERSIVE", "INSTAGRAM_FEED_WEB", "INSTAGRAM_FEED_WEB_M_SITE", "INSTAGRAM_LEAD_GEN_MULTI_SUBMIT_ADS", "INSTAGRAM_PROFILE_FEED", "INSTAGRAM_PROFILE_REELS", "INSTAGRAM_REELS", "INSTAGRAM_REELS_OVERLAY", "INSTAGRAM_SEARCH_CHAIN", "INSTAGRAM_SEARCH_GRID", "INSTAGRAM_STANDARD", "INSTAGRAM_STORY", "INSTAGRAM_STORY_EFFECT_TRAY", "INSTAGRAM_STORY_WEB", "INSTAGRAM_STORY_WEB_M_SITE", "INSTANT_ARTICLE_RECIRCULATION_AD", "INSTANT_ARTICLE_STANDARD", "INSTREAM_BANNER_DESKTOP", "INSTREAM_BANNER_FULLSCREEN_IOS", "INSTREAM_BANNER_FULLSCREEN_MOBILE", "INSTREAM_BANNER_IMMERSIVE_MOBILE", "INSTREAM_BANNER_MOBILE", "INSTREAM_VIDEO_DESKTOP", "INSTREAM_VIDEO_FULLSCREEN_IOS", "INSTREAM_VIDEO_FULLSCREEN_MOBILE", "INSTREAM_VIDEO_IMAGE", "INSTREAM_VIDEO_IMMERSIVE_MOBILE", "INSTREAM_VIDEO_MOBILE", "JOB_BROWSER_DESKTOP", "JOB_BROWSER_MOBILE", "MARKETPLACE_MOBILE", "MESSENGER_MOBILE_INBOX_MEDIA", "MESSENGER_MOBILE_STORY_MEDIA", "MOBILE_BANNER", "MOBILE_FEED_BASIC", "MOBILE_FEED_STANDARD", "MOBILE_FULLWIDTH", "MOBILE_INTERSTITIAL", "MOBILE_MEDIUM_RECTANGLE", "MOBILE_NATIVE", "RIGHT_COLUMN_STANDARD", "SUGGESTED_VIDEO_DESKTOP", "SUGGESTED_VIDEO_FULLSCREEN_MOBILE", "SUGGESTED_VIDEO_IMMERSIVE_MOBILE", "SUGGESTED_VIDEO_MOBILE", "WATCH_FEED_HOME", "WATCH_FEED_MOBILE"},
				},
				"creative": map[string]any{
					"type":        "string",
					"description": "creative parameter",
					"required":    true,
				},
				"creative_feature": map[string]any{
					"type":        "string",
					"description": "creative_feature parameter",
					"enum":        []string{"product_metadata_automation", "profile_card", "standard_enhancements_catalog", "video_to_image"},
				},
				"dynamic_asset_label": map[string]any{
					"type":        "string",
					"description": "dynamic_asset_label parameter",
				},
				"dynamic_creative_spec": map[string]any{
					"type":        "object",
					"description": "dynamic_creative_spec parameter",
				},
				"dynamic_customization": map[string]any{
					"type":        "object",
					"description": "dynamic_customization parameter",
				},
				"end_date": map[string]any{
					"type":        "string",
					"description": "end_date parameter",
				},
				"height": map[string]any{
					"type":        "integer",
					"description": "height parameter",
				},
				"locale": map[string]any{
					"type":        "string",
					"description": "locale parameter",
				},
				"place_page_id": map[string]any{
					"type":        "integer",
					"description": "place_page_id parameter",
				},
				"post": map[string]any{
					"type":        "object",
					"description": "post parameter",
				},
				"product_item_ids": map[string]any{
					"type":        "array",
					"description": "product_item_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"render_type": map[string]any{
					"type":        "string",
					"description": "render_type parameter",
					"enum":        []string{"FALLBACK"},
				},
				"start_date": map[string]any{
					"type":        "string",
					"description": "start_date parameter",
				},
				"width": map[string]any{
					"type":        "integer",
					"description": "width parameter",
				},
			}),
			mcp.Description("Parameters object containing: ad_format (enum) [AUDIENCE_NETWORK_INSTREAM_VIDEO, AUDIENCE_NETWORK_INSTREAM_VIDEO_MOBILE, AUDIENCE_NETWORK_OUTSTREAM_VIDEO, AUDIENCE_NETWORK_REWARDED_VIDEO, BIZ_DISCO_FEED_MOBILE, ...] [required], creative (AdCreative) [required], creative_feature (enum) [product_metadata_automation, profile_card, standard_enhancements_catalog, video_to_image], dynamic_asset_label (string), dynamic_creative_spec (object), dynamic_customization (object), end_date (datetime), height (integer), locale (string), place_page_id (integer), post (object), product_item_ids (array<string>), render_type (enum) [FALLBACK], start_date (datetime), width (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdPreview objects. Available fields: body, transformation_spec"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_generatepreviewsTool)

	// adaccount_get_impacting_ad_studies tool
	// Available fields for AdStudy: business, canceled_time, client_business, cooldown_start_time, created_by, created_time, description, end_time, id, measurement_contact, name, observation_end_time, results_first_available_date, sales_contact, start_time, type, updated_by, updated_time
	adaccount_get_impacting_ad_studiesTool := mcp.NewTool("adaccount_get_impacting_ad_studies",
		mcp.WithDescription("GET impacting_ad_studies for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdStudy objects. Available fields: business, canceled_time, client_business, cooldown_start_time, created_by, created_time, description, end_time, id, measurement_contact, name, observation_end_time, results_first_available_date, sales_contact, start_time (and 3 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_impacting_ad_studiesTool)

	// adaccount_get_insights tool
	// Available fields for AdsInsights: account_currency, account_id, account_name, action_values, actions, ad_click_actions, ad_id, ad_impression_actions, ad_name, adset_end, adset_id, adset_name, adset_start, age_targeting, attribution_setting, auction_bid, auction_competitiveness, auction_max_competitor_bid, average_purchases_conversion_value, buying_type, campaign_id, campaign_name, canvas_avg_view_percent, canvas_avg_view_time, catalog_segment_actions, catalog_segment_value, catalog_segment_value_mobile_purchase_roas, catalog_segment_value_omni_purchase_roas, catalog_segment_value_website_purchase_roas, clicks, conversion_lead_rate, conversion_leads, conversion_rate_ranking, conversion_values, conversions, converted_product_app_custom_event_fb_mobile_purchase, converted_product_app_custom_event_fb_mobile_purchase_value, converted_product_offline_purchase, converted_product_offline_purchase_value, converted_product_omni_purchase, converted_product_omni_purchase_values, converted_product_quantity, converted_product_value, converted_product_website_pixel_purchase, converted_product_website_pixel_purchase_value, converted_promoted_product_app_custom_event_fb_mobile_purchase, converted_promoted_product_app_custom_event_fb_mobile_purchase_value, converted_promoted_product_offline_purchase, converted_promoted_product_offline_purchase_value, converted_promoted_product_omni_purchase, converted_promoted_product_omni_purchase_values, converted_promoted_product_quantity, converted_promoted_product_value, converted_promoted_product_website_pixel_purchase, converted_promoted_product_website_pixel_purchase_value, cost_per_15_sec_video_view, cost_per_2_sec_continuous_video_view, cost_per_action_type, cost_per_ad_click, cost_per_conversion, cost_per_conversion_lead, cost_per_dda_countby_convs, cost_per_estimated_ad_recallers, cost_per_inline_link_click, cost_per_inline_post_engagement, cost_per_objective_result, cost_per_one_thousand_ad_impression, cost_per_outbound_click, cost_per_result, cost_per_thruplay, cost_per_unique_action_type, cost_per_unique_click, cost_per_unique_conversion, cost_per_unique_inline_link_click, cost_per_unique_outbound_click, cpc, cpm, cpp, created_time, creative_media_type, ctr, date_start, date_stop, dda_countby_convs, dda_results, engagement_rate_ranking, estimated_ad_recall_rate, estimated_ad_recall_rate_lower_bound, estimated_ad_recall_rate_upper_bound, estimated_ad_recallers, estimated_ad_recallers_lower_bound, estimated_ad_recallers_upper_bound, frequency, full_view_impressions, full_view_reach, gender_targeting, impressions, inline_link_click_ctr, inline_link_clicks, inline_post_engagement, instagram_upcoming_event_reminders_set, instant_experience_clicks_to_open, instant_experience_clicks_to_start, instant_experience_outbound_clicks, interactive_component_tap, labels, landing_page_view_actions_per_link_click, landing_page_view_per_link_click, landing_page_view_per_purchase_rate, location, marketing_messages_click_rate_benchmark, marketing_messages_cost_per_delivered, marketing_messages_cost_per_link_btn_click, marketing_messages_delivered, marketing_messages_delivery_rate, marketing_messages_link_btn_click, marketing_messages_link_btn_click_rate, marketing_messages_media_view_rate, marketing_messages_phone_call_btn_click_rate, marketing_messages_quick_reply_btn_click, marketing_messages_quick_reply_btn_click_rate, marketing_messages_read, marketing_messages_read_rate, marketing_messages_read_rate_benchmark, marketing_messages_sent, marketing_messages_spend, marketing_messages_spend_currency, marketing_messages_website_add_to_cart, marketing_messages_website_initiate_checkout, marketing_messages_website_purchase, marketing_messages_website_purchase_values, mobile_app_purchase_roas, objective, objective_result_rate, objective_results, onsite_conversion_messaging_detected_purchase_deduped, optimization_goal, outbound_clicks, outbound_clicks_ctr, place_page_name, product_brand, product_category, product_content_id, product_custom_label_0, product_custom_label_1, product_custom_label_2, product_custom_label_3, product_custom_label_4, product_group_content_id, product_group_retailer_id, product_name, product_retailer_id, purchase_per_landing_page_view, purchase_roas, purchases_per_link_click, qualifying_question_qualify_answer_rate, quality_ranking, reach, result_rate, result_values_performance_indicator, results, shops_assisted_purchases, social_spend, spend, total_postbacks, total_postbacks_detailed, total_postbacks_detailed_v4, unique_actions, unique_clicks, unique_conversions, unique_ctr, unique_inline_link_click_ctr, unique_inline_link_clicks, unique_link_clicks_ctr, unique_outbound_clicks, unique_outbound_clicks_ctr, unique_video_continuous_2_sec_watched_actions, unique_video_view_15_sec, updated_time, video_15_sec_watched_actions, video_30_sec_watched_actions, video_avg_time_watched_actions, video_continuous_2_sec_watched_actions, video_p100_watched_actions, video_p25_watched_actions, video_p50_watched_actions, video_p75_watched_actions, video_p95_watched_actions, video_play_actions, video_play_curve_actions, video_play_retention_0_to_15s_actions, video_play_retention_20_to_60s_actions, video_play_retention_graph_actions, video_thruplay_watched_actions, video_time_watched_actions, video_view_per_impression, website_ctr, website_purchase_roas, wish_bid
	// Params object accepts: action_attribution_windows (list<adaccountinsights_action_attribution_windows_enum_param>), action_breakdowns (list<adaccountinsights_action_breakdowns_enum_param>), action_report_time (adaccountinsights_action_report_time_enum_param), breakdowns (list<adaccountinsights_breakdowns_enum_param>), date_preset (adaccountinsights_date_preset_enum_param), default_summary (bool), export_columns (list<string>), export_format (string), export_name (string), fields (list<string>), filtering (list<Object>), level (adaccountinsights_level_enum_param), limit (int), product_id_limit (int), sort (list<string>), summary (list<string>), summary_action_breakdowns (list<adaccountinsights_summary_action_breakdowns_enum_param>), time_increment (string), time_range (map), time_ranges (list<map>), use_account_attribution_setting (bool), use_unified_attribution_setting (bool)
	adaccount_get_insightsTool := mcp.NewTool("adaccount_get_insights",
		mcp.WithDescription("GET insights for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"action_attribution_windows": map[string]any{
					"type":        "array",
					"description": "action_attribution_windows parameter",
					"enum":        []string{"1d_click", "1d_ev", "1d_view", "28d_click", "28d_view", "28d_view_all_conversions", "28d_view_first_conversion", "7d_click", "7d_view", "7d_view_all_conversions", "7d_view_first_conversion", "dda", "default", "skan_click", "skan_click_second_postback", "skan_click_third_postback", "skan_view", "skan_view_second_postback", "skan_view_third_postback"},
					"items":       map[string]any{"type": "string"},
				},
				"action_breakdowns": map[string]any{
					"type":        "array",
					"description": "action_breakdowns parameter",
					"enum":        []string{"action_canvas_component_name", "action_carousel_card_id", "action_carousel_card_name", "action_destination", "action_device", "action_reaction", "action_target_id", "action_type", "action_video_sound", "action_video_type", "conversion_destination", "matched_persona_id", "matched_persona_name", "signal_source_bucket", "standard_event_content_type"},
					"items":       map[string]any{"type": "string"},
				},
				"action_report_time": map[string]any{
					"type":        "string",
					"description": "action_report_time parameter",
					"enum":        []string{"conversion", "impression", "lifetime", "mixed"},
				},
				"breakdowns": map[string]any{
					"type":        "array",
					"description": "breakdowns parameter",
					"enum":        []string{"ad_extension_domain", "ad_extension_url", "ad_format_asset", "age", "app_id", "body_asset", "breakdown_ad_objective", "breakdown_reporting_ad_id", "call_to_action_asset", "coarse_conversion_value", "comscore_market", "comscore_market_code", "conversion_destination", "country", "creative_relaxation_asset_type", "description_asset", "device_platform", "dma", "fidelity_type", "flexible_format_asset_type", "frequency_value", "gen_ai_asset_type", "gender", "hourly_stats_aggregated_by_advertiser_time_zone", "hourly_stats_aggregated_by_audience_time_zone", "hsid", "image_asset", "impression_device", "impression_view_time_advertiser_hour_v2", "is_auto_advance", "is_conversion_id_modeled", "is_rendered_as_delayed_skip_ad", "landing_destination", "link_url_asset", "marketing_messages_btn_name", "mdsa_landing_destination", "media_asset_url", "media_creator", "media_destination_url", "media_format", "media_origin_url", "media_text_content", "media_type", "mmm", "place_page_id", "platform_position", "postback_sequence_index", "product_id", "publisher_platform", "redownload", "region", "signal_source_bucket", "skan_campaign_id", "skan_conversion_id", "skan_version", "sot_attribution_model_type", "sot_attribution_window", "sot_channel", "sot_event_type", "sot_source", "standard_event_content_type", "title_asset", "user_persona_id", "user_persona_name", "video_asset"},
					"items":       map[string]any{"type": "string"},
				},
				"date_preset": map[string]any{
					"type":        "string",
					"description": "date_preset parameter",
					"enum":        []string{"data_maximum", "last_14d", "last_28d", "last_30d", "last_3d", "last_7d", "last_90d", "last_month", "last_quarter", "last_week_mon_sun", "last_week_sun_sat", "last_year", "maximum", "this_month", "this_quarter", "this_week_mon_today", "this_week_sun_today", "this_year", "today", "yesterday"},
				},
				"default_summary": map[string]any{
					"type":        "boolean",
					"description": "default_summary parameter",
				},
				"export_columns": map[string]any{
					"type":        "array",
					"description": "export_columns parameter",
					"items":       map[string]any{"type": "string"},
				},
				"export_format": map[string]any{
					"type":        "string",
					"description": "export_format parameter",
				},
				"export_name": map[string]any{
					"type":        "string",
					"description": "export_name parameter",
				},
				"fields": map[string]any{
					"type":        "array",
					"description": "fields parameter",
					"items":       map[string]any{"type": "string"},
				},
				"filtering": map[string]any{
					"type":        "array",
					"description": "filtering parameter",
					"items":       map[string]any{"type": "object"},
				},
				"level": map[string]any{
					"type":        "string",
					"description": "level parameter",
					"enum":        []string{"account", "ad", "adset", "campaign"},
				},
				"limit": map[string]any{
					"type":        "integer",
					"description": "limit parameter",
				},
				"product_id_limit": map[string]any{
					"type":        "integer",
					"description": "product_id_limit parameter",
				},
				"sort": map[string]any{
					"type":        "array",
					"description": "sort parameter",
					"items":       map[string]any{"type": "string"},
				},
				"summary": map[string]any{
					"type":        "array",
					"description": "summary parameter",
					"items":       map[string]any{"type": "string"},
				},
				"summary_action_breakdowns": map[string]any{
					"type":        "array",
					"description": "summary_action_breakdowns parameter",
					"enum":        []string{"action_canvas_component_name", "action_carousel_card_id", "action_carousel_card_name", "action_destination", "action_device", "action_reaction", "action_target_id", "action_type", "action_video_sound", "action_video_type", "conversion_destination", "matched_persona_id", "matched_persona_name", "signal_source_bucket", "standard_event_content_type"},
					"items":       map[string]any{"type": "string"},
				},
				"time_increment": map[string]any{
					"type":        "string",
					"description": "time_increment parameter",
				},
				"time_range": map[string]any{
					"type":        "object",
					"description": "time_range parameter",
				},
				"time_ranges": map[string]any{
					"type":        "array",
					"description": "time_ranges parameter",
					"items":       map[string]any{"type": "object"},
				},
				"use_account_attribution_setting": map[string]any{
					"type":        "boolean",
					"description": "use_account_attribution_setting parameter",
				},
				"use_unified_attribution_setting": map[string]any{
					"type":        "boolean",
					"description": "use_unified_attribution_setting parameter",
				},
			}),
			mcp.Description("Parameters object containing: action_attribution_windows (array<enum>) [1d_click, 1d_ev, 1d_view, 28d_click, 28d_view, ...], action_breakdowns (array<enum>) [action_canvas_component_name, action_carousel_card_id, action_carousel_card_name, action_destination, action_device, ...], action_report_time (enum) [conversion, impression, lifetime, mixed], breakdowns (array<enum>) [ad_extension_domain, ad_extension_url, ad_format_asset, age, app_id, ...], date_preset (enum) [data_maximum, last_14d, last_28d, last_30d, last_3d, ...], default_summary (boolean), export_columns (array<string>), export_format (string), export_name (string), fields (array<string>), filtering (array<object>), level (enum) [account, ad, adset, campaign], limit (integer), product_id_limit (integer), sort (array<string>), summary (array<string>), summary_action_breakdowns (array<enum>) [action_canvas_component_name, action_carousel_card_id, action_carousel_card_name, action_destination, action_device, ...], time_increment (string), time_range (object), time_ranges (array<object>), use_account_attribution_setting (boolean), use_unified_attribution_setting (boolean)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdsInsights objects. Available fields: account_currency, account_id, account_name, action_values, actions, ad_click_actions, ad_id, ad_impression_actions, ad_name, adset_end, adset_id, adset_name, adset_start, age_targeting, attribution_setting (and 184 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_insightsTool)

	// adaccount_post_insights tool
	// Params object accepts: action_attribution_windows (list<adaccountinsights_action_attribution_windows_enum_param>), action_breakdowns (list<adaccountinsights_action_breakdowns_enum_param>), action_report_time (adaccountinsights_action_report_time_enum_param), breakdowns (list<adaccountinsights_breakdowns_enum_param>), date_preset (adaccountinsights_date_preset_enum_param), default_summary (bool), export_columns (list<string>), export_format (string), export_name (string), fields (list<string>), filtering (list<Object>), level (adaccountinsights_level_enum_param), limit (int), product_id_limit (int), sort (list<string>), summary (list<string>), summary_action_breakdowns (list<adaccountinsights_summary_action_breakdowns_enum_param>), time_increment (string), time_range (map), time_ranges (list<map>), use_account_attribution_setting (bool), use_unified_attribution_setting (bool)
	adaccount_post_insightsTool := mcp.NewTool("adaccount_post_insights",
		mcp.WithDescription("POST insights for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"action_attribution_windows": map[string]any{
					"type":        "array",
					"description": "action_attribution_windows parameter",
					"enum":        []string{"1d_click", "1d_ev", "1d_view", "28d_click", "28d_view", "28d_view_all_conversions", "28d_view_first_conversion", "7d_click", "7d_view", "7d_view_all_conversions", "7d_view_first_conversion", "dda", "default", "skan_click", "skan_click_second_postback", "skan_click_third_postback", "skan_view", "skan_view_second_postback", "skan_view_third_postback"},
					"items":       map[string]any{"type": "string"},
				},
				"action_breakdowns": map[string]any{
					"type":        "array",
					"description": "action_breakdowns parameter",
					"enum":        []string{"action_canvas_component_name", "action_carousel_card_id", "action_carousel_card_name", "action_destination", "action_device", "action_reaction", "action_target_id", "action_type", "action_video_sound", "action_video_type", "conversion_destination", "matched_persona_id", "matched_persona_name", "signal_source_bucket", "standard_event_content_type"},
					"items":       map[string]any{"type": "string"},
				},
				"action_report_time": map[string]any{
					"type":        "string",
					"description": "action_report_time parameter",
					"enum":        []string{"conversion", "impression", "lifetime", "mixed"},
				},
				"breakdowns": map[string]any{
					"type":        "array",
					"description": "breakdowns parameter",
					"enum":        []string{"ad_extension_domain", "ad_extension_url", "ad_format_asset", "age", "app_id", "body_asset", "breakdown_ad_objective", "breakdown_reporting_ad_id", "call_to_action_asset", "coarse_conversion_value", "comscore_market", "comscore_market_code", "conversion_destination", "country", "creative_relaxation_asset_type", "description_asset", "device_platform", "dma", "fidelity_type", "flexible_format_asset_type", "frequency_value", "gen_ai_asset_type", "gender", "hourly_stats_aggregated_by_advertiser_time_zone", "hourly_stats_aggregated_by_audience_time_zone", "hsid", "image_asset", "impression_device", "impression_view_time_advertiser_hour_v2", "is_auto_advance", "is_conversion_id_modeled", "is_rendered_as_delayed_skip_ad", "landing_destination", "link_url_asset", "marketing_messages_btn_name", "mdsa_landing_destination", "media_asset_url", "media_creator", "media_destination_url", "media_format", "media_origin_url", "media_text_content", "media_type", "mmm", "place_page_id", "platform_position", "postback_sequence_index", "product_id", "publisher_platform", "redownload", "region", "signal_source_bucket", "skan_campaign_id", "skan_conversion_id", "skan_version", "sot_attribution_model_type", "sot_attribution_window", "sot_channel", "sot_event_type", "sot_source", "standard_event_content_type", "title_asset", "user_persona_id", "user_persona_name", "video_asset"},
					"items":       map[string]any{"type": "string"},
				},
				"date_preset": map[string]any{
					"type":        "string",
					"description": "date_preset parameter",
					"enum":        []string{"data_maximum", "last_14d", "last_28d", "last_30d", "last_3d", "last_7d", "last_90d", "last_month", "last_quarter", "last_week_mon_sun", "last_week_sun_sat", "last_year", "maximum", "this_month", "this_quarter", "this_week_mon_today", "this_week_sun_today", "this_year", "today", "yesterday"},
				},
				"default_summary": map[string]any{
					"type":        "boolean",
					"description": "default_summary parameter",
				},
				"export_columns": map[string]any{
					"type":        "array",
					"description": "export_columns parameter",
					"items":       map[string]any{"type": "string"},
				},
				"export_format": map[string]any{
					"type":        "string",
					"description": "export_format parameter",
				},
				"export_name": map[string]any{
					"type":        "string",
					"description": "export_name parameter",
				},
				"fields": map[string]any{
					"type":        "array",
					"description": "fields parameter",
					"items":       map[string]any{"type": "string"},
				},
				"filtering": map[string]any{
					"type":        "array",
					"description": "filtering parameter",
					"items":       map[string]any{"type": "object"},
				},
				"level": map[string]any{
					"type":        "string",
					"description": "level parameter",
					"enum":        []string{"account", "ad", "adset", "campaign"},
				},
				"limit": map[string]any{
					"type":        "integer",
					"description": "limit parameter",
				},
				"product_id_limit": map[string]any{
					"type":        "integer",
					"description": "product_id_limit parameter",
				},
				"sort": map[string]any{
					"type":        "array",
					"description": "sort parameter",
					"items":       map[string]any{"type": "string"},
				},
				"summary": map[string]any{
					"type":        "array",
					"description": "summary parameter",
					"items":       map[string]any{"type": "string"},
				},
				"summary_action_breakdowns": map[string]any{
					"type":        "array",
					"description": "summary_action_breakdowns parameter",
					"enum":        []string{"action_canvas_component_name", "action_carousel_card_id", "action_carousel_card_name", "action_destination", "action_device", "action_reaction", "action_target_id", "action_type", "action_video_sound", "action_video_type", "conversion_destination", "matched_persona_id", "matched_persona_name", "signal_source_bucket", "standard_event_content_type"},
					"items":       map[string]any{"type": "string"},
				},
				"time_increment": map[string]any{
					"type":        "string",
					"description": "time_increment parameter",
				},
				"time_range": map[string]any{
					"type":        "object",
					"description": "time_range parameter",
				},
				"time_ranges": map[string]any{
					"type":        "array",
					"description": "time_ranges parameter",
					"items":       map[string]any{"type": "object"},
				},
				"use_account_attribution_setting": map[string]any{
					"type":        "boolean",
					"description": "use_account_attribution_setting parameter",
				},
				"use_unified_attribution_setting": map[string]any{
					"type":        "boolean",
					"description": "use_unified_attribution_setting parameter",
				},
			}),
			mcp.Description("Parameters object containing: action_attribution_windows (array<enum>) [1d_click, 1d_ev, 1d_view, 28d_click, 28d_view, ...], action_breakdowns (array<enum>) [action_canvas_component_name, action_carousel_card_id, action_carousel_card_name, action_destination, action_device, ...], action_report_time (enum) [conversion, impression, lifetime, mixed], breakdowns (array<enum>) [ad_extension_domain, ad_extension_url, ad_format_asset, age, app_id, ...], date_preset (enum) [data_maximum, last_14d, last_28d, last_30d, last_3d, ...], default_summary (boolean), export_columns (array<string>), export_format (string), export_name (string), fields (array<string>), filtering (array<object>), level (enum) [account, ad, adset, campaign], limit (integer), product_id_limit (integer), sort (array<string>), summary (array<string>), summary_action_breakdowns (array<enum>) [action_canvas_component_name, action_carousel_card_id, action_carousel_card_name, action_destination, action_device, ...], time_increment (string), time_range (object), time_ranges (array<object>), use_account_attribution_setting (boolean), use_unified_attribution_setting (boolean)"),
		),
	)
	tools = append(tools, adaccount_post_insightsTool)

	// adaccount_get_instagram_accounts tool
	// Available fields for IGUser: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url, shopping_product_tag_eligibility, shopping_review_status, username, website
	adaccount_get_instagram_accountsTool := mcp.NewTool("adaccount_get_instagram_accounts",
		mcp.WithDescription("GET instagram_accounts for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGUser objects. Available fields: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_instagram_accountsTool)

	// adaccount_get_ios_fourteen_campaign_limits tool
	// Available fields for AdAccountIosFourteenCampaignLimits: campaign_group_limit, campaign_group_limits_details, campaign_limit
	// Params object accepts: app_id (string)
	adaccount_get_ios_fourteen_campaign_limitsTool := mcp.NewTool("adaccount_get_ios_fourteen_campaign_limits",
		mcp.WithDescription("GET ios_fourteen_campaign_limits for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"app_id": map[string]any{
					"type":        "string",
					"description": "app_id parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: app_id (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountIosFourteenCampaignLimits objects. Available fields: campaign_group_limit, campaign_group_limits_details, campaign_limit"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_ios_fourteen_campaign_limitsTool)

	// adaccount_get_matched_search_applications tool
	// Available fields for AdAccountMatchedSearchApplicationsEdgeData: app_id, are_app_events_unavailable, icon_url, name, search_source_store, store, unique_id, url
	// Params object accepts: allow_incomplete_app (bool), app_store (adaccountmatched_search_applications_app_store_enum_param), app_store_country (string), business_id (string), is_skadnetwork_search (bool), only_apps_with_permission (bool), query_term (string)
	adaccount_get_matched_search_applicationsTool := mcp.NewTool("adaccount_get_matched_search_applications",
		mcp.WithDescription("GET matched_search_applications for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"allow_incomplete_app": map[string]any{
					"type":        "boolean",
					"description": "allow_incomplete_app parameter",
				},
				"app_store": map[string]any{
					"type":        "string",
					"description": "app_store parameter",
					"required":    true,
					"enum":        []string{"AMAZON_APP_STORE", "APK_MIRROR", "APK_MONK", "APK_PURE", "APTOIDE_A1_STORE", "BEMOBI_MOBILE_STORE", "DIGITAL_TURBINE_STORE", "DOES_NOT_EXIST", "FB_ANDROID_STORE", "FB_CANVAS", "FB_GAMEROOM", "GALAXY_STORE", "GOOGLE_PLAY", "INSTANT_GAME", "ITUNES", "ITUNES_IPAD", "NEON_ANDROID_STORE", "NONE", "OCULUS_APP_STORE", "OPPO", "ROKU_STORE", "UPTODOWN", "VIVO", "WINDOWS_10_STORE", "WINDOWS_STORE", "XIAOMI"},
				},
				"app_store_country": map[string]any{
					"type":        "string",
					"description": "app_store_country parameter",
				},
				"business_id": map[string]any{
					"type":        "string",
					"description": "business_id parameter",
				},
				"is_skadnetwork_search": map[string]any{
					"type":        "boolean",
					"description": "is_skadnetwork_search parameter",
				},
				"only_apps_with_permission": map[string]any{
					"type":        "boolean",
					"description": "only_apps_with_permission parameter",
				},
				"query_term": map[string]any{
					"type":        "string",
					"description": "query_term parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: allow_incomplete_app (boolean), app_store (enum) [AMAZON_APP_STORE, APK_MIRROR, APK_MONK, APK_PURE, APTOIDE_A1_STORE, ...] [required], app_store_country (string), business_id (string), is_skadnetwork_search (boolean), only_apps_with_permission (boolean), query_term (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountMatchedSearchApplicationsEdgeData objects. Available fields: app_id, are_app_events_unavailable, icon_url, name, search_source_store, store, unique_id, url"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_matched_search_applicationsTool)

	// adaccount_get_max_bid tool
	// Available fields for AdAccountMaxBid: max_bid
	adaccount_get_max_bidTool := mcp.NewTool("adaccount_get_max_bid",
		mcp.WithDescription("GET max_bid for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountMaxBid objects. Available fields: max_bid"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_max_bidTool)

	// adaccount_get_mcmeconversions tool
	// Available fields for AdsMcmeConversion: creation_time, description, id, is_archived, mcme_conversion_type, name, omnichannel_object_id
	adaccount_get_mcmeconversionsTool := mcp.NewTool("adaccount_get_mcmeconversions",
		mcp.WithDescription("GET mcmeconversions for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdsMcmeConversion objects. Available fields: creation_time, description, id, is_archived, mcme_conversion_type, name, omnichannel_object_id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_mcmeconversionsTool)

	// adaccount_get_minimum_budgets tool
	// Available fields for MinimumBudget: currency, min_daily_budget_high_freq, min_daily_budget_imp, min_daily_budget_low_freq, min_daily_budget_video_views
	// Params object accepts: bid_amount (int)
	adaccount_get_minimum_budgetsTool := mcp.NewTool("adaccount_get_minimum_budgets",
		mcp.WithDescription("GET minimum_budgets for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"bid_amount": map[string]any{
					"type":        "integer",
					"description": "bid_amount parameter",
				},
			}),
			mcp.Description("Parameters object containing: bid_amount (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for MinimumBudget objects. Available fields: currency, min_daily_budget_high_freq, min_daily_budget_imp, min_daily_budget_low_freq, min_daily_budget_video_views"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_minimum_budgetsTool)

	// adaccount_get_onbehalf_requests tool
	// Available fields for BusinessOwnedObjectOnBehalfOfRequest: business_owned_object, id, receiving_business, requesting_business, status
	// Params object accepts: status (adaccountonbehalf_requests_status_enum_param)
	adaccount_get_onbehalf_requestsTool := mcp.NewTool("adaccount_get_onbehalf_requests",
		mcp.WithDescription("GET onbehalf_requests for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"status": map[string]any{
					"type":        "string",
					"description": "status parameter",
					"enum":        []string{"APPROVE", "CANCELED", "DECLINE", "EXPIRED", "IN_PROGRESS", "PENDING", "PENDING_EMAIL_VERIFICATION", "PENDING_INTEGRITY_REVIEW"},
				},
			}),
			mcp.Description("Parameters object containing: status (enum) [APPROVE, CANCELED, DECLINE, EXPIRED, IN_PROGRESS, ...]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for BusinessOwnedObjectOnBehalfOfRequest objects. Available fields: business_owned_object, id, receiving_business, requesting_business, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_onbehalf_requestsTool)

	// adaccount_post_product_audiences tool
	// Params object accepts: allowed_domains (list<string>), associated_audience_id (unsigned int), claim_objective (adaccountproduct_audiences_claim_objective_enum_param), content_type (adaccountproduct_audiences_content_type_enum_param), creation_params (map), description (string), enable_fetch_or_create (bool), event_source_group (string), event_sources (list<map>), exclusions (list<Object>), inclusions (list<Object>), is_snapshot (bool), is_value_based (bool), name (string), opt_out_link (string), parent_audience_id (unsigned int), product_set_id (string), rev_share_policy_id (unsigned int), subtype (adaccountproduct_audiences_subtype_enum_param)
	adaccount_post_product_audiencesTool := mcp.NewTool("adaccount_post_product_audiences",
		mcp.WithDescription("POST product_audiences for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"allowed_domains": map[string]any{
					"type":        "array",
					"description": "allowed_domains parameter",
					"items":       map[string]any{"type": "string"},
				},
				"associated_audience_id": map[string]any{
					"type":        "integer",
					"description": "associated_audience_id parameter",
				},
				"claim_objective": map[string]any{
					"type":        "string",
					"description": "claim_objective parameter",
					"enum":        []string{"AUTOMOTIVE_MODEL", "COLLABORATIVE_ADS", "HOME_LISTING", "MEDIA_TITLE", "PRODUCT", "TRAVEL", "VEHICLE", "VEHICLE_OFFER"},
				},
				"content_type": map[string]any{
					"type":        "string",
					"description": "content_type parameter",
					"enum":        []string{"AUTOMOTIVE_MODEL", "DESTINATION", "FLIGHT", "GENERIC", "HOME_LISTING", "HOTEL", "LOCAL_SERVICE_BUSINESS", "MEDIA_TITLE", "OFFLINE_PRODUCT", "PRODUCT", "VEHICLE", "VEHICLE_OFFER"},
				},
				"creation_params": map[string]any{
					"type":        "object",
					"description": "creation_params parameter",
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"enable_fetch_or_create": map[string]any{
					"type":        "boolean",
					"description": "enable_fetch_or_create parameter",
				},
				"event_source_group": map[string]any{
					"type":        "string",
					"description": "event_source_group parameter",
				},
				"event_sources": map[string]any{
					"type":        "array",
					"description": "event_sources parameter",
					"items":       map[string]any{"type": "object"},
				},
				"exclusions": map[string]any{
					"type":        "array",
					"description": "exclusions parameter",
					"items":       map[string]any{"type": "object"},
				},
				"inclusions": map[string]any{
					"type":        "array",
					"description": "inclusions parameter",
					"items":       map[string]any{"type": "object"},
				},
				"is_snapshot": map[string]any{
					"type":        "boolean",
					"description": "is_snapshot parameter",
				},
				"is_value_based": map[string]any{
					"type":        "boolean",
					"description": "is_value_based parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"opt_out_link": map[string]any{
					"type":        "string",
					"description": "opt_out_link parameter",
				},
				"parent_audience_id": map[string]any{
					"type":        "integer",
					"description": "parent_audience_id parameter",
				},
				"product_set_id": map[string]any{
					"type":        "string",
					"description": "product_set_id parameter",
					"required":    true,
				},
				"rev_share_policy_id": map[string]any{
					"type":        "integer",
					"description": "rev_share_policy_id parameter",
				},
				"subtype": map[string]any{
					"type":        "string",
					"description": "subtype parameter",
					"enum":        []string{"APP", "BAG_OF_ACCOUNTS", "BIDDING", "CLAIM", "CUSTOM", "ENGAGEMENT", "EXCLUSION", "FOX", "LOOKALIKE", "MANAGED", "MEASUREMENT", "MESSENGER_SUBSCRIBER_LIST", "OFFLINE_CONVERSION", "PARTNER", "PRIMARY", "REGULATED_CATEGORIES_AUDIENCE", "STUDY_RULE_AUDIENCE", "VIDEO", "WEBSITE"},
				},
			}),
			mcp.Description("Parameters object containing: allowed_domains (array<string>), associated_audience_id (integer), claim_objective (enum) [AUTOMOTIVE_MODEL, COLLABORATIVE_ADS, HOME_LISTING, MEDIA_TITLE, PRODUCT, ...], content_type (enum) [AUTOMOTIVE_MODEL, DESTINATION, FLIGHT, GENERIC, HOME_LISTING, ...], creation_params (object), description (string), enable_fetch_or_create (boolean), event_source_group (string), event_sources (array<object>), exclusions (array<object>), inclusions (array<object>), is_snapshot (boolean), is_value_based (boolean), name (string) [required], opt_out_link (string), parent_audience_id (integer), product_set_id (string) [required], rev_share_policy_id (integer), subtype (enum) [APP, BAG_OF_ACCOUNTS, BIDDING, CLAIM, CUSTOM, ...]"),
		),
	)
	tools = append(tools, adaccount_post_product_audiencesTool)

	// adaccount_get_promote_pages tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	adaccount_get_promote_pagesTool := mcp.NewTool("adaccount_get_promote_pages",
		mcp.WithDescription("GET promote_pages for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_promote_pagesTool)

	// adaccount_get_publisher_block_lists tool
	// Available fields for PublisherBlockList: app_publishers, business_owner_id, id, is_auto_blocking_on, is_eligible_at_campaign_level, last_update_time, last_update_user, name, owner_ad_account_id, web_publishers
	adaccount_get_publisher_block_listsTool := mcp.NewTool("adaccount_get_publisher_block_lists",
		mcp.WithDescription("GET publisher_block_lists for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PublisherBlockList objects. Available fields: app_publishers, business_owner_id, id, is_auto_blocking_on, is_eligible_at_campaign_level, last_update_time, last_update_user, name, owner_ad_account_id, web_publishers"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_publisher_block_listsTool)

	// adaccount_post_publisher_block_lists tool
	// Params object accepts: name (string)
	adaccount_post_publisher_block_listsTool := mcp.NewTool("adaccount_post_publisher_block_lists",
		mcp.WithDescription("POST publisher_block_lists for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
			}),
			mcp.Description("Parameters object containing: name (string)"),
		),
	)
	tools = append(tools, adaccount_post_publisher_block_listsTool)

	// adaccount_get_reachestimate tool
	// Available fields for AdAccountReachEstimate: estimate_ready, users_lower_bound, users_upper_bound
	// Params object accepts: adgroup_ids (list<string>), caller_id (string), concepts (string), creative_action_spec (string), is_debug (bool), object_store_url (string), targeting_spec (Targeting)
	adaccount_get_reachestimateTool := mcp.NewTool("adaccount_get_reachestimate",
		mcp.WithDescription("GET reachestimate for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"adgroup_ids": map[string]any{
					"type":        "array",
					"description": "adgroup_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"caller_id": map[string]any{
					"type":        "string",
					"description": "caller_id parameter",
				},
				"concepts": map[string]any{
					"type":        "string",
					"description": "concepts parameter",
				},
				"creative_action_spec": map[string]any{
					"type":        "string",
					"description": "creative_action_spec parameter",
				},
				"is_debug": map[string]any{
					"type":        "boolean",
					"description": "is_debug parameter",
				},
				"object_store_url": map[string]any{
					"type":        "string",
					"description": "object_store_url parameter",
				},
				"targeting_spec": map[string]any{
					"type":        "string",
					"description": "targeting_spec parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: adgroup_ids (array<string>), caller_id (string), concepts (string), creative_action_spec (string), is_debug (boolean), object_store_url (string), targeting_spec (Targeting) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountReachEstimate objects. Available fields: estimate_ready, users_lower_bound, users_upper_bound"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_reachestimateTool)

	// adaccount_get_reachfrequencypredictions tool
	// Available fields for ReachFrequencyPrediction: account_id, activity_status, ad_formats, auction_entry_option_index, audience_size_lower_bound, audience_size_upper_bound, business_id, buying_type, campaign_group_id, campaign_id, campaign_time_start, campaign_time_stop, currency, curve_budget_reach, curve_reach, daily_grp_curve, daily_impression_curve, daily_impression_curve_map, day_parting_schedule, destination_id, end_time, expiration_time, external_budget, external_impression, external_maximum_budget, external_maximum_impression, external_maximum_reach, external_minimum_budget, external_minimum_impression, external_minimum_reach, external_reach, feed_ratio_0000, frequency_cap, frequency_distribution_map, frequency_distribution_map_agg, grp_audience_size, grp_avg_probability_map, grp_country_audience_size, grp_curve, grp_dmas_audience_size, grp_filtering_threshold_00, grp_points, grp_ratio, grp_reach_ratio, grp_status, holdout_percentage, id, impression_curve, instagram_destination_id, instream_packages, interval_frequency_cap, interval_frequency_cap_reset_period, is_balanced_frequency, is_bonus_media, is_conversion_goal, is_higher_average_frequency, is_io, is_reserved_buying, is_trp, name, objective, objective_name, odax_objective, odax_objective_name, optimization_goal, optimization_goal_name, pause_periods, percent_reach_at_target_frequency, placement_breakdown, placement_breakdown_map, plan_name, plan_type, prediction_mode, prediction_progress, reference_id, reservation_status, start_time, status, story_event_type, target_cpm, target_frequency, target_frequency_reset_period, target_spec, time_created, time_updated, timezone_id, timezone_name, topline_id, video_view_length_constraint, viewtag
	adaccount_get_reachfrequencypredictionsTool := mcp.NewTool("adaccount_get_reachfrequencypredictions",
		mcp.WithDescription("GET reachfrequencypredictions for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ReachFrequencyPrediction objects. Available fields: account_id, activity_status, ad_formats, auction_entry_option_index, audience_size_lower_bound, audience_size_upper_bound, business_id, buying_type, campaign_group_id, campaign_id, campaign_time_start, campaign_time_stop, currency, curve_budget_reach, curve_reach (and 75 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_reachfrequencypredictionsTool)

	// adaccount_post_reachfrequencypredictions tool
	// Params object accepts: action (adaccountreachfrequencypredictions_action_enum_param), ad_formats (list<map>), auction_entry_option_index (unsigned int), budget (unsigned int), buying_type (adaccountreachfrequencypredictions_buying_type_enum_param), campaign_group_id (string), day_parting_schedule (list<Object>), deal_id (string), destination_id (unsigned int), destination_ids (list<string>), end_time (unsigned int), exceptions (bool), existing_campaign_id (string), expiration_time (unsigned int), frequency_cap (unsigned int), grp_buying (bool), impression (unsigned int), instream_packages (list<adaccountreachfrequencypredictions_instream_packages_enum_param>), interval_frequency_cap_reset_period (unsigned int), is_balanced_frequency (bool), is_bonus_media (bool), is_conversion_goal (bool), is_full_view (bool), is_higher_average_frequency (bool), is_reach_and_frequency_io_buying (bool), is_reserved_buying (bool), num_curve_points (unsigned int), objective (string), optimization_goal (string), prediction_mode (unsigned int), reach (unsigned int), rf_prediction_id (string), rf_prediction_id_to_release (string), rf_prediction_id_to_share (string), start_time (unsigned int), stop_time (unsigned int), story_event_type (unsigned int), target_cpm (unsigned int), target_frequency (unsigned int), target_frequency_reset_period (unsigned int), target_spec (Targeting), video_view_length_constraint (unsigned int)
	adaccount_post_reachfrequencypredictionsTool := mcp.NewTool("adaccount_post_reachfrequencypredictions",
		mcp.WithDescription("POST reachfrequencypredictions for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"action": map[string]any{
					"type":        "string",
					"description": "action parameter",
					"enum":        []string{"cancel", "quote", "reserve"},
				},
				"ad_formats": map[string]any{
					"type":        "array",
					"description": "ad_formats parameter",
					"items":       map[string]any{"type": "object"},
				},
				"auction_entry_option_index": map[string]any{
					"type":        "integer",
					"description": "auction_entry_option_index parameter",
				},
				"budget": map[string]any{
					"type":        "integer",
					"description": "budget parameter",
				},
				"buying_type": map[string]any{
					"type":        "string",
					"description": "buying_type parameter",
					"enum":        []string{"AUCTION", "DEPRECATED_REACH_BLOCK", "FIXED_CPM", "MIXED", "REACHBLOCK", "RESEARCH_POLL", "RESERVED"},
				},
				"campaign_group_id": map[string]any{
					"type":        "string",
					"description": "campaign_group_id parameter",
				},
				"day_parting_schedule": map[string]any{
					"type":        "array",
					"description": "day_parting_schedule parameter",
					"items":       map[string]any{"type": "object"},
				},
				"deal_id": map[string]any{
					"type":        "string",
					"description": "deal_id parameter",
				},
				"destination_id": map[string]any{
					"type":        "integer",
					"description": "destination_id parameter",
				},
				"destination_ids": map[string]any{
					"type":        "array",
					"description": "destination_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"end_time": map[string]any{
					"type":        "integer",
					"description": "end_time parameter",
				},
				"exceptions": map[string]any{
					"type":        "boolean",
					"description": "exceptions parameter",
				},
				"existing_campaign_id": map[string]any{
					"type":        "string",
					"description": "existing_campaign_id parameter",
				},
				"expiration_time": map[string]any{
					"type":        "integer",
					"description": "expiration_time parameter",
				},
				"frequency_cap": map[string]any{
					"type":        "integer",
					"description": "frequency_cap parameter",
				},
				"grp_buying": map[string]any{
					"type":        "boolean",
					"description": "grp_buying parameter",
				},
				"impression": map[string]any{
					"type":        "integer",
					"description": "impression parameter",
				},
				"instream_packages": map[string]any{
					"type":        "array",
					"description": "instream_packages parameter",
					"enum":        []string{"BEAUTY", "ENTERTAINMENT", "FOOD", "NORMAL", "PREMIUM", "REGULAR_ANIMALS_PETS", "REGULAR_FOOD", "REGULAR_GAMES", "REGULAR_POLITICS", "REGULAR_SPORTS", "REGULAR_STYLE", "REGULAR_TV_MOVIES", "SPANISH", "SPORTS"},
					"items":       map[string]any{"type": "string"},
				},
				"interval_frequency_cap_reset_period": map[string]any{
					"type":        "integer",
					"description": "interval_frequency_cap_reset_period parameter",
				},
				"is_balanced_frequency": map[string]any{
					"type":        "boolean",
					"description": "is_balanced_frequency parameter",
				},
				"is_bonus_media": map[string]any{
					"type":        "boolean",
					"description": "is_bonus_media parameter",
				},
				"is_conversion_goal": map[string]any{
					"type":        "boolean",
					"description": "is_conversion_goal parameter",
				},
				"is_full_view": map[string]any{
					"type":        "boolean",
					"description": "is_full_view parameter",
				},
				"is_higher_average_frequency": map[string]any{
					"type":        "boolean",
					"description": "is_higher_average_frequency parameter",
				},
				"is_reach_and_frequency_io_buying": map[string]any{
					"type":        "boolean",
					"description": "is_reach_and_frequency_io_buying parameter",
				},
				"is_reserved_buying": map[string]any{
					"type":        "boolean",
					"description": "is_reserved_buying parameter",
				},
				"num_curve_points": map[string]any{
					"type":        "integer",
					"description": "num_curve_points parameter",
				},
				"objective": map[string]any{
					"type":        "string",
					"description": "objective parameter",
				},
				"optimization_goal": map[string]any{
					"type":        "string",
					"description": "optimization_goal parameter",
				},
				"prediction_mode": map[string]any{
					"type":        "integer",
					"description": "prediction_mode parameter",
				},
				"reach": map[string]any{
					"type":        "integer",
					"description": "reach parameter",
				},
				"rf_prediction_id": map[string]any{
					"type":        "string",
					"description": "rf_prediction_id parameter",
				},
				"rf_prediction_id_to_release": map[string]any{
					"type":        "string",
					"description": "rf_prediction_id_to_release parameter",
				},
				"rf_prediction_id_to_share": map[string]any{
					"type":        "string",
					"description": "rf_prediction_id_to_share parameter",
				},
				"start_time": map[string]any{
					"type":        "integer",
					"description": "start_time parameter",
				},
				"stop_time": map[string]any{
					"type":        "integer",
					"description": "stop_time parameter",
				},
				"story_event_type": map[string]any{
					"type":        "integer",
					"description": "story_event_type parameter",
				},
				"target_cpm": map[string]any{
					"type":        "integer",
					"description": "target_cpm parameter",
				},
				"target_frequency": map[string]any{
					"type":        "integer",
					"description": "target_frequency parameter",
				},
				"target_frequency_reset_period": map[string]any{
					"type":        "integer",
					"description": "target_frequency_reset_period parameter",
				},
				"target_spec": map[string]any{
					"type":        "string",
					"description": "target_spec parameter",
				},
				"video_view_length_constraint": map[string]any{
					"type":        "integer",
					"description": "video_view_length_constraint parameter",
				},
			}),
			mcp.Description("Parameters object containing: action (enum) [cancel, quote, reserve], ad_formats (array<object>), auction_entry_option_index (integer), budget (integer), buying_type (enum) [AUCTION, DEPRECATED_REACH_BLOCK, FIXED_CPM, MIXED, REACHBLOCK, ...], campaign_group_id (string), day_parting_schedule (array<object>), deal_id (string), destination_id (integer), destination_ids (array<string>), end_time (integer), exceptions (boolean), existing_campaign_id (string), expiration_time (integer), frequency_cap (integer), grp_buying (boolean), impression (integer), instream_packages (array<enum>) [BEAUTY, ENTERTAINMENT, FOOD, NORMAL, PREMIUM, ...], interval_frequency_cap_reset_period (integer), is_balanced_frequency (boolean), is_bonus_media (boolean), is_conversion_goal (boolean), is_full_view (boolean), is_higher_average_frequency (boolean), is_reach_and_frequency_io_buying (boolean), is_reserved_buying (boolean), num_curve_points (integer), objective (string), optimization_goal (string), prediction_mode (integer), reach (integer), rf_prediction_id (string), rf_prediction_id_to_release (string), rf_prediction_id_to_share (string), start_time (integer), stop_time (integer), story_event_type (integer), target_cpm (integer), target_frequency (integer), target_frequency_reset_period (integer), target_spec (Targeting), video_view_length_constraint (integer)"),
		),
	)
	tools = append(tools, adaccount_post_reachfrequencypredictionsTool)

	// adaccount_get_recommendations tool
	// Available fields for AdAccountRecommendations: recommendations
	adaccount_get_recommendationsTool := mcp.NewTool("adaccount_get_recommendations",
		mcp.WithDescription("GET recommendations for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountRecommendations objects. Available fields: recommendations"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_recommendationsTool)

	// adaccount_post_recommendations tool
	// Params object accepts: asc_fragmentation_parameters (map), autoflow_parameters (map), fragmentation_parameters (map), music_parameters (map), recommendation_signature (string), scale_good_campaign_parameters (map)
	adaccount_post_recommendationsTool := mcp.NewTool("adaccount_post_recommendations",
		mcp.WithDescription("POST recommendations for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"asc_fragmentation_parameters": map[string]any{
					"type":        "object",
					"description": "asc_fragmentation_parameters parameter",
				},
				"autoflow_parameters": map[string]any{
					"type":        "object",
					"description": "autoflow_parameters parameter",
				},
				"fragmentation_parameters": map[string]any{
					"type":        "object",
					"description": "fragmentation_parameters parameter",
				},
				"music_parameters": map[string]any{
					"type":        "object",
					"description": "music_parameters parameter",
				},
				"recommendation_signature": map[string]any{
					"type":        "string",
					"description": "recommendation_signature parameter",
					"required":    true,
				},
				"scale_good_campaign_parameters": map[string]any{
					"type":        "object",
					"description": "scale_good_campaign_parameters parameter",
				},
			}),
			mcp.Description("Parameters object containing: asc_fragmentation_parameters (object), autoflow_parameters (object), fragmentation_parameters (object), music_parameters (object), recommendation_signature (string) [required], scale_good_campaign_parameters (object)"),
		),
	)
	tools = append(tools, adaccount_post_recommendationsTool)

	// adaccount_get_saved_audiences tool
	// Available fields for SavedAudience: account, approximate_count_lower_bound, approximate_count_upper_bound, delete_time, description, id, name, operation_status, owner_business, page_deletion_marked_delete_time, permission_for_actions, run_status, sentence_lines, targeting, time_created, time_updated
	// Params object accepts: business_id (string), fields (list<string>), filtering (list<Object>)
	adaccount_get_saved_audiencesTool := mcp.NewTool("adaccount_get_saved_audiences",
		mcp.WithDescription("GET saved_audiences for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"business_id": map[string]any{
					"type":        "string",
					"description": "business_id parameter",
				},
				"fields": map[string]any{
					"type":        "array",
					"description": "fields parameter",
					"items":       map[string]any{"type": "string"},
				},
				"filtering": map[string]any{
					"type":        "array",
					"description": "filtering parameter",
					"items":       map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: business_id (string), fields (array<string>), filtering (array<object>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for SavedAudience objects. Available fields: account, approximate_count_lower_bound, approximate_count_upper_bound, delete_time, description, id, name, operation_status, owner_business, page_deletion_marked_delete_time, permission_for_actions, run_status, sentence_lines, targeting, time_created (and 1 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_saved_audiencesTool)

	// adaccount_delete_subscribed_apps tool
	// Params object accepts: app_id (string)
	adaccount_delete_subscribed_appsTool := mcp.NewTool("adaccount_delete_subscribed_apps",
		mcp.WithDescription("DELETE subscribed_apps for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"app_id": map[string]any{
					"type":        "string",
					"description": "app_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: app_id (string)"),
		),
	)
	tools = append(tools, adaccount_delete_subscribed_appsTool)

	// adaccount_get_subscribed_apps tool
	// Available fields for AdAccountSubscribedApps: app_id, app_name
	adaccount_get_subscribed_appsTool := mcp.NewTool("adaccount_get_subscribed_apps",
		mcp.WithDescription("GET subscribed_apps for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountSubscribedApps objects. Available fields: app_id, app_name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_subscribed_appsTool)

	// adaccount_post_subscribed_apps tool
	// Params object accepts: app_id (string)
	adaccount_post_subscribed_appsTool := mcp.NewTool("adaccount_post_subscribed_apps",
		mcp.WithDescription("POST subscribed_apps for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"app_id": map[string]any{
					"type":        "string",
					"description": "app_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: app_id (string)"),
		),
	)
	tools = append(tools, adaccount_post_subscribed_appsTool)

	// adaccount_get_targetingbrowse tool
	// Available fields for AdAccountTargetingUnified: audience_size_lower_bound, audience_size_upper_bound, conversion_lift, description, id, img, info, info_title, is_recommendation, key, link, name, parent, partner, path, performance_rating, raw_name, recommendation_model, search_interest_id, source, spend, type, valid
	// Params object accepts: excluded_category (string), include_nodes (bool), is_exclusion (bool), limit_type (adaccounttargetingbrowse_limit_type_enum_param), regulated_categories (list<adaccounttargetingbrowse_regulated_categories_enum_param>), regulated_countries (list<adaccounttargetingbrowse_regulated_countries_enum_param>), whitelisted_types (list<adaccounttargetingbrowse_whitelisted_types_enum_param>)
	adaccount_get_targetingbrowseTool := mcp.NewTool("adaccount_get_targetingbrowse",
		mcp.WithDescription("GET targetingbrowse for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"excluded_category": map[string]any{
					"type":        "string",
					"description": "excluded_category parameter",
				},
				"include_nodes": map[string]any{
					"type":        "boolean",
					"description": "include_nodes parameter",
				},
				"is_exclusion": map[string]any{
					"type":        "boolean",
					"description": "is_exclusion parameter",
				},
				"limit_type": map[string]any{
					"type":        "string",
					"description": "limit_type parameter",
					"enum":        []string{"behaviors", "college_years", "education_majors", "education_schools", "education_statuses", "ethnic_affinity", "family_statuses", "generation", "home_ownership", "home_type", "home_value", "household_composition", "income", "industries", "interested_in", "interests", "life_events", "location_categories", "moms", "net_worth", "office_type", "politics", "relationship_statuses", "user_adclusters", "work_employers", "work_positions"},
				},
				"regulated_categories": map[string]any{
					"type":        "array",
					"description": "regulated_categories parameter",
					"enum":        []string{"CREDIT", "EMPLOYMENT", "FINANCIAL_PRODUCTS_SERVICES", "HOUSING", "ISSUES_ELECTIONS_POLITICS", "NONE", "ONLINE_GAMBLING_AND_GAMING"},
					"items":       map[string]any{"type": "string"},
				},
				"regulated_countries": map[string]any{
					"type":        "array",
					"description": "regulated_countries parameter",
					"enum":        []string{"AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "XK", "YE", "YT", "ZA", "ZM", "ZW"},
					"items":       map[string]any{"type": "string"},
				},
				"whitelisted_types": map[string]any{
					"type":        "array",
					"description": "whitelisted_types parameter",
					"enum":        []string{"adgroup_id", "age_max", "age_min", "age_range", "alternate_auto_targeting_option", "app_install_state", "audience_network_positions", "behaviors", "brand_safety_content_filter_levels", "brand_safety_content_severity_levels", "cafe_ca_contraction_targeting_signal", "cafe_ca_expansion_targeting_signal", "catalog_based_targeting", "cities", "city_keys", "college_years", "conjunctive_user_adclusters", "connections", "contextual_targeting_categories", "countries", "country", "country_groups", "custom_audiences", "device_platforms", "direct_install_devices", "dynamic_audience_ids", "education_majors", "education_schools", "education_statuses", "effective_audience_network_positions", "effective_device_platforms", "effective_facebook_positions", "effective_instagram_positions", "effective_messenger_positions", "effective_oculus_positions", "effective_publisher_platforms", "effective_threads_positions", "effective_whatsapp_positions", "engagement_specs", "ethnic_affinity", "exclude_previous_days", "exclude_reached_since", "excluded_brand_safety_content_types", "excluded_connections", "excluded_custom_audiences", "excluded_dynamic_audience_ids", "excluded_engagement_specs", "excluded_geo_locations", "excluded_mobile_device_model", "excluded_product_audience_specs", "excluded_publisher_categories", "excluded_publisher_list_ids", "excluded_user_adclusters", "excluded_user_device", "exclusions", "expanded_implicit_custom_audiences", "facebook_positions", "family_statuses", "fb_deal_id", "flexible_spec", "follow_profiles", "follow_profiles_negative", "format", "friends_of_connections", "gatekeepers", "genders", "generation", "geo_locations", "home_ownership", "home_type", "home_value", "household_composition", "household_income", "id", "income", "industries", "instagram_hashtags", "instagram_positions", "install_state_application", "instream_video_skippable_excluded", "instream_video_sponsorship_placements", "interest_defaults_source", "interested_in", "interests", "is_instagram_destination_ad", "is_whatsapp_destination_ad", "keywords", "life_events", "locales", "location_categories", "location_cluster_ids", "location_expansion", "marketing_message_channels", "marketplace_product_categories", "messenger_positions", "mobile_device_model", "moms", "net_worth", "oculus_positions", "office_type", "page_types", "place_page_set_ids", "political_views", "politics", "product_audience_specs", "prospecting_audience", "publisher_platforms", "radius", "region_keys", "regions", "relationship_statuses", "rtb_flag", "site_category", "subscriber_universe", "tafe_ca_mitigation_strategy", "targeting_automation", "targeting_optimization", "targeting_relaxation_types", "threads_positions", "timezones", "topic", "trending", "user_adclusters", "user_age_unknown", "user_device", "user_event", "user_os", "user_page_threads", "user_page_threads_excluded", "whatsapp_positions", "wireless_carrier", "work_employers", "work_positions", "zips"},
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: excluded_category (string), include_nodes (boolean), is_exclusion (boolean), limit_type (enum) [behaviors, college_years, education_majors, education_schools, education_statuses, ...], regulated_categories (array<enum>) [CREDIT, EMPLOYMENT, FINANCIAL_PRODUCTS_SERVICES, HOUSING, ISSUES_ELECTIONS_POLITICS, ...], regulated_countries (array<enum>) [AD, AE, AF, AG, AI, ...], whitelisted_types (array<enum>) [adgroup_id, age_max, age_min, age_range, alternate_auto_targeting_option, ...]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountTargetingUnified objects. Available fields: audience_size_lower_bound, audience_size_upper_bound, conversion_lift, description, id, img, info, info_title, is_recommendation, key, link, name, parent, partner, path (and 8 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_targetingbrowseTool)

	// adaccount_get_targetingsearch tool
	// Available fields for AdAccountTargetingUnified: audience_size_lower_bound, audience_size_upper_bound, conversion_lift, description, id, img, info, info_title, is_recommendation, key, link, name, parent, partner, path, performance_rating, raw_name, recommendation_model, search_interest_id, source, spend, type, valid
	// Params object accepts: allow_only_fat_head_interests (bool), app_store (adaccounttargetingsearch_app_store_enum_param), countries (list<string>), is_account_level_brand_safety_exclusion (bool), is_account_level_employer_exclusion (bool), is_exclusion (bool), limit_type (adaccounttargetingsearch_limit_type_enum_param), objective (adaccounttargetingsearch_objective_enum_param), promoted_object (Object), q (string), regulated_categories (list<adaccounttargetingsearch_regulated_categories_enum_param>), regulated_countries (list<adaccounttargetingsearch_regulated_countries_enum_param>), session_id (unsigned int), targeting_list (list<Object>), whitelisted_types (list<adaccounttargetingsearch_whitelisted_types_enum_param>)
	adaccount_get_targetingsearchTool := mcp.NewTool("adaccount_get_targetingsearch",
		mcp.WithDescription("GET targetingsearch for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"allow_only_fat_head_interests": map[string]any{
					"type":        "boolean",
					"description": "allow_only_fat_head_interests parameter",
				},
				"app_store": map[string]any{
					"type":        "string",
					"description": "app_store parameter",
					"enum":        []string{"amazon_app_store", "apk_mirror", "apk_monk", "apk_pure", "aptoide_a1_store", "bemobi_mobile_store", "digital_turbine_store", "does_not_exist", "fb_android_store", "fb_canvas", "fb_gameroom", "galaxy_store", "google_play", "instant_game", "itunes", "itunes_ipad", "neon_android_store", "none", "oculus_app_store", "oppo", "roku_channel_store", "uptodown", "vivo", "windows_10_store", "windows_store", "xiaomi"},
				},
				"countries": map[string]any{
					"type":        "array",
					"description": "countries parameter",
					"items":       map[string]any{"type": "string"},
				},
				"is_account_level_brand_safety_exclusion": map[string]any{
					"type":        "boolean",
					"description": "is_account_level_brand_safety_exclusion parameter",
				},
				"is_account_level_employer_exclusion": map[string]any{
					"type":        "boolean",
					"description": "is_account_level_employer_exclusion parameter",
				},
				"is_exclusion": map[string]any{
					"type":        "boolean",
					"description": "is_exclusion parameter",
				},
				"limit_type": map[string]any{
					"type":        "string",
					"description": "limit_type parameter",
					"enum":        []string{"adgroup_id", "age_max", "age_min", "age_range", "alternate_auto_targeting_option", "app_install_state", "audience_network_positions", "behaviors", "brand_safety_content_filter_levels", "brand_safety_content_severity_levels", "cafe_ca_contraction_targeting_signal", "cafe_ca_expansion_targeting_signal", "catalog_based_targeting", "cities", "city_keys", "college_years", "conjunctive_user_adclusters", "connections", "contextual_targeting_categories", "countries", "country", "country_groups", "custom_audiences", "device_platforms", "direct_install_devices", "dynamic_audience_ids", "education_majors", "education_schools", "education_statuses", "effective_audience_network_positions", "effective_device_platforms", "effective_facebook_positions", "effective_instagram_positions", "effective_messenger_positions", "effective_oculus_positions", "effective_publisher_platforms", "effective_threads_positions", "effective_whatsapp_positions", "engagement_specs", "ethnic_affinity", "exclude_previous_days", "exclude_reached_since", "excluded_brand_safety_content_types", "excluded_connections", "excluded_custom_audiences", "excluded_dynamic_audience_ids", "excluded_engagement_specs", "excluded_geo_locations", "excluded_mobile_device_model", "excluded_product_audience_specs", "excluded_publisher_categories", "excluded_publisher_list_ids", "excluded_user_adclusters", "excluded_user_device", "exclusions", "expanded_implicit_custom_audiences", "facebook_positions", "family_statuses", "fb_deal_id", "flexible_spec", "follow_profiles", "follow_profiles_negative", "format", "friends_of_connections", "gatekeepers", "genders", "generation", "geo_locations", "home_ownership", "home_type", "home_value", "household_composition", "household_income", "id", "income", "industries", "instagram_hashtags", "instagram_positions", "install_state_application", "instream_video_skippable_excluded", "instream_video_sponsorship_placements", "interest_defaults_source", "interested_in", "interests", "is_instagram_destination_ad", "is_whatsapp_destination_ad", "keywords", "life_events", "locales", "location_categories", "location_cluster_ids", "location_expansion", "marketing_message_channels", "marketplace_product_categories", "messenger_positions", "mobile_device_model", "moms", "net_worth", "oculus_positions", "office_type", "page_types", "place_page_set_ids", "political_views", "politics", "product_audience_specs", "prospecting_audience", "publisher_platforms", "radius", "region_keys", "regions", "relationship_statuses", "rtb_flag", "site_category", "subscriber_universe", "tafe_ca_mitigation_strategy", "targeting_automation", "targeting_optimization", "targeting_relaxation_types", "threads_positions", "timezones", "topic", "trending", "user_adclusters", "user_age_unknown", "user_device", "user_event", "user_os", "user_page_threads", "user_page_threads_excluded", "whatsapp_positions", "wireless_carrier", "work_employers", "work_positions", "zips"},
				},
				"objective": map[string]any{
					"type":        "string",
					"description": "objective parameter",
					"enum":        []string{"APP_INSTALLS", "BRAND_AWARENESS", "CONVERSIONS", "EVENT_RESPONSES", "LEAD_GENERATION", "LINK_CLICKS", "LOCAL_AWARENESS", "MESSAGES", "OFFER_CLAIMS", "OUTCOME_APP_PROMOTION", "OUTCOME_AWARENESS", "OUTCOME_ENGAGEMENT", "OUTCOME_LEADS", "OUTCOME_SALES", "OUTCOME_TRAFFIC", "PAGE_LIKES", "POST_ENGAGEMENT", "PRODUCT_CATALOG_SALES", "REACH", "STORE_VISITS", "VIDEO_VIEWS"},
				},
				"promoted_object": map[string]any{
					"type":        "object",
					"description": "promoted_object parameter",
				},
				"q": map[string]any{
					"type":        "string",
					"description": "q parameter",
					"required":    true,
				},
				"regulated_categories": map[string]any{
					"type":        "array",
					"description": "regulated_categories parameter",
					"enum":        []string{"CREDIT", "EMPLOYMENT", "FINANCIAL_PRODUCTS_SERVICES", "HOUSING", "ISSUES_ELECTIONS_POLITICS", "NONE", "ONLINE_GAMBLING_AND_GAMING"},
					"items":       map[string]any{"type": "string"},
				},
				"regulated_countries": map[string]any{
					"type":        "array",
					"description": "regulated_countries parameter",
					"enum":        []string{"AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "XK", "YE", "YT", "ZA", "ZM", "ZW"},
					"items":       map[string]any{"type": "string"},
				},
				"session_id": map[string]any{
					"type":        "integer",
					"description": "session_id parameter",
				},
				"targeting_list": map[string]any{
					"type":        "array",
					"description": "targeting_list parameter",
					"items":       map[string]any{"type": "object"},
				},
				"whitelisted_types": map[string]any{
					"type":        "array",
					"description": "whitelisted_types parameter",
					"enum":        []string{"adgroup_id", "age_max", "age_min", "age_range", "alternate_auto_targeting_option", "app_install_state", "audience_network_positions", "behaviors", "brand_safety_content_filter_levels", "brand_safety_content_severity_levels", "cafe_ca_contraction_targeting_signal", "cafe_ca_expansion_targeting_signal", "catalog_based_targeting", "cities", "city_keys", "college_years", "conjunctive_user_adclusters", "connections", "contextual_targeting_categories", "countries", "country", "country_groups", "custom_audiences", "device_platforms", "direct_install_devices", "dynamic_audience_ids", "education_majors", "education_schools", "education_statuses", "effective_audience_network_positions", "effective_device_platforms", "effective_facebook_positions", "effective_instagram_positions", "effective_messenger_positions", "effective_oculus_positions", "effective_publisher_platforms", "effective_threads_positions", "effective_whatsapp_positions", "engagement_specs", "ethnic_affinity", "exclude_previous_days", "exclude_reached_since", "excluded_brand_safety_content_types", "excluded_connections", "excluded_custom_audiences", "excluded_dynamic_audience_ids", "excluded_engagement_specs", "excluded_geo_locations", "excluded_mobile_device_model", "excluded_product_audience_specs", "excluded_publisher_categories", "excluded_publisher_list_ids", "excluded_user_adclusters", "excluded_user_device", "exclusions", "expanded_implicit_custom_audiences", "facebook_positions", "family_statuses", "fb_deal_id", "flexible_spec", "follow_profiles", "follow_profiles_negative", "format", "friends_of_connections", "gatekeepers", "genders", "generation", "geo_locations", "home_ownership", "home_type", "home_value", "household_composition", "household_income", "id", "income", "industries", "instagram_hashtags", "instagram_positions", "install_state_application", "instream_video_skippable_excluded", "instream_video_sponsorship_placements", "interest_defaults_source", "interested_in", "interests", "is_instagram_destination_ad", "is_whatsapp_destination_ad", "keywords", "life_events", "locales", "location_categories", "location_cluster_ids", "location_expansion", "marketing_message_channels", "marketplace_product_categories", "messenger_positions", "mobile_device_model", "moms", "net_worth", "oculus_positions", "office_type", "page_types", "place_page_set_ids", "political_views", "politics", "product_audience_specs", "prospecting_audience", "publisher_platforms", "radius", "region_keys", "regions", "relationship_statuses", "rtb_flag", "site_category", "subscriber_universe", "tafe_ca_mitigation_strategy", "targeting_automation", "targeting_optimization", "targeting_relaxation_types", "threads_positions", "timezones", "topic", "trending", "user_adclusters", "user_age_unknown", "user_device", "user_event", "user_os", "user_page_threads", "user_page_threads_excluded", "whatsapp_positions", "wireless_carrier", "work_employers", "work_positions", "zips"},
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: allow_only_fat_head_interests (boolean), app_store (enum) [amazon_app_store, apk_mirror, apk_monk, apk_pure, aptoide_a1_store, ...], countries (array<string>), is_account_level_brand_safety_exclusion (boolean), is_account_level_employer_exclusion (boolean), is_exclusion (boolean), limit_type (enum) [adgroup_id, age_max, age_min, age_range, alternate_auto_targeting_option, ...], objective (enum) [APP_INSTALLS, BRAND_AWARENESS, CONVERSIONS, EVENT_RESPONSES, LEAD_GENERATION, ...], promoted_object (object), q (string) [required], regulated_categories (array<enum>) [CREDIT, EMPLOYMENT, FINANCIAL_PRODUCTS_SERVICES, HOUSING, ISSUES_ELECTIONS_POLITICS, ...], regulated_countries (array<enum>) [AD, AE, AF, AG, AI, ...], session_id (integer), targeting_list (array<object>), whitelisted_types (array<enum>) [adgroup_id, age_max, age_min, age_range, alternate_auto_targeting_option, ...]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountTargetingUnified objects. Available fields: audience_size_lower_bound, audience_size_upper_bound, conversion_lift, description, id, img, info, info_title, is_recommendation, key, link, name, parent, partner, path (and 8 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_targetingsearchTool)

	// adaccount_get_targetingsentencelines tool
	// Available fields for TargetingSentenceLine: id, params, targetingsentencelines
	// Params object accepts: discard_ages (bool), discard_placements (bool), hide_targeting_spec_from_return (bool), targeting_spec (Targeting)
	adaccount_get_targetingsentencelinesTool := mcp.NewTool("adaccount_get_targetingsentencelines",
		mcp.WithDescription("GET targetingsentencelines for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"discard_ages": map[string]any{
					"type":        "boolean",
					"description": "discard_ages parameter",
				},
				"discard_placements": map[string]any{
					"type":        "boolean",
					"description": "discard_placements parameter",
				},
				"hide_targeting_spec_from_return": map[string]any{
					"type":        "boolean",
					"description": "hide_targeting_spec_from_return parameter",
				},
				"targeting_spec": map[string]any{
					"type":        "string",
					"description": "targeting_spec parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: discard_ages (boolean), discard_placements (boolean), hide_targeting_spec_from_return (boolean), targeting_spec (Targeting) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for TargetingSentenceLine objects. Available fields: id, params, targetingsentencelines"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_targetingsentencelinesTool)

	// adaccount_get_targetingsuggestions tool
	// Available fields for AdAccountTargetingUnified: audience_size_lower_bound, audience_size_upper_bound, conversion_lift, description, id, img, info, info_title, is_recommendation, key, link, name, parent, partner, path, performance_rating, raw_name, recommendation_model, search_interest_id, source, spend, type, valid
	// Params object accepts: app_store (adaccounttargetingsuggestions_app_store_enum_param), countries (list<string>), limit_type (adaccounttargetingsuggestions_limit_type_enum_param), mode (adaccounttargetingsuggestions_mode_enum_param), objective (adaccounttargetingsuggestions_objective_enum_param), objects (Object), regulated_categories (list<adaccounttargetingsuggestions_regulated_categories_enum_param>), regulated_countries (list<adaccounttargetingsuggestions_regulated_countries_enum_param>), session_id (unsigned int), targeting_list (list<Object>), whitelisted_types (list<adaccounttargetingsuggestions_whitelisted_types_enum_param>)
	adaccount_get_targetingsuggestionsTool := mcp.NewTool("adaccount_get_targetingsuggestions",
		mcp.WithDescription("GET targetingsuggestions for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"app_store": map[string]any{
					"type":        "string",
					"description": "app_store parameter",
					"enum":        []string{"amazon_app_store", "apk_mirror", "apk_monk", "apk_pure", "aptoide_a1_store", "bemobi_mobile_store", "digital_turbine_store", "does_not_exist", "fb_android_store", "fb_canvas", "fb_gameroom", "galaxy_store", "google_play", "instant_game", "itunes", "itunes_ipad", "neon_android_store", "none", "oculus_app_store", "oppo", "roku_channel_store", "uptodown", "vivo", "windows_10_store", "windows_store", "xiaomi"},
				},
				"countries": map[string]any{
					"type":        "array",
					"description": "countries parameter",
					"items":       map[string]any{"type": "string"},
				},
				"limit_type": map[string]any{
					"type":        "string",
					"description": "limit_type parameter",
					"enum":        []string{"behaviors", "college_years", "education_majors", "education_schools", "education_statuses", "family_statuses", "home_value", "income", "industries", "interested_in", "interests", "life_events", "location_categories", "relationship_statuses", "user_adclusters", "work_employers", "work_positions"},
				},
				"mode": map[string]any{
					"type":        "string",
					"description": "mode parameter",
					"enum":        []string{"best_performing", "recently_used", "related", "suggestions"},
				},
				"objective": map[string]any{
					"type":        "string",
					"description": "objective parameter",
					"enum":        []string{"APP_INSTALLS", "BRAND_AWARENESS", "CONVERSIONS", "EVENT_RESPONSES", "LEAD_GENERATION", "LINK_CLICKS", "LOCAL_AWARENESS", "MESSAGES", "OFFER_CLAIMS", "OUTCOME_APP_PROMOTION", "OUTCOME_AWARENESS", "OUTCOME_ENGAGEMENT", "OUTCOME_LEADS", "OUTCOME_SALES", "OUTCOME_TRAFFIC", "PAGE_LIKES", "POST_ENGAGEMENT", "PRODUCT_CATALOG_SALES", "REACH", "STORE_VISITS", "VIDEO_VIEWS"},
				},
				"objects": map[string]any{
					"type":        "object",
					"description": "objects parameter",
				},
				"regulated_categories": map[string]any{
					"type":        "array",
					"description": "regulated_categories parameter",
					"enum":        []string{"CREDIT", "EMPLOYMENT", "FINANCIAL_PRODUCTS_SERVICES", "HOUSING", "ISSUES_ELECTIONS_POLITICS", "NONE", "ONLINE_GAMBLING_AND_GAMING"},
					"items":       map[string]any{"type": "string"},
				},
				"regulated_countries": map[string]any{
					"type":        "array",
					"description": "regulated_countries parameter",
					"enum":        []string{"AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "XK", "YE", "YT", "ZA", "ZM", "ZW"},
					"items":       map[string]any{"type": "string"},
				},
				"session_id": map[string]any{
					"type":        "integer",
					"description": "session_id parameter",
				},
				"targeting_list": map[string]any{
					"type":        "array",
					"description": "targeting_list parameter",
					"items":       map[string]any{"type": "object"},
				},
				"whitelisted_types": map[string]any{
					"type":        "array",
					"description": "whitelisted_types parameter",
					"enum":        []string{"behaviors", "college_years", "education_majors", "education_schools", "education_statuses", "family_statuses", "home_value", "income", "industries", "interested_in", "interests", "life_events", "location_categories", "relationship_statuses", "user_adclusters", "work_employers", "work_positions"},
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: app_store (enum) [amazon_app_store, apk_mirror, apk_monk, apk_pure, aptoide_a1_store, ...], countries (array<string>), limit_type (enum) [behaviors, college_years, education_majors, education_schools, education_statuses, ...], mode (enum) [best_performing, recently_used, related, suggestions], objective (enum) [APP_INSTALLS, BRAND_AWARENESS, CONVERSIONS, EVENT_RESPONSES, LEAD_GENERATION, ...], objects (object), regulated_categories (array<enum>) [CREDIT, EMPLOYMENT, FINANCIAL_PRODUCTS_SERVICES, HOUSING, ISSUES_ELECTIONS_POLITICS, ...], regulated_countries (array<enum>) [AD, AE, AF, AG, AI, ...], session_id (integer), targeting_list (array<object>), whitelisted_types (array<enum>) [behaviors, college_years, education_majors, education_schools, education_statuses, ...]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountTargetingUnified objects. Available fields: audience_size_lower_bound, audience_size_upper_bound, conversion_lift, description, id, img, info, info_title, is_recommendation, key, link, name, parent, partner, path (and 8 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_targetingsuggestionsTool)

	// adaccount_get_targetingvalidation tool
	// Available fields for AdAccountTargetingUnified: audience_size_lower_bound, audience_size_upper_bound, conversion_lift, description, id, img, info, info_title, is_recommendation, key, link, name, parent, partner, path, performance_rating, raw_name, recommendation_model, search_interest_id, source, spend, type, valid
	// Params object accepts: id_list (list<unsigned int>), is_exclusion (bool), name_list (list<string>), targeting_list (list<Object>)
	adaccount_get_targetingvalidationTool := mcp.NewTool("adaccount_get_targetingvalidation",
		mcp.WithDescription("GET targetingvalidation for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"id_list": map[string]any{
					"type":        "array",
					"description": "id_list parameter",
					"items":       map[string]any{"type": "integer"},
				},
				"is_exclusion": map[string]any{
					"type":        "boolean",
					"description": "is_exclusion parameter",
				},
				"name_list": map[string]any{
					"type":        "array",
					"description": "name_list parameter",
					"items":       map[string]any{"type": "string"},
				},
				"targeting_list": map[string]any{
					"type":        "array",
					"description": "targeting_list parameter",
					"items":       map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: id_list (array<integer>), is_exclusion (boolean), name_list (array<string>), targeting_list (array<object>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountTargetingUnified objects. Available fields: audience_size_lower_bound, audience_size_upper_bound, conversion_lift, description, id, img, info, info_title, is_recommendation, key, link, name, parent, partner, path (and 8 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_targetingvalidationTool)

	// adaccount_get_tracking tool
	// Available fields for AdAccountTrackingData: tracking_specs
	adaccount_get_trackingTool := mcp.NewTool("adaccount_get_tracking",
		mcp.WithDescription("GET tracking for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountTrackingData objects. Available fields: tracking_specs"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_trackingTool)

	// adaccount_post_tracking tool
	// Params object accepts: tracking_specs (Object)
	adaccount_post_trackingTool := mcp.NewTool("adaccount_post_tracking",
		mcp.WithDescription("POST tracking for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"tracking_specs": map[string]any{
					"type":        "object",
					"description": "tracking_specs parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: tracking_specs (object) [required]"),
		),
	)
	tools = append(tools, adaccount_post_trackingTool)

	// adaccount_get_users tool
	// Available fields for AdAccountUser: id, name, tasks
	adaccount_get_usersTool := mcp.NewTool("adaccount_get_users",
		mcp.WithDescription("GET users for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccountUser objects. Available fields: id, name, tasks"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_usersTool)

	// adaccount_delete_usersofanyaudience tool
	// Params object accepts: namespace (string), payload (Object), session (Object)
	adaccount_delete_usersofanyaudienceTool := mcp.NewTool("adaccount_delete_usersofanyaudience",
		mcp.WithDescription("DELETE usersofanyaudience for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"namespace": map[string]any{
					"type":        "string",
					"description": "namespace parameter",
				},
				"payload": map[string]any{
					"type":        "object",
					"description": "payload parameter",
				},
				"session": map[string]any{
					"type":        "object",
					"description": "session parameter",
				},
			}),
			mcp.Description("Parameters object containing: namespace (string), payload (object), session (object)"),
		),
	)
	tools = append(tools, adaccount_delete_usersofanyaudienceTool)

	// adaccount_get_value_rule_set tool
	// Available fields for AdsValueAdjustmentRuleCollection: id, is_default_setting, name, product_type, status
	// Params object accepts: product_type (adaccountvalue_rule_set_product_type_enum_param), status (adaccountvalue_rule_set_status_enum_param)
	adaccount_get_value_rule_setTool := mcp.NewTool("adaccount_get_value_rule_set",
		mcp.WithDescription("GET value_rule_set for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"product_type": map[string]any{
					"type":        "string",
					"description": "product_type parameter",
					"enum":        []string{"AUDIENCE", "LEADGEN_ADS", "OMNI_CHANNEL"},
				},
				"status": map[string]any{
					"type":        "string",
					"description": "status parameter",
					"enum":        []string{"ACTIVE", "DELETED"},
				},
			}),
			mcp.Description("Parameters object containing: product_type (enum) [AUDIENCE, LEADGEN_ADS, OMNI_CHANNEL], status (enum) [ACTIVE, DELETED]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdsValueAdjustmentRuleCollection objects. Available fields: id, is_default_setting, name, product_type, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_value_rule_setTool)

	// adaccount_post_value_rule_set tool
	// Params object accepts: name (string), product_type (adaccountvalue_rule_set_product_type_enum_param), rules (list<map>)
	adaccount_post_value_rule_setTool := mcp.NewTool("adaccount_post_value_rule_set",
		mcp.WithDescription("POST value_rule_set for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"product_type": map[string]any{
					"type":        "string",
					"description": "product_type parameter",
					"enum":        []string{"AUDIENCE", "LEADGEN_ADS", "OMNI_CHANNEL"},
				},
				"rules": map[string]any{
					"type":        "array",
					"description": "rules parameter",
					"required":    true,
					"items":       map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: name (string) [required], product_type (enum) [AUDIENCE, LEADGEN_ADS, OMNI_CHANNEL], rules (array<object>) [required]"),
		),
	)
	tools = append(tools, adaccount_post_value_rule_setTool)

	// adaccount_get_video_ads tool
	// Available fields for AdVideo: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html, embeddable, event, expiration, format, from, icon, id, is_crosspost_video, is_crossposting_eligible, is_episode, is_instagram_eligible, is_reference_only, length, live_audience_count, live_status, music_video_copyright, permalink_url, picture, place, post_id, post_views, premiere_living_room_status, privacy, published, scheduled_publish_time, source, spherical, status, title, universal_video_id, updated_time, views
	// Params object accepts: since (datetime), until (datetime)
	adaccount_get_video_adsTool := mcp.NewTool("adaccount_get_video_ads",
		mcp.WithDescription("GET video_ads for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"since": map[string]any{
					"type":        "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type":        "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: since (datetime), until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdVideo objects. Available fields: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html (and 32 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_video_adsTool)

	// adaccount_post_video_ads tool
	// Params object accepts: description (string), privacy (string), title (string), upload_phase (adaccountvideo_ads_upload_phase_enum_param), video_id (string), video_state (adaccountvideo_ads_video_state_enum_param)
	adaccount_post_video_adsTool := mcp.NewTool("adaccount_post_video_ads",
		mcp.WithDescription("POST video_ads for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"privacy": map[string]any{
					"type":        "string",
					"description": "privacy parameter",
				},
				"title": map[string]any{
					"type":        "string",
					"description": "title parameter",
				},
				"upload_phase": map[string]any{
					"type":        "string",
					"description": "upload_phase parameter",
					"required":    true,
					"enum":        []string{"FINISH", "START"},
				},
				"video_id": map[string]any{
					"type":        "string",
					"description": "video_id parameter",
				},
				"video_state": map[string]any{
					"type":        "string",
					"description": "video_state parameter",
					"enum":        []string{"DRAFT", "PUBLISHED", "SCHEDULED"},
				},
			}),
			mcp.Description("Parameters object containing: description (string), privacy (string), title (string), upload_phase (enum) [FINISH, START] [required], video_id (string), video_state (enum) [DRAFT, PUBLISHED, SCHEDULED]"),
		),
	)
	tools = append(tools, adaccount_post_video_adsTool)

	// adaccount_get_ tool
	// Available fields for AdAccount: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state, business_street, business_street2, business_zip, can_create_brand_lift_study, capabilities, created_time, currency, custom_audience_info, default_dsa_beneficiary, default_dsa_payor, disable_reason, end_advertiser, end_advertiser_name, existing_customers, expired_funding_source_details, extended_credit_invoice_group, failed_delivery_checks, fb_entity, funding_source, funding_source_details, has_migrated_permissions, has_page_authorized_adaccount, id, io_number, is_attribution_spec_system_default, is_ba_skip_delayed_eligible, is_direct_deals_enabled, is_in_3ds_authorization_enabled_market, is_notifications_enabled, is_personal, is_prepay_account, is_tax_id_required, liable_address, line_numbers, media_agency, min_campaign_group_spend_cap, min_daily_budget, name, offsite_pixels_tos_accepted, owner, owner_business, partner, rf_spec, send_bill_to_address, show_checkout_experience, sold_to_address, spend_cap, tax_id, tax_id_status, tax_id_type, timezone_id, timezone_name, timezone_offset_hours_utc, tos_accepted, user_access_expire_time, user_tasks, user_tos_accepted, viewable_business
	adaccount_get_Tool := mcp.NewTool("adaccount_get_",
		mcp.WithDescription("GET  for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccount objects. Available fields: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state (and 58 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adaccount_get_Tool)

	// adaccount_post_ tool
	// Params object accepts: agency_client_declaration (map), attribution_spec (list<Object>), business_info (map), currency (adaccount_currency), custom_audience_info (map), default_dsa_beneficiary (string), default_dsa_payor (string), end_advertiser (string), existing_customers (list<string>), is_ba_skip_delayed_eligible (bool), is_notifications_enabled (bool), media_agency (string), name (string), partner (string), spend_cap (float), spend_cap_action (string), timezone_id (unsigned int), tos_accepted (map)
	adaccount_post_Tool := mcp.NewTool("adaccount_post_",
		mcp.WithDescription("POST  for AdAccount"),
		mcp.WithString("account_id",
			mcp.Required(),
			mcp.Description("Facebook Ad Account ID (without 'act_' prefix)"),
		),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"agency_client_declaration": map[string]any{
					"type":        "object",
					"description": "agency_client_declaration parameter",
				},
				"attribution_spec": map[string]any{
					"type":        "array",
					"description": "attribution_spec parameter",
					"items":       map[string]any{"type": "object"},
				},
				"business_info": map[string]any{
					"type":        "object",
					"description": "business_info parameter",
				},
				"currency": map[string]any{
					"type":        "string",
					"description": "currency parameter",
					"enum":        []string{"AED", "ARS", "AUD", "BDT", "BOB", "BRL", "CAD", "CHF", "CLP", "CNY", "COP", "CRC", "CZK", "DKK", "DZD", "EGP", "EUR", "GBP", "GTQ", "HKD", "HNL", "HUF", "IDR", "ILS", "INR", "ISK", "JPY", "KES", "KRW", "LKR", "MOP", "MXN", "MYR", "NGN", "NIO", "NOK", "NZD", "PEN", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "SAR", "SEK", "SGD", "THB", "TRY", "TWD", "UAH", "USD", "UYU", "VND", "ZAR"},
				},
				"custom_audience_info": map[string]any{
					"type":        "object",
					"description": "custom_audience_info parameter",
				},
				"default_dsa_beneficiary": map[string]any{
					"type":        "string",
					"description": "default_dsa_beneficiary parameter",
				},
				"default_dsa_payor": map[string]any{
					"type":        "string",
					"description": "default_dsa_payor parameter",
				},
				"end_advertiser": map[string]any{
					"type":        "string",
					"description": "end_advertiser parameter",
				},
				"existing_customers": map[string]any{
					"type":        "array",
					"description": "existing_customers parameter",
					"items":       map[string]any{"type": "string"},
				},
				"is_ba_skip_delayed_eligible": map[string]any{
					"type":        "boolean",
					"description": "is_ba_skip_delayed_eligible parameter",
				},
				"is_notifications_enabled": map[string]any{
					"type":        "boolean",
					"description": "is_notifications_enabled parameter",
				},
				"media_agency": map[string]any{
					"type":        "string",
					"description": "media_agency parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"partner": map[string]any{
					"type":        "string",
					"description": "partner parameter",
				},
				"spend_cap": map[string]any{
					"type":        "number",
					"description": "spend_cap parameter",
				},
				"spend_cap_action": map[string]any{
					"type":        "string",
					"description": "spend_cap_action parameter",
				},
				"timezone_id": map[string]any{
					"type":        "integer",
					"description": "timezone_id parameter",
				},
				"tos_accepted": map[string]any{
					"type":        "object",
					"description": "tos_accepted parameter",
				},
			}),
			mcp.Description("Parameters object containing: agency_client_declaration (object), attribution_spec (array<object>), business_info (object), currency (adaccount_currency) [AED, ARS, AUD, BDT, BOB, ...], custom_audience_info (object), default_dsa_beneficiary (string), default_dsa_payor (string), end_advertiser (string), existing_customers (array<string>), is_ba_skip_delayed_eligible (boolean), is_notifications_enabled (boolean), media_agency (string), name (string), partner (string), spend_cap (number), spend_cap_action (string), timezone_id (integer), tos_accepted (object)"),
		),
	)
	tools = append(tools, adaccount_post_Tool)

	return tools
}

// AdAccount handlers

// HandleAdaccount_get_account_controls handles the adaccount_get_account_controls tool with context-based auth
func HandleAdaccount_get_account_controls(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_account_controls(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_account_controls: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_account_controls handles the adaccount_post_account_controls tool with context-based auth
func HandleAdaccount_post_account_controls(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_account_controls(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_account_controls: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_activities handles the adaccount_get_activities tool with context-based auth
func HandleAdaccount_get_activities(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_activities(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_activities: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_ad_place_page_sets handles the adaccount_get_ad_place_page_sets tool with context-based auth
func HandleAdaccount_get_ad_place_page_sets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_ad_place_page_sets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_ad_place_page_sets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_ad_place_page_sets handles the adaccount_post_ad_place_page_sets tool with context-based auth
func HandleAdaccount_post_ad_place_page_sets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_ad_place_page_sets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_ad_place_page_sets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_ad_place_page_sets_async handles the adaccount_post_ad_place_page_sets_async tool with context-based auth
func HandleAdaccount_post_ad_place_page_sets_async(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_ad_place_page_sets_async(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_ad_place_page_sets_async: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_ad_saved_keywords handles the adaccount_get_ad_saved_keywords tool with context-based auth
func HandleAdaccount_get_ad_saved_keywords(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_ad_saved_keywords(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_ad_saved_keywords: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_ad_studies handles the adaccount_get_ad_studies tool with context-based auth
func HandleAdaccount_get_ad_studies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_ad_studies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_ad_studies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adcloudplayables handles the adaccount_get_adcloudplayables tool with context-based auth
func HandleAdaccount_get_adcloudplayables(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adcloudplayables(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adcloudplayables: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adcreatives handles the adaccount_get_adcreatives tool with context-based auth
func HandleAdaccount_get_adcreatives(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adcreatives(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adcreatives: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_adcreatives handles the adaccount_post_adcreatives tool with context-based auth
func HandleAdaccount_post_adcreatives(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_post_adcreatives(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_adcreatives: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adcreativesbylabels handles the adaccount_get_adcreativesbylabels tool with context-based auth
func HandleAdaccount_get_adcreativesbylabels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adcreativesbylabels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adcreativesbylabels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_delete_adimages handles the adaccount_delete_adimages tool with context-based auth
func HandleAdaccount_delete_adimages(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_delete_adimages(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_delete_adimages: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adimages handles the adaccount_get_adimages tool with context-based auth
func HandleAdaccount_get_adimages(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adimages(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adimages: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_adimages handles the adaccount_post_adimages tool with context-based auth
func HandleAdaccount_post_adimages(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_post_adimages(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_adimages: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adlabels handles the adaccount_get_adlabels tool with context-based auth
func HandleAdaccount_get_adlabels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adlabels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adlabels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_adlabels handles the adaccount_post_adlabels tool with context-based auth
func HandleAdaccount_post_adlabels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_adlabels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_adlabels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adplayables handles the adaccount_get_adplayables tool with context-based auth
func HandleAdaccount_get_adplayables(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adplayables(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adplayables: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_adplayables handles the adaccount_post_adplayables tool with context-based auth
func HandleAdaccount_post_adplayables(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_adplayables(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_adplayables: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adrules_history handles the adaccount_get_adrules_history tool with context-based auth
func HandleAdaccount_get_adrules_history(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adrules_history(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adrules_history: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adrules_library handles the adaccount_get_adrules_library tool with context-based auth
func HandleAdaccount_get_adrules_library(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adrules_library(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adrules_library: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_adrules_library handles the adaccount_post_adrules_library tool with context-based auth
func HandleAdaccount_post_adrules_library(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_adrules_library(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_adrules_library: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_ads handles the adaccount_get_ads tool with context-based auth
func HandleAdaccount_get_ads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_ads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_ads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_ads handles the adaccount_post_ads tool with context-based auth
func HandleAdaccount_post_ads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_ads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_ads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_ads_reporting_mmm_reports handles the adaccount_get_ads_reporting_mmm_reports tool with context-based auth
func HandleAdaccount_get_ads_reporting_mmm_reports(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_ads_reporting_mmm_reports(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_ads_reporting_mmm_reports: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_ads_reporting_mmm_schedulers handles the adaccount_get_ads_reporting_mmm_schedulers tool with context-based auth
func HandleAdaccount_get_ads_reporting_mmm_schedulers(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_ads_reporting_mmm_schedulers(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_ads_reporting_mmm_schedulers: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_ads_volume handles the adaccount_get_ads_volume tool with context-based auth
func HandleAdaccount_get_ads_volume(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_ads_volume(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_ads_volume: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adsbylabels handles the adaccount_get_adsbylabels tool with context-based auth
func HandleAdaccount_get_adsbylabels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adsbylabels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adsbylabels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adsets handles the adaccount_get_adsets tool with context-based auth
func HandleAdaccount_get_adsets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adsets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adsets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_adsets handles the adaccount_post_adsets tool with context-based auth
func HandleAdaccount_post_adsets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_adsets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_adsets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adsetsbylabels handles the adaccount_get_adsetsbylabels tool with context-based auth
func HandleAdaccount_get_adsetsbylabels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adsetsbylabels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adsetsbylabels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_adspixels handles the adaccount_get_adspixels tool with context-based auth
func HandleAdaccount_get_adspixels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_adspixels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_adspixels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_adspixels handles the adaccount_post_adspixels tool with context-based auth
func HandleAdaccount_post_adspixels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_post_adspixels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_adspixels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_advertisable_applications handles the adaccount_get_advertisable_applications tool with context-based auth
func HandleAdaccount_get_advertisable_applications(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_advertisable_applications(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_advertisable_applications: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_delete_advideos handles the adaccount_delete_advideos tool with context-based auth
func HandleAdaccount_delete_advideos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_delete_advideos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_delete_advideos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_advideos handles the adaccount_get_advideos tool with context-based auth
func HandleAdaccount_get_advideos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_advideos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_advideos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_advideos handles the adaccount_post_advideos tool with context-based auth
func HandleAdaccount_post_advideos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_post_advideos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_advideos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_affectedadsets handles the adaccount_get_affectedadsets tool with context-based auth
func HandleAdaccount_get_affectedadsets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_affectedadsets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_affectedadsets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_delete_agencies handles the adaccount_delete_agencies tool with context-based auth
func HandleAdaccount_delete_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_delete_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_delete_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_agencies handles the adaccount_get_agencies tool with context-based auth
func HandleAdaccount_get_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_agencies handles the adaccount_post_agencies tool with context-based auth
func HandleAdaccount_post_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_applications handles the adaccount_get_applications tool with context-based auth
func HandleAdaccount_get_applications(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_applications(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_applications: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_delete_assigned_users handles the adaccount_delete_assigned_users tool with context-based auth
func HandleAdaccount_delete_assigned_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_delete_assigned_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_delete_assigned_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_assigned_users handles the adaccount_get_assigned_users tool with context-based auth
func HandleAdaccount_get_assigned_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_assigned_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_assigned_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_assigned_users handles the adaccount_post_assigned_users tool with context-based auth
func HandleAdaccount_post_assigned_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_assigned_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_assigned_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_async_batch_requests handles the adaccount_post_async_batch_requests tool with context-based auth
func HandleAdaccount_post_async_batch_requests(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_async_batch_requests(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_async_batch_requests: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_async_requests handles the adaccount_get_async_requests tool with context-based auth
func HandleAdaccount_get_async_requests(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_async_requests(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_async_requests: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_asyncadcreatives handles the adaccount_get_asyncadcreatives tool with context-based auth
func HandleAdaccount_get_asyncadcreatives(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_asyncadcreatives(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_asyncadcreatives: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_asyncadcreatives handles the adaccount_post_asyncadcreatives tool with context-based auth
func HandleAdaccount_post_asyncadcreatives(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_asyncadcreatives(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_asyncadcreatives: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_asyncadrequestsets handles the adaccount_get_asyncadrequestsets tool with context-based auth
func HandleAdaccount_get_asyncadrequestsets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_asyncadrequestsets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_asyncadrequestsets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_asyncadrequestsets handles the adaccount_post_asyncadrequestsets tool with context-based auth
func HandleAdaccount_post_asyncadrequestsets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_asyncadrequestsets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_asyncadrequestsets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_audience_funnel handles the adaccount_get_audience_funnel tool with context-based auth
func HandleAdaccount_get_audience_funnel(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_audience_funnel(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_audience_funnel: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_block_list_drafts handles the adaccount_post_block_list_drafts tool with context-based auth
func HandleAdaccount_post_block_list_drafts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_block_list_drafts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_block_list_drafts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_brand_safety_content_filter_levels handles the adaccount_post_brand_safety_content_filter_levels tool with context-based auth
func HandleAdaccount_post_brand_safety_content_filter_levels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_brand_safety_content_filter_levels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_brand_safety_content_filter_levels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_broadtargetingcategories handles the adaccount_get_broadtargetingcategories tool with context-based auth
func HandleAdaccount_get_broadtargetingcategories(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_broadtargetingcategories(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_broadtargetingcategories: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_businessprojects handles the adaccount_get_businessprojects tool with context-based auth
func HandleAdaccount_get_businessprojects(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_businessprojects(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_businessprojects: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_delete_campaigns handles the adaccount_delete_campaigns tool with context-based auth
func HandleAdaccount_delete_campaigns(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_delete_campaigns(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_delete_campaigns: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_campaigns handles the adaccount_get_campaigns tool with context-based auth
func HandleAdaccount_get_campaigns(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_campaigns(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_campaigns: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_campaigns handles the adaccount_post_campaigns tool with context-based auth
func HandleAdaccount_post_campaigns(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_campaigns(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_campaigns: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_campaignsbylabels handles the adaccount_get_campaignsbylabels tool with context-based auth
func HandleAdaccount_get_campaignsbylabels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_campaignsbylabels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_campaignsbylabels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_connected_instagram_accounts handles the adaccount_get_connected_instagram_accounts tool with context-based auth
func HandleAdaccount_get_connected_instagram_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_connected_instagram_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_connected_instagram_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_connected_instagram_accounts_with_iabp handles the adaccount_get_connected_instagram_accounts_with_iabp tool with context-based auth
func HandleAdaccount_get_connected_instagram_accounts_with_iabp(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_connected_instagram_accounts_with_iabp(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_connected_instagram_accounts_with_iabp: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_conversion_goals handles the adaccount_get_conversion_goals tool with context-based auth
func HandleAdaccount_get_conversion_goals(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_conversion_goals(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_conversion_goals: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_customaudiences handles the adaccount_get_customaudiences tool with context-based auth
func HandleAdaccount_get_customaudiences(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_customaudiences(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_customaudiences: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_customaudiences handles the adaccount_post_customaudiences tool with context-based auth
func HandleAdaccount_post_customaudiences(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_post_customaudiences(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_customaudiences: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_customaudiencestos handles the adaccount_get_customaudiencestos tool with context-based auth
func HandleAdaccount_get_customaudiencestos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_customaudiencestos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_customaudiencestos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_customaudiencestos handles the adaccount_post_customaudiencestos tool with context-based auth
func HandleAdaccount_post_customaudiencestos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_customaudiencestos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_customaudiencestos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_customconversions handles the adaccount_get_customconversions tool with context-based auth
func HandleAdaccount_get_customconversions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_customconversions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_customconversions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_customconversions handles the adaccount_post_customconversions tool with context-based auth
func HandleAdaccount_post_customconversions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_customconversions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_customconversions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_delivery_estimate handles the adaccount_get_delivery_estimate tool with context-based auth
func HandleAdaccount_get_delivery_estimate(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_delivery_estimate(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_delivery_estimate: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_deprecatedtargetingadsets handles the adaccount_get_deprecatedtargetingadsets tool with context-based auth
func HandleAdaccount_get_deprecatedtargetingadsets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_deprecatedtargetingadsets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_deprecatedtargetingadsets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_dsa_recommendations handles the adaccount_get_dsa_recommendations tool with context-based auth
func HandleAdaccount_get_dsa_recommendations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_dsa_recommendations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_dsa_recommendations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_generatepreviews handles the adaccount_get_generatepreviews tool with context-based auth
func HandleAdaccount_get_generatepreviews(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_generatepreviews(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_generatepreviews: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_impacting_ad_studies handles the adaccount_get_impacting_ad_studies tool with context-based auth
func HandleAdaccount_get_impacting_ad_studies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_impacting_ad_studies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_impacting_ad_studies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_insights handles the adaccount_get_insights tool with context-based auth
func HandleAdaccount_get_insights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_insights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_insights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_insights handles the adaccount_post_insights tool with context-based auth
func HandleAdaccount_post_insights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_post_insights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_insights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_instagram_accounts handles the adaccount_get_instagram_accounts tool with context-based auth
func HandleAdaccount_get_instagram_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_instagram_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_instagram_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_ios_fourteen_campaign_limits handles the adaccount_get_ios_fourteen_campaign_limits tool with context-based auth
func HandleAdaccount_get_ios_fourteen_campaign_limits(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_ios_fourteen_campaign_limits(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_ios_fourteen_campaign_limits: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_matched_search_applications handles the adaccount_get_matched_search_applications tool with context-based auth
func HandleAdaccount_get_matched_search_applications(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_matched_search_applications(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_matched_search_applications: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_max_bid handles the adaccount_get_max_bid tool with context-based auth
func HandleAdaccount_get_max_bid(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_max_bid(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_max_bid: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_mcmeconversions handles the adaccount_get_mcmeconversions tool with context-based auth
func HandleAdaccount_get_mcmeconversions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_mcmeconversions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_mcmeconversions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_minimum_budgets handles the adaccount_get_minimum_budgets tool with context-based auth
func HandleAdaccount_get_minimum_budgets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_minimum_budgets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_minimum_budgets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_onbehalf_requests handles the adaccount_get_onbehalf_requests tool with context-based auth
func HandleAdaccount_get_onbehalf_requests(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_onbehalf_requests(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_onbehalf_requests: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_product_audiences handles the adaccount_post_product_audiences tool with context-based auth
func HandleAdaccount_post_product_audiences(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_product_audiences(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_product_audiences: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_promote_pages handles the adaccount_get_promote_pages tool with context-based auth
func HandleAdaccount_get_promote_pages(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_promote_pages(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_promote_pages: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_publisher_block_lists handles the adaccount_get_publisher_block_lists tool with context-based auth
func HandleAdaccount_get_publisher_block_lists(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_publisher_block_lists(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_publisher_block_lists: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_publisher_block_lists handles the adaccount_post_publisher_block_lists tool with context-based auth
func HandleAdaccount_post_publisher_block_lists(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_post_publisher_block_lists(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_publisher_block_lists: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_reachestimate handles the adaccount_get_reachestimate tool with context-based auth
func HandleAdaccount_get_reachestimate(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_reachestimate(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_reachestimate: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_reachfrequencypredictions handles the adaccount_get_reachfrequencypredictions tool with context-based auth
func HandleAdaccount_get_reachfrequencypredictions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_reachfrequencypredictions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_reachfrequencypredictions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_reachfrequencypredictions handles the adaccount_post_reachfrequencypredictions tool with context-based auth
func HandleAdaccount_post_reachfrequencypredictions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_post_reachfrequencypredictions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_reachfrequencypredictions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_recommendations handles the adaccount_get_recommendations tool with context-based auth
func HandleAdaccount_get_recommendations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_recommendations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_recommendations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_recommendations handles the adaccount_post_recommendations tool with context-based auth
func HandleAdaccount_post_recommendations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_recommendations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_recommendations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_saved_audiences handles the adaccount_get_saved_audiences tool with context-based auth
func HandleAdaccount_get_saved_audiences(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_saved_audiences(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_saved_audiences: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_delete_subscribed_apps handles the adaccount_delete_subscribed_apps tool with context-based auth
func HandleAdaccount_delete_subscribed_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_delete_subscribed_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_delete_subscribed_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_subscribed_apps handles the adaccount_get_subscribed_apps tool with context-based auth
func HandleAdaccount_get_subscribed_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_subscribed_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_subscribed_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_subscribed_apps handles the adaccount_post_subscribed_apps tool with context-based auth
func HandleAdaccount_post_subscribed_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_post_subscribed_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_subscribed_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_targetingbrowse handles the adaccount_get_targetingbrowse tool with context-based auth
func HandleAdaccount_get_targetingbrowse(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_targetingbrowse(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_targetingbrowse: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_targetingsearch handles the adaccount_get_targetingsearch tool with context-based auth
func HandleAdaccount_get_targetingsearch(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_targetingsearch(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_targetingsearch: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_targetingsentencelines handles the adaccount_get_targetingsentencelines tool with context-based auth
func HandleAdaccount_get_targetingsentencelines(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_targetingsentencelines(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_targetingsentencelines: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_targetingsuggestions handles the adaccount_get_targetingsuggestions tool with context-based auth
func HandleAdaccount_get_targetingsuggestions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_targetingsuggestions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_targetingsuggestions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_targetingvalidation handles the adaccount_get_targetingvalidation tool with context-based auth
func HandleAdaccount_get_targetingvalidation(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_targetingvalidation(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_targetingvalidation: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_tracking handles the adaccount_get_tracking tool with context-based auth
func HandleAdaccount_get_tracking(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_tracking(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_tracking: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_tracking handles the adaccount_post_tracking tool with context-based auth
func HandleAdaccount_post_tracking(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_tracking(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_tracking: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_users handles the adaccount_get_users tool with context-based auth
func HandleAdaccount_get_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_delete_usersofanyaudience handles the adaccount_delete_usersofanyaudience tool with context-based auth
func HandleAdaccount_delete_usersofanyaudience(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_delete_usersofanyaudience(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_delete_usersofanyaudience: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_value_rule_set handles the adaccount_get_value_rule_set tool with context-based auth
func HandleAdaccount_get_value_rule_set(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_value_rule_set(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_value_rule_set: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_value_rule_set handles the adaccount_post_value_rule_set tool with context-based auth
func HandleAdaccount_post_value_rule_set(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_value_rule_set(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_value_rule_set: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_video_ads handles the adaccount_get_video_ads tool with context-based auth
func HandleAdaccount_get_video_ads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_video_ads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_video_ads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_video_ads handles the adaccount_post_video_ads tool with context-based auth
func HandleAdaccount_post_video_ads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adaccount_post_video_ads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_video_ads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_get_ handles the adaccount_get_ tool with context-based auth
func HandleAdaccount_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adaccount_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdaccount_post_ handles the adaccount_post_ tool with context-based auth
func HandleAdaccount_post_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdAccountClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: account_id
	account_id, err := request.RequireString("account_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter account_id: %v", err)), nil
	}
	args["account_id"] = account_id

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adaccount_post_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adaccount_post_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}
