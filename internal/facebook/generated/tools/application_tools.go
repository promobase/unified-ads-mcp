// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetApplicationTools returns MCP tools for Application
func GetApplicationTools() []mcp.Tool {
	var tools []mcp.Tool

	// application_delete_accounts tool
	// Params object accepts: type (applicationaccounts_type_enum_param), uid (int)
	application_delete_accountsTool := mcp.NewTool("application_delete_accounts",
		mcp.WithDescription("DELETE accounts for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"test-users"},
				},
				"uid": map[string]any{
					"type":        "integer",
					"description": "uid parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: type (enum) [test-users], uid (integer) [required]"),
		),
	)
	tools = append(tools, application_delete_accountsTool)

	// application_get_accounts tool
	// Params object accepts: type (applicationaccounts_type_enum_param)
	application_get_accountsTool := mcp.NewTool("application_get_accounts",
		mcp.WithDescription("GET accounts for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"test-users"},
				},
			}),
			mcp.Description("Parameters object containing: type (enum) [test-users]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_accountsTool)

	// application_post_accounts tool
	// Params object accepts: installed (bool), minor (bool), name (string), owner_access_token (string), permissions (list<Permission>), type (applicationaccounts_type_enum_param), uid (int)
	application_post_accountsTool := mcp.NewTool("application_post_accounts",
		mcp.WithDescription("POST accounts for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"installed": map[string]any{
					"type":        "boolean",
					"description": "installed parameter",
				},
				"minor": map[string]any{
					"type":        "boolean",
					"description": "minor parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"owner_access_token": map[string]any{
					"type":        "string",
					"description": "owner_access_token parameter",
				},
				"permissions": map[string]any{
					"type":        "array",
					"description": "permissions parameter",
					"items":       map[string]any{"type": "string"},
				},
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"test-users"},
				},
				"uid": map[string]any{
					"type":        "integer",
					"description": "uid parameter",
				},
			}),
			mcp.Description("Parameters object containing: installed (boolean), minor (boolean), name (string), owner_access_token (string), permissions (array<Permission>), type (enum) [test-users], uid (integer)"),
		),
	)
	tools = append(tools, application_post_accountsTool)

	// application_post_activities tool
	// Params object accepts: advertiser_id (string), advertiser_tracking_enabled (bool), anon_id (string), app_user_id (string), application_tracking_enabled (bool), attribution (string), attribution_referrer (string), attribution_sources (list<map>), auto_publish (bool), bundle_id (string), bundle_short_version (string), bundle_version (string), campaign_ids (string), click_id (string), consider_views (bool), custom_events (list<Object>), custom_events_file (file), data_processing_options (list<string>), data_processing_options_country (unsigned int), data_processing_options_state (unsigned int), device_token (string), event (applicationactivities_event_enum_param), event_id (string), extinfo (Object), google_install_referrer (string), include_dwell_data (bool), include_video_data (bool), install_id (string), install_referrer (string), install_timestamp (unsigned int), installer_package (string), is_fb (bool), limited_data_use (bool), meta_install_referrer (string), migration_bundle (string), operational_parameters (list<map>), page_id (unsigned int), page_scoped_user_id (unsigned int), receipt_data (string), sdk_version (string), ud (map), url_schemes (list<string>), user_id (string), user_id_type (applicationactivities_user_id_type_enum_param), vendor_id (string), windows_attribution_id (string)
	application_post_activitiesTool := mcp.NewTool("application_post_activities",
		mcp.WithDescription("POST activities for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"advertiser_id": map[string]any{
					"type":        "string",
					"description": "advertiser_id parameter",
				},
				"advertiser_tracking_enabled": map[string]any{
					"type":        "boolean",
					"description": "advertiser_tracking_enabled parameter",
				},
				"anon_id": map[string]any{
					"type":        "string",
					"description": "anon_id parameter",
				},
				"app_user_id": map[string]any{
					"type":        "string",
					"description": "app_user_id parameter",
				},
				"application_tracking_enabled": map[string]any{
					"type":        "boolean",
					"description": "application_tracking_enabled parameter",
				},
				"attribution": map[string]any{
					"type":        "string",
					"description": "attribution parameter",
				},
				"attribution_referrer": map[string]any{
					"type":        "string",
					"description": "attribution_referrer parameter",
				},
				"attribution_sources": map[string]any{
					"type":        "array",
					"description": "attribution_sources parameter",
					"items":       map[string]any{"type": "object"},
				},
				"auto_publish": map[string]any{
					"type":        "boolean",
					"description": "auto_publish parameter",
				},
				"bundle_id": map[string]any{
					"type":        "string",
					"description": "bundle_id parameter",
				},
				"bundle_short_version": map[string]any{
					"type":        "string",
					"description": "bundle_short_version parameter",
				},
				"bundle_version": map[string]any{
					"type":        "string",
					"description": "bundle_version parameter",
				},
				"campaign_ids": map[string]any{
					"type":        "string",
					"description": "campaign_ids parameter",
				},
				"click_id": map[string]any{
					"type":        "string",
					"description": "click_id parameter",
				},
				"consider_views": map[string]any{
					"type":        "boolean",
					"description": "consider_views parameter",
				},
				"custom_events": map[string]any{
					"type":        "array",
					"description": "custom_events parameter",
					"items":       map[string]any{"type": "object"},
				},
				"custom_events_file": map[string]any{
					"type":        "string",
					"description": "custom_events_file parameter",
				},
				"data_processing_options": map[string]any{
					"type":        "array",
					"description": "data_processing_options parameter",
					"items":       map[string]any{"type": "string"},
				},
				"data_processing_options_country": map[string]any{
					"type":        "integer",
					"description": "data_processing_options_country parameter",
				},
				"data_processing_options_state": map[string]any{
					"type":        "integer",
					"description": "data_processing_options_state parameter",
				},
				"device_token": map[string]any{
					"type":        "string",
					"description": "device_token parameter",
				},
				"event": map[string]any{
					"type":        "string",
					"description": "event parameter",
					"required":    true,
					"enum":        []string{"CUSTOM_APP_EVENTS", "DEFERRED_APP_LINK", "MOBILE_APP_INSTALL"},
				},
				"event_id": map[string]any{
					"type":        "string",
					"description": "event_id parameter",
				},
				"extinfo": map[string]any{
					"type":        "object",
					"description": "extinfo parameter",
				},
				"google_install_referrer": map[string]any{
					"type":        "string",
					"description": "google_install_referrer parameter",
				},
				"include_dwell_data": map[string]any{
					"type":        "boolean",
					"description": "include_dwell_data parameter",
				},
				"include_video_data": map[string]any{
					"type":        "boolean",
					"description": "include_video_data parameter",
				},
				"install_id": map[string]any{
					"type":        "string",
					"description": "install_id parameter",
				},
				"install_referrer": map[string]any{
					"type":        "string",
					"description": "install_referrer parameter",
				},
				"install_timestamp": map[string]any{
					"type":        "integer",
					"description": "install_timestamp parameter",
				},
				"installer_package": map[string]any{
					"type":        "string",
					"description": "installer_package parameter",
				},
				"is_fb": map[string]any{
					"type":        "boolean",
					"description": "is_fb parameter",
				},
				"limited_data_use": map[string]any{
					"type":        "boolean",
					"description": "limited_data_use parameter",
				},
				"meta_install_referrer": map[string]any{
					"type":        "string",
					"description": "meta_install_referrer parameter",
				},
				"migration_bundle": map[string]any{
					"type":        "string",
					"description": "migration_bundle parameter",
				},
				"operational_parameters": map[string]any{
					"type":        "array",
					"description": "operational_parameters parameter",
					"items":       map[string]any{"type": "object"},
				},
				"page_id": map[string]any{
					"type":        "integer",
					"description": "page_id parameter",
				},
				"page_scoped_user_id": map[string]any{
					"type":        "integer",
					"description": "page_scoped_user_id parameter",
				},
				"receipt_data": map[string]any{
					"type":        "string",
					"description": "receipt_data parameter",
				},
				"sdk_version": map[string]any{
					"type":        "string",
					"description": "sdk_version parameter",
				},
				"ud": map[string]any{
					"type":        "object",
					"description": "ud parameter",
				},
				"url_schemes": map[string]any{
					"type":        "array",
					"description": "url_schemes parameter",
					"items":       map[string]any{"type": "string"},
				},
				"user_id": map[string]any{
					"type":        "string",
					"description": "user_id parameter",
				},
				"user_id_type": map[string]any{
					"type":        "string",
					"description": "user_id_type parameter",
					"enum":        []string{"INSTANT_GAMES_PLAYER_ID"},
				},
				"vendor_id": map[string]any{
					"type":        "string",
					"description": "vendor_id parameter",
				},
				"windows_attribution_id": map[string]any{
					"type":        "string",
					"description": "windows_attribution_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: advertiser_id (string), advertiser_tracking_enabled (boolean), anon_id (string), app_user_id (string), application_tracking_enabled (boolean), attribution (string), attribution_referrer (string), attribution_sources (array<object>), auto_publish (boolean), bundle_id (string), bundle_short_version (string), bundle_version (string), campaign_ids (string), click_id (string), consider_views (boolean), custom_events (array<object>), custom_events_file (file), data_processing_options (array<string>), data_processing_options_country (integer), data_processing_options_state (integer), device_token (string), event (enum) [CUSTOM_APP_EVENTS, DEFERRED_APP_LINK, MOBILE_APP_INSTALL] [required], event_id (string), extinfo (object), google_install_referrer (string), include_dwell_data (boolean), include_video_data (boolean), install_id (string), install_referrer (string), install_timestamp (integer), installer_package (string), is_fb (boolean), limited_data_use (boolean), meta_install_referrer (string), migration_bundle (string), operational_parameters (array<object>), page_id (integer), page_scoped_user_id (integer), receipt_data (string), sdk_version (string), ud (object), url_schemes (array<string>), user_id (string), user_id_type (enum) [INSTANT_GAMES_PLAYER_ID], vendor_id (string), windows_attribution_id (string)"),
		),
	)
	tools = append(tools, application_post_activitiesTool)

	// application_get_ad_placement_groups tool
	application_get_ad_placement_groupsTool := mcp.NewTool("application_get_ad_placement_groups",
		mcp.WithDescription("GET ad_placement_groups for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_ad_placement_groupsTool)

	// application_get_adnetwork_placements tool
	// Available fields for AdPlacement: bundle_id, display_format, external_placement_id, google_display_format, id, name, placement_group, platform, status
	// Params object accepts: request_id (string)
	application_get_adnetwork_placementsTool := mcp.NewTool("application_get_adnetwork_placements",
		mcp.WithDescription("GET adnetwork_placements for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"request_id": map[string]any{
					"type":        "string",
					"description": "request_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: request_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdPlacement objects. Available fields: bundle_id, display_format, external_placement_id, google_display_format, id, name, placement_group, platform, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_adnetwork_placementsTool)

	// application_get_adnetworkanalytics tool
	// Available fields for AdNetworkAnalyticsSyncQueryResult: omitted_results, query_id, results
	// Params object accepts: aggregation_period (applicationadnetworkanalytics_aggregation_period_enum_param), breakdowns (list<applicationadnetworkanalytics_breakdowns_enum_param>), filters (list<map>), limit (unsigned int), metrics (list<applicationadnetworkanalytics_metrics_enum_param>), ordering_column (applicationadnetworkanalytics_ordering_column_enum_param), ordering_type (applicationadnetworkanalytics_ordering_type_enum_param), should_include_until (bool), since (datetime), until (datetime)
	application_get_adnetworkanalyticsTool := mcp.NewTool("application_get_adnetworkanalytics",
		mcp.WithDescription("GET adnetworkanalytics for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"aggregation_period": map[string]any{
					"type":        "string",
					"description": "aggregation_period parameter",
					"enum":        []string{"DAY", "TOTAL"},
				},
				"breakdowns": map[string]any{
					"type":        "array",
					"description": "breakdowns parameter",
					"enum":        []string{"AD_SERVER_CAMPAIGN_ID", "AD_SPACE", "AGE", "APP", "CLICKED_VIEW_TAG", "COUNTRY", "DEAL", "DEAL_AD", "DEAL_PAGE", "DELIVERY_METHOD", "DISPLAY_FORMAT", "FAIL_REASON", "GENDER", "INSTANT_ARTICLE_ID", "INSTANT_ARTICLE_PAGE_ID", "IS_DEAL_BACKFILL", "PLACEMENT", "PLACEMENT_NAME", "PLATFORM", "PROPERTY", "SDK_VERSION"},
					"items":       map[string]any{"type": "string"},
				},
				"filters": map[string]any{
					"type":        "array",
					"description": "filters parameter",
					"items":       map[string]any{"type": "object"},
				},
				"limit": map[string]any{
					"type":        "integer",
					"description": "limit parameter",
				},
				"metrics": map[string]any{
					"type":        "array",
					"description": "metrics parameter",
					"required":    true,
					"enum":        []string{"FB_AD_NETWORK_BIDDING_BID_RATE", "FB_AD_NETWORK_BIDDING_REQUEST", "FB_AD_NETWORK_BIDDING_RESPONSE", "FB_AD_NETWORK_BIDDING_REVENUE", "FB_AD_NETWORK_BIDDING_WIN_RATE", "FB_AD_NETWORK_CLICK", "FB_AD_NETWORK_CPM", "FB_AD_NETWORK_CTR", "FB_AD_NETWORK_FILLED_REQUEST", "FB_AD_NETWORK_FILL_RATE", "FB_AD_NETWORK_IMP", "FB_AD_NETWORK_IMPRESSION_RATE", "FB_AD_NETWORK_REQUEST", "FB_AD_NETWORK_REVENUE", "FB_AD_NETWORK_SHOW_RATE", "FB_AD_NETWORK_VIDEO_GUARANTEE_REVENUE", "FB_AD_NETWORK_VIDEO_MRC", "FB_AD_NETWORK_VIDEO_MRC_RATE", "FB_AD_NETWORK_VIDEO_VIEW", "FB_AD_NETWORK_VIDEO_VIEW_RATE"},
					"items":       map[string]any{"type": "string"},
				},
				"ordering_column": map[string]any{
					"type":        "string",
					"description": "ordering_column parameter",
					"enum":        []string{"METRIC", "TIME", "VALUE"},
				},
				"ordering_type": map[string]any{
					"type":        "string",
					"description": "ordering_type parameter",
					"enum":        []string{"ASCENDING", "DESCENDING"},
				},
				"should_include_until": map[string]any{
					"type":        "boolean",
					"description": "should_include_until parameter",
				},
				"since": map[string]any{
					"type":        "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type":        "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: aggregation_period (enum) [DAY, TOTAL], breakdowns (array<enum>) [AD_SERVER_CAMPAIGN_ID, AD_SPACE, AGE, APP, CLICKED_VIEW_TAG, ...], filters (array<object>), limit (integer), metrics (array<enum>) [FB_AD_NETWORK_BIDDING_BID_RATE, FB_AD_NETWORK_BIDDING_REQUEST, FB_AD_NETWORK_BIDDING_RESPONSE, FB_AD_NETWORK_BIDDING_REVENUE, FB_AD_NETWORK_BIDDING_WIN_RATE, ...] [required], ordering_column (enum) [METRIC, TIME, VALUE], ordering_type (enum) [ASCENDING, DESCENDING], should_include_until (boolean), since (datetime), until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdNetworkAnalyticsSyncQueryResult objects. Available fields: omitted_results, query_id, results"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_adnetworkanalyticsTool)

	// application_post_adnetworkanalytics tool
	// Params object accepts: aggregation_period (applicationadnetworkanalytics_aggregation_period_enum_param), breakdowns (list<applicationadnetworkanalytics_breakdowns_enum_param>), filters (list<Object>), limit (int), metrics (list<applicationadnetworkanalytics_metrics_enum_param>), ordering_column (applicationadnetworkanalytics_ordering_column_enum_param), ordering_type (applicationadnetworkanalytics_ordering_type_enum_param), since (datetime), until (datetime)
	application_post_adnetworkanalyticsTool := mcp.NewTool("application_post_adnetworkanalytics",
		mcp.WithDescription("POST adnetworkanalytics for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"aggregation_period": map[string]any{
					"type":        "string",
					"description": "aggregation_period parameter",
					"enum":        []string{"DAY", "TOTAL"},
				},
				"breakdowns": map[string]any{
					"type":        "array",
					"description": "breakdowns parameter",
					"enum":        []string{"AD_SERVER_CAMPAIGN_ID", "AD_SPACE", "AGE", "APP", "CLICKED_VIEW_TAG", "COUNTRY", "DEAL", "DEAL_AD", "DEAL_PAGE", "DELIVERY_METHOD", "DISPLAY_FORMAT", "FAIL_REASON", "GENDER", "INSTANT_ARTICLE_ID", "INSTANT_ARTICLE_PAGE_ID", "IS_DEAL_BACKFILL", "PLACEMENT", "PLACEMENT_NAME", "PLATFORM", "PROPERTY", "SDK_VERSION"},
					"items":       map[string]any{"type": "string"},
				},
				"filters": map[string]any{
					"type":        "array",
					"description": "filters parameter",
					"items":       map[string]any{"type": "object"},
				},
				"limit": map[string]any{
					"type":        "integer",
					"description": "limit parameter",
				},
				"metrics": map[string]any{
					"type":        "array",
					"description": "metrics parameter",
					"required":    true,
					"enum":        []string{"FB_AD_NETWORK_BIDDING_BID_RATE", "FB_AD_NETWORK_BIDDING_REQUEST", "FB_AD_NETWORK_BIDDING_RESPONSE", "FB_AD_NETWORK_BIDDING_REVENUE", "FB_AD_NETWORK_BIDDING_WIN_RATE", "FB_AD_NETWORK_CLICK", "FB_AD_NETWORK_CPM", "FB_AD_NETWORK_CTR", "FB_AD_NETWORK_FILLED_REQUEST", "FB_AD_NETWORK_FILL_RATE", "FB_AD_NETWORK_IMP", "FB_AD_NETWORK_IMPRESSION_RATE", "FB_AD_NETWORK_REQUEST", "FB_AD_NETWORK_REVENUE", "FB_AD_NETWORK_SHOW_RATE", "FB_AD_NETWORK_VIDEO_GUARANTEE_REVENUE", "FB_AD_NETWORK_VIDEO_MRC", "FB_AD_NETWORK_VIDEO_MRC_RATE", "FB_AD_NETWORK_VIDEO_VIEW", "FB_AD_NETWORK_VIDEO_VIEW_RATE"},
					"items":       map[string]any{"type": "string"},
				},
				"ordering_column": map[string]any{
					"type":        "string",
					"description": "ordering_column parameter",
					"enum":        []string{"METRIC", "TIME", "VALUE"},
				},
				"ordering_type": map[string]any{
					"type":        "string",
					"description": "ordering_type parameter",
					"enum":        []string{"ASCENDING", "DESCENDING"},
				},
				"since": map[string]any{
					"type":        "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type":        "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: aggregation_period (enum) [DAY, TOTAL], breakdowns (array<enum>) [AD_SERVER_CAMPAIGN_ID, AD_SPACE, AGE, APP, CLICKED_VIEW_TAG, ...], filters (array<object>), limit (integer), metrics (array<enum>) [FB_AD_NETWORK_BIDDING_BID_RATE, FB_AD_NETWORK_BIDDING_REQUEST, FB_AD_NETWORK_BIDDING_RESPONSE, FB_AD_NETWORK_BIDDING_REVENUE, FB_AD_NETWORK_BIDDING_WIN_RATE, ...] [required], ordering_column (enum) [METRIC, TIME, VALUE], ordering_type (enum) [ASCENDING, DESCENDING], since (datetime), until (datetime)"),
		),
	)
	tools = append(tools, application_post_adnetworkanalyticsTool)

	// application_get_adnetworkanalytics_results tool
	// Available fields for AdNetworkAnalyticsAsyncQueryResult: data, omitted_results, query_id, results, status
	// Params object accepts: query_ids (list<string>)
	application_get_adnetworkanalytics_resultsTool := mcp.NewTool("application_get_adnetworkanalytics_results",
		mcp.WithDescription("GET adnetworkanalytics_results for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"query_ids": map[string]any{
					"type":        "array",
					"description": "query_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: query_ids (array<string>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdNetworkAnalyticsAsyncQueryResult objects. Available fields: data, omitted_results, query_id, results, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_adnetworkanalytics_resultsTool)

	// application_get_aem_attribution tool
	// Params object accepts: advertiser_ids (list<string>), fb_content_data (string)
	application_get_aem_attributionTool := mcp.NewTool("application_get_aem_attribution",
		mcp.WithDescription("GET aem_attribution for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"advertiser_ids": map[string]any{
					"type":        "array",
					"description": "advertiser_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"fb_content_data": map[string]any{
					"type":        "string",
					"description": "fb_content_data parameter",
				},
			}),
			mcp.Description("Parameters object containing: advertiser_ids (array<string>), fb_content_data (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_aem_attributionTool)

	// application_get_aem_conversion_configs tool
	// Params object accepts: advertiser_ids (list<string>)
	application_get_aem_conversion_configsTool := mcp.NewTool("application_get_aem_conversion_configs",
		mcp.WithDescription("GET aem_conversion_configs for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"advertiser_ids": map[string]any{
					"type":        "array",
					"description": "advertiser_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: advertiser_ids (array<string>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_aem_conversion_configsTool)

	// application_get_aem_conversion_filter tool
	// Params object accepts: catalog_id (string), fb_content_ids (string)
	application_get_aem_conversion_filterTool := mcp.NewTool("application_get_aem_conversion_filter",
		mcp.WithDescription("GET aem_conversion_filter for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"catalog_id": map[string]any{
					"type":        "string",
					"description": "catalog_id parameter",
				},
				"fb_content_ids": map[string]any{
					"type":        "string",
					"description": "fb_content_ids parameter",
				},
			}),
			mcp.Description("Parameters object containing: catalog_id (string), fb_content_ids (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_aem_conversion_filterTool)

	// application_post_aem_conversions tool
	// Params object accepts: aem_conversions (list<map>)
	application_post_aem_conversionsTool := mcp.NewTool("application_post_aem_conversions",
		mcp.WithDescription("POST aem_conversions for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"aem_conversions": map[string]any{
					"type":        "array",
					"description": "aem_conversions parameter",
					"required":    true,
					"items":       map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: aem_conversions (array<object>) [required]"),
		),
	)
	tools = append(tools, application_post_aem_conversionsTool)

	// application_post_aem_skan_readiness tool
	// Params object accepts: app_id (int), is_aem_ready (bool), is_app_aem_install_ready (bool), is_app_aem_ready (bool), is_skan_ready (bool), message (string)
	application_post_aem_skan_readinessTool := mcp.NewTool("application_post_aem_skan_readiness",
		mcp.WithDescription("POST aem_skan_readiness for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"app_id": map[string]any{
					"type":        "integer",
					"description": "app_id parameter",
					"required":    true,
				},
				"is_aem_ready": map[string]any{
					"type":        "boolean",
					"description": "is_aem_ready parameter",
				},
				"is_app_aem_install_ready": map[string]any{
					"type":        "boolean",
					"description": "is_app_aem_install_ready parameter",
				},
				"is_app_aem_ready": map[string]any{
					"type":        "boolean",
					"description": "is_app_aem_ready parameter",
				},
				"is_skan_ready": map[string]any{
					"type":        "boolean",
					"description": "is_skan_ready parameter",
				},
				"message": map[string]any{
					"type":        "string",
					"description": "message parameter",
				},
			}),
			mcp.Description("Parameters object containing: app_id (integer) [required], is_aem_ready (boolean), is_app_aem_install_ready (boolean), is_app_aem_ready (boolean), is_skan_ready (boolean), message (string)"),
		),
	)
	tools = append(tools, application_post_aem_skan_readinessTool)

	// application_get_agencies tool
	// Available fields for Business: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id, two_factor_type, updated_by, updated_time, user_access_expire_time, verification_status, vertical, vertical_id
	application_get_agenciesTool := mcp.NewTool("application_get_agencies",
		mcp.WithDescription("GET agencies for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Business objects. Available fields: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id (and 7 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_agenciesTool)

	// application_post_aggregate_revenue tool
	// Params object accepts: ecpms (list<string>), query_ids (list<string>), request_id (string), sync_api (bool)
	application_post_aggregate_revenueTool := mcp.NewTool("application_post_aggregate_revenue",
		mcp.WithDescription("POST aggregate_revenue for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"ecpms": map[string]any{
					"type":        "array",
					"description": "ecpms parameter",
					"items":       map[string]any{"type": "string"},
				},
				"query_ids": map[string]any{
					"type":        "array",
					"description": "query_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"request_id": map[string]any{
					"type":        "string",
					"description": "request_id parameter",
				},
				"sync_api": map[string]any{
					"type":        "boolean",
					"description": "sync_api parameter",
				},
			}),
			mcp.Description("Parameters object containing: ecpms (array<string>), query_ids (array<string>), request_id (string), sync_api (boolean)"),
		),
	)
	tools = append(tools, application_post_aggregate_revenueTool)

	// application_get_android_dialog_configs tool
	application_get_android_dialog_configsTool := mcp.NewTool("application_get_android_dialog_configs",
		mcp.WithDescription("GET android_dialog_configs for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_android_dialog_configsTool)

	// application_get_app_capi_settings tool
	application_get_app_capi_settingsTool := mcp.NewTool("application_get_app_capi_settings",
		mcp.WithDescription("GET app_capi_settings for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_app_capi_settingsTool)

	// application_get_app_event_types tool
	application_get_app_event_typesTool := mcp.NewTool("application_get_app_event_types",
		mcp.WithDescription("GET app_event_types for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_app_event_typesTool)

	// application_post_app_indexing tool
	// Params object accepts: app_version (string), device_session_id (string), extra_info (string), platform (applicationapp_indexing_platform_enum_param), request_type (applicationapp_indexing_request_type_enum_param), tree (map)
	application_post_app_indexingTool := mcp.NewTool("application_post_app_indexing",
		mcp.WithDescription("POST app_indexing for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"app_version": map[string]any{
					"type":        "string",
					"description": "app_version parameter",
					"required":    true,
				},
				"device_session_id": map[string]any{
					"type":        "string",
					"description": "device_session_id parameter",
				},
				"extra_info": map[string]any{
					"type":        "string",
					"description": "extra_info parameter",
				},
				"platform": map[string]any{
					"type":        "string",
					"description": "platform parameter",
					"required":    true,
					"enum":        []string{"ANDROID", "IOS"},
				},
				"request_type": map[string]any{
					"type":        "string",
					"description": "request_type parameter",
					"enum":        []string{"APP_INDEXING", "BUTTON_SAMPLING", "PLUGIN"},
				},
				"tree": map[string]any{
					"type":        "object",
					"description": "tree parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: app_version (string) [required], device_session_id (string), extra_info (string), platform (enum) [ANDROID, IOS] [required], request_type (enum) [APP_INDEXING, BUTTON_SAMPLING, PLUGIN], tree (object) [required]"),
		),
	)
	tools = append(tools, application_post_app_indexingTool)

	// application_post_app_indexing_session tool
	// Params object accepts: device_session_id (string), extinfo (string)
	application_post_app_indexing_sessionTool := mcp.NewTool("application_post_app_indexing_session",
		mcp.WithDescription("POST app_indexing_session for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"device_session_id": map[string]any{
					"type":        "string",
					"description": "device_session_id parameter",
					"required":    true,
				},
				"extinfo": map[string]any{
					"type":        "string",
					"description": "extinfo parameter",
				},
			}),
			mcp.Description("Parameters object containing: device_session_id (string) [required], extinfo (string)"),
		),
	)
	tools = append(tools, application_post_app_indexing_sessionTool)

	// application_get_app_installed_groups tool
	// Available fields for Group: archived, cover, created_time, description, email, icon, id, install, link, member_count, member_request_count, name, parent, permissions, privacy, purpose, subdomain, updated_time, venue
	// Params object accepts: group_id (string)
	application_get_app_installed_groupsTool := mcp.NewTool("application_get_app_installed_groups",
		mcp.WithDescription("GET app_installed_groups for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"group_id": map[string]any{
					"type":        "string",
					"description": "group_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: group_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Group objects. Available fields: archived, cover, created_time, description, email, icon, id, install, link, member_count, member_request_count, name, parent, permissions, privacy (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_app_installed_groupsTool)

	// application_post_app_push_device_token tool
	// Params object accepts: device_id (string), device_token (string), platform (applicationapp_push_device_token_platform_enum_param)
	application_post_app_push_device_tokenTool := mcp.NewTool("application_post_app_push_device_token",
		mcp.WithDescription("POST app_push_device_token for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"device_id": map[string]any{
					"type":        "string",
					"description": "device_id parameter",
					"required":    true,
				},
				"device_token": map[string]any{
					"type":        "string",
					"description": "device_token parameter",
					"required":    true,
				},
				"platform": map[string]any{
					"type":        "string",
					"description": "platform parameter",
					"enum":        []string{"ANDROID", "IOS", "UNKNOWN"},
				},
			}),
			mcp.Description("Parameters object containing: device_id (string) [required], device_token (string) [required], platform (enum) [ANDROID, IOS, UNKNOWN]"),
		),
	)
	tools = append(tools, application_post_app_push_device_tokenTool)

	// application_get_appassets tool
	application_get_appassetsTool := mcp.NewTool("application_get_appassets",
		mcp.WithDescription("GET appassets for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_appassetsTool)

	// application_post_assets tool
	// Params object accepts: asset (file), comment (string), type (string)
	application_post_assetsTool := mcp.NewTool("application_post_assets",
		mcp.WithDescription("POST assets for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"asset": map[string]any{
					"type":        "string",
					"description": "asset parameter",
					"required":    true,
				},
				"comment": map[string]any{
					"type":        "string",
					"description": "comment parameter",
				},
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: asset (file) [required], comment (string), type (string) [required]"),
		),
	)
	tools = append(tools, application_post_assetsTool)

	// application_get_authorized_adaccounts tool
	// Available fields for AdAccount: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state, business_street, business_street2, business_zip, can_create_brand_lift_study, capabilities, created_time, currency, custom_audience_info, default_dsa_beneficiary, default_dsa_payor, disable_reason, end_advertiser, end_advertiser_name, existing_customers, expired_funding_source_details, extended_credit_invoice_group, failed_delivery_checks, fb_entity, funding_source, funding_source_details, has_migrated_permissions, has_page_authorized_adaccount, id, io_number, is_attribution_spec_system_default, is_ba_skip_delayed_eligible, is_direct_deals_enabled, is_in_3ds_authorization_enabled_market, is_notifications_enabled, is_personal, is_prepay_account, is_tax_id_required, liable_address, line_numbers, media_agency, min_campaign_group_spend_cap, min_daily_budget, name, offsite_pixels_tos_accepted, owner, owner_business, partner, rf_spec, send_bill_to_address, show_checkout_experience, sold_to_address, spend_cap, tax_id, tax_id_status, tax_id_type, timezone_id, timezone_name, timezone_offset_hours_utc, tos_accepted, user_access_expire_time, user_tasks, user_tos_accepted, viewable_business
	// Params object accepts: business (string)
	application_get_authorized_adaccountsTool := mcp.NewTool("application_get_authorized_adaccounts",
		mcp.WithDescription("GET authorized_adaccounts for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
				},
			}),
			mcp.Description("Parameters object containing: business (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccount objects. Available fields: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state (and 58 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_authorized_adaccountsTool)

	// application_get_button_auto_detection_device_selection tool
	// Params object accepts: device_id (string)
	application_get_button_auto_detection_device_selectionTool := mcp.NewTool("application_get_button_auto_detection_device_selection",
		mcp.WithDescription("GET button_auto_detection_device_selection for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"device_id": map[string]any{
					"type":        "string",
					"description": "device_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: device_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_button_auto_detection_device_selectionTool)

	// application_get_cloudbridge_settings tool
	application_get_cloudbridge_settingsTool := mcp.NewTool("application_get_cloudbridge_settings",
		mcp.WithDescription("GET cloudbridge_settings for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_cloudbridge_settingsTool)

	// application_post_codeless_event_mappings tool
	// Params object accepts: mappings (list<map>), mutation_method (applicationcodeless_event_mappings_mutation_method_enum_param), platform (applicationcodeless_event_mappings_platform_enum_param), post_method (applicationcodeless_event_mappings_post_method_enum_param)
	application_post_codeless_event_mappingsTool := mcp.NewTool("application_post_codeless_event_mappings",
		mcp.WithDescription("POST codeless_event_mappings for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"mappings": map[string]any{
					"type":        "array",
					"description": "mappings parameter",
					"required":    true,
					"items":       map[string]any{"type": "object"},
				},
				"mutation_method": map[string]any{
					"type":        "string",
					"description": "mutation_method parameter",
					"required":    true,
					"enum":        []string{"ADD", "DELETE", "REPLACE"},
				},
				"platform": map[string]any{
					"type":        "string",
					"description": "platform parameter",
					"required":    true,
					"enum":        []string{"ANDROID", "IOS"},
				},
				"post_method": map[string]any{
					"type":        "string",
					"description": "post_method parameter",
					"enum":        []string{"CODELESS", "EYMT"},
				},
			}),
			mcp.Description("Parameters object containing: mappings (array<object>) [required], mutation_method (enum) [ADD, DELETE, REPLACE] [required], platform (enum) [ANDROID, IOS] [required], post_method (enum) [CODELESS, EYMT]"),
		),
	)
	tools = append(tools, application_post_codeless_event_mappingsTool)

	// application_get_connected_client_businesses tool
	// Available fields for Business: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id, two_factor_type, updated_by, updated_time, user_access_expire_time, verification_status, vertical, vertical_id
	application_get_connected_client_businessesTool := mcp.NewTool("application_get_connected_client_businesses",
		mcp.WithDescription("GET connected_client_businesses for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Business objects. Available fields: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id (and 7 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_connected_client_businessesTool)

	// application_get_da_checks tool
	// Available fields for DACheck: action_uri, description, key, result, title, user_message
	// Params object accepts: checks (list<string>), connection_method (applicationda_checks_connection_method_enum_param)
	application_get_da_checksTool := mcp.NewTool("application_get_da_checks",
		mcp.WithDescription("GET da_checks for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"checks": map[string]any{
					"type":        "array",
					"description": "checks parameter",
					"items":       map[string]any{"type": "string"},
				},
				"connection_method": map[string]any{
					"type":        "string",
					"description": "connection_method parameter",
					"enum":        []string{"ALL", "APP", "BROWSER", "SERVER"},
				},
			}),
			mcp.Description("Parameters object containing: checks (array<string>), connection_method (enum) [ALL, APP, BROWSER, SERVER]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for DACheck objects. Available fields: action_uri, description, key, result, title, user_message"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_da_checksTool)

	// application_post_domain_reports tool
	// Params object accepts: tracking_domains (list<string>)
	application_post_domain_reportsTool := mcp.NewTool("application_post_domain_reports",
		mcp.WithDescription("POST domain_reports for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"tracking_domains": map[string]any{
					"type":        "array",
					"description": "tracking_domains parameter",
					"required":    true,
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: tracking_domains (array<string>) [required]"),
		),
	)
	tools = append(tools, application_post_domain_reportsTool)

	// application_get_iap_purchases tool
	// Params object accepts: order_id (string)
	application_get_iap_purchasesTool := mcp.NewTool("application_get_iap_purchases",
		mcp.WithDescription("GET iap_purchases for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"order_id": map[string]any{
					"type":        "string",
					"description": "order_id parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: order_id (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_iap_purchasesTool)

	// application_get_ios_dialog_configs tool
	application_get_ios_dialog_configsTool := mcp.NewTool("application_get_ios_dialog_configs",
		mcp.WithDescription("GET ios_dialog_configs for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_ios_dialog_configsTool)

	// application_get_linked_dataset tool
	// Available fields for AdsDataset: can_proxy, collection_rate, config, creation_time, creator, dataset_id, description, duplicate_entries, enable_auto_assign_to_accounts, enable_automatic_events, enable_automatic_matching, enable_real_time_event_log, event_stats, event_time_max, event_time_min, first_party_cookie_status, has_bapi_domains, has_catalog_microdata_activity, has_ofa_redacted_keys, has_sent_pii, id, is_consolidated_container, is_created_by_business, is_crm, is_eligible_for_sharing_to_ad_account, is_eligible_for_sharing_to_business, is_eligible_for_value_optimization, is_mta_use, is_restricted_use, is_unavailable, last_fired_time, last_upload_app, last_upload_app_changed_time, last_upload_time, late_upload_reminder_eligibility, match_rate_approx, matched_entries, name, no_ads_tracked_for_weekly_uploaded_events_reminder_eligibility, num_active_ad_set_tracked, num_recent_offline_conversions_uploaded, num_uploads, owner_ad_account, owner_business, percentage_of_late_uploads_in_external_suboptimal_window, permissions, server_last_fired_time, show_automatic_events, upload_rate, upload_reminder_eligibility, usage, valid_entries
	application_get_linked_datasetTool := mcp.NewTool("application_get_linked_dataset",
		mcp.WithDescription("GET linked_dataset for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdsDataset objects. Available fields: can_proxy, collection_rate, config, creation_time, creator, dataset_id, description, duplicate_entries, enable_auto_assign_to_accounts, enable_automatic_events, enable_automatic_matching, enable_real_time_event_log, event_stats, event_time_max, event_time_min (and 37 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_linked_datasetTool)

	// application_get_message_templates tool
	// Params object accepts: template_id (string)
	application_get_message_templatesTool := mcp.NewTool("application_get_message_templates",
		mcp.WithDescription("GET message_templates for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"template_id": map[string]any{
					"type":        "string",
					"description": "template_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: template_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_message_templatesTool)

	// application_post_mmp_auditing tool
	// Params object accepts: advertiser_id (string), attribution (string), attribution_method (string), attribution_model (string), attribution_referrer (string), auditing_token (string), click_attr_window (unsigned int), custom_events (list<Object>), decline_reason (string), device_os (string), engagement_type (string), event (string), event_id (string), event_reported_time (unsigned int), fb_ad_id (unsigned int), fb_adgroup_id (unsigned int), fb_click_time (unsigned int), fb_view_time (unsigned int), google_install_referrer (string), inactivity_window_hours (unsigned int), install_id (string), is_fb (bool), meta_install_referrer (string), used_install_referrer (bool), view_attr_window (unsigned int)
	application_post_mmp_auditingTool := mcp.NewTool("application_post_mmp_auditing",
		mcp.WithDescription("POST mmp_auditing for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"advertiser_id": map[string]any{
					"type":        "string",
					"description": "advertiser_id parameter",
				},
				"attribution": map[string]any{
					"type":        "string",
					"description": "attribution parameter",
				},
				"attribution_method": map[string]any{
					"type":        "string",
					"description": "attribution_method parameter",
				},
				"attribution_model": map[string]any{
					"type":        "string",
					"description": "attribution_model parameter",
				},
				"attribution_referrer": map[string]any{
					"type":        "string",
					"description": "attribution_referrer parameter",
				},
				"auditing_token": map[string]any{
					"type":        "string",
					"description": "auditing_token parameter",
				},
				"click_attr_window": map[string]any{
					"type":        "integer",
					"description": "click_attr_window parameter",
				},
				"custom_events": map[string]any{
					"type":        "array",
					"description": "custom_events parameter",
					"items":       map[string]any{"type": "object"},
				},
				"decline_reason": map[string]any{
					"type":        "string",
					"description": "decline_reason parameter",
				},
				"device_os": map[string]any{
					"type":        "string",
					"description": "device_os parameter",
				},
				"engagement_type": map[string]any{
					"type":        "string",
					"description": "engagement_type parameter",
				},
				"event": map[string]any{
					"type":        "string",
					"description": "event parameter",
					"required":    true,
				},
				"event_id": map[string]any{
					"type":        "string",
					"description": "event_id parameter",
				},
				"event_reported_time": map[string]any{
					"type":        "integer",
					"description": "event_reported_time parameter",
				},
				"fb_ad_id": map[string]any{
					"type":        "integer",
					"description": "fb_ad_id parameter",
				},
				"fb_adgroup_id": map[string]any{
					"type":        "integer",
					"description": "fb_adgroup_id parameter",
				},
				"fb_click_time": map[string]any{
					"type":        "integer",
					"description": "fb_click_time parameter",
				},
				"fb_view_time": map[string]any{
					"type":        "integer",
					"description": "fb_view_time parameter",
				},
				"google_install_referrer": map[string]any{
					"type":        "string",
					"description": "google_install_referrer parameter",
				},
				"inactivity_window_hours": map[string]any{
					"type":        "integer",
					"description": "inactivity_window_hours parameter",
				},
				"install_id": map[string]any{
					"type":        "string",
					"description": "install_id parameter",
				},
				"is_fb": map[string]any{
					"type":        "boolean",
					"description": "is_fb parameter",
					"required":    true,
				},
				"meta_install_referrer": map[string]any{
					"type":        "string",
					"description": "meta_install_referrer parameter",
				},
				"used_install_referrer": map[string]any{
					"type":        "boolean",
					"description": "used_install_referrer parameter",
				},
				"view_attr_window": map[string]any{
					"type":        "integer",
					"description": "view_attr_window parameter",
				},
			}),
			mcp.Description("Parameters object containing: advertiser_id (string), attribution (string), attribution_method (string), attribution_model (string), attribution_referrer (string), auditing_token (string), click_attr_window (integer), custom_events (array<object>), decline_reason (string), device_os (string), engagement_type (string), event (string) [required], event_id (string), event_reported_time (integer), fb_ad_id (integer), fb_adgroup_id (integer), fb_click_time (integer), fb_view_time (integer), google_install_referrer (string), inactivity_window_hours (integer), install_id (string), is_fb (boolean) [required], meta_install_referrer (string), used_install_referrer (boolean), view_attr_window (integer)"),
		),
	)
	tools = append(tools, application_post_mmp_auditingTool)

	// application_get_mobile_sdk_gk tool
	// Params object accepts: device_id (string), extinfo (Object), os_version (string), platform (applicationmobile_sdk_gk_platform_enum_param), sdk_version (string)
	application_get_mobile_sdk_gkTool := mcp.NewTool("application_get_mobile_sdk_gk",
		mcp.WithDescription("GET mobile_sdk_gk for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"device_id": map[string]any{
					"type":        "string",
					"description": "device_id parameter",
				},
				"extinfo": map[string]any{
					"type":        "object",
					"description": "extinfo parameter",
				},
				"os_version": map[string]any{
					"type":        "string",
					"description": "os_version parameter",
				},
				"platform": map[string]any{
					"type":        "string",
					"description": "platform parameter",
					"required":    true,
					"enum":        []string{"ANDROID", "IOS"},
				},
				"sdk_version": map[string]any{
					"type":        "string",
					"description": "sdk_version parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: device_id (string), extinfo (object), os_version (string), platform (enum) [ANDROID, IOS] [required], sdk_version (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_mobile_sdk_gkTool)

	// application_get_monetized_digital_store_objects tool
	application_get_monetized_digital_store_objectsTool := mcp.NewTool("application_get_monetized_digital_store_objects",
		mcp.WithDescription("GET monetized_digital_store_objects for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_monetized_digital_store_objectsTool)

	// application_post_monetized_digital_store_objects tool
	// Params object accepts: content_id (string), store (string)
	application_post_monetized_digital_store_objectsTool := mcp.NewTool("application_post_monetized_digital_store_objects",
		mcp.WithDescription("POST monetized_digital_store_objects for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"content_id": map[string]any{
					"type":        "string",
					"description": "content_id parameter",
					"required":    true,
				},
				"store": map[string]any{
					"type":        "string",
					"description": "store parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: content_id (string) [required], store (string) [required]"),
		),
	)
	tools = append(tools, application_post_monetized_digital_store_objectsTool)

	// application_get_object_types tool
	application_get_object_typesTool := mcp.NewTool("application_get_object_types",
		mcp.WithDescription("GET object_types for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_object_typesTool)

	// application_get_objects tool
	application_get_objectsTool := mcp.NewTool("application_get_objects",
		mcp.WithDescription("GET objects for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_objectsTool)

	// application_post_occludespopups tool
	// Params object accepts: flash (bool), unity (bool)
	application_post_occludespopupsTool := mcp.NewTool("application_post_occludespopups",
		mcp.WithDescription("POST occludespopups for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"flash": map[string]any{
					"type":        "boolean",
					"description": "flash parameter",
				},
				"unity": map[string]any{
					"type":        "boolean",
					"description": "unity parameter",
				},
			}),
			mcp.Description("Parameters object containing: flash (boolean), unity (boolean)"),
		),
	)
	tools = append(tools, application_post_occludespopupsTool)

	// application_get_permissions tool
	// Params object accepts: android_key_hash (string), ios_bundle_id (string), permission (list<Permission>), proxied_app_id (int), status (list<applicationpermissions_status_enum_param>)
	application_get_permissionsTool := mcp.NewTool("application_get_permissions",
		mcp.WithDescription("GET permissions for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"android_key_hash": map[string]any{
					"type":        "string",
					"description": "android_key_hash parameter",
				},
				"ios_bundle_id": map[string]any{
					"type":        "string",
					"description": "ios_bundle_id parameter",
				},
				"permission": map[string]any{
					"type":        "array",
					"description": "permission parameter",
					"items":       map[string]any{"type": "string"},
				},
				"proxied_app_id": map[string]any{
					"type":        "integer",
					"description": "proxied_app_id parameter",
				},
				"status": map[string]any{
					"type":        "array",
					"description": "status parameter",
					"enum":        []string{"live", "unapproved"},
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: android_key_hash (string), ios_bundle_id (string), permission (array<Permission>), proxied_app_id (integer), status (array<enum>) [live, unapproved]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_permissionsTool)

	// application_get_products tool
	// Params object accepts: product_ids (list<string>)
	application_get_productsTool := mcp.NewTool("application_get_products",
		mcp.WithDescription("GET products for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"product_ids": map[string]any{
					"type":        "array",
					"description": "product_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: product_ids (array<string>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_productsTool)

	// application_get_purchases tool
	application_get_purchasesTool := mcp.NewTool("application_get_purchases",
		mcp.WithDescription("GET purchases for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_purchasesTool)

	// application_get_roles tool
	application_get_rolesTool := mcp.NewTool("application_get_roles",
		mcp.WithDescription("GET roles for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_rolesTool)

	// application_get_server_domain_infos tool
	application_get_server_domain_infosTool := mcp.NewTool("application_get_server_domain_infos",
		mcp.WithDescription("GET server_domain_infos for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_server_domain_infosTool)

	// application_get_sgw_dataset_status tool
	// Params object accepts: dataset_id (unsigned int)
	application_get_sgw_dataset_statusTool := mcp.NewTool("application_get_sgw_dataset_status",
		mcp.WithDescription("GET sgw_dataset_status for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"dataset_id": map[string]any{
					"type":        "integer",
					"description": "dataset_id parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: dataset_id (integer) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_sgw_dataset_statusTool)

	// application_get_sgw_install_deferral_link tool
	// Params object accepts: client_ip (string), dataset_id (unsigned int)
	application_get_sgw_install_deferral_linkTool := mcp.NewTool("application_get_sgw_install_deferral_link",
		mcp.WithDescription("GET sgw_install_deferral_link for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"client_ip": map[string]any{
					"type":        "string",
					"description": "client_ip parameter",
				},
				"dataset_id": map[string]any{
					"type":        "integer",
					"description": "dataset_id parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: client_ip (string), dataset_id (integer) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_sgw_install_deferral_linkTool)

	// application_get_subscribed_domains tool
	application_get_subscribed_domainsTool := mcp.NewTool("application_get_subscribed_domains",
		mcp.WithDescription("GET subscribed_domains for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_subscribed_domainsTool)

	// application_post_subscribed_domains tool
	// Params object accepts: subscribe (list<string>), unsubscribe (list<string>)
	application_post_subscribed_domainsTool := mcp.NewTool("application_post_subscribed_domains",
		mcp.WithDescription("POST subscribed_domains for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"subscribe": map[string]any{
					"type":        "array",
					"description": "subscribe parameter",
					"items":       map[string]any{"type": "string"},
				},
				"unsubscribe": map[string]any{
					"type":        "array",
					"description": "unsubscribe parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: subscribe (array<string>), unsubscribe (array<string>)"),
		),
	)
	tools = append(tools, application_post_subscribed_domainsTool)

	// application_get_subscribed_domains_phishing tool
	application_get_subscribed_domains_phishingTool := mcp.NewTool("application_get_subscribed_domains_phishing",
		mcp.WithDescription("GET subscribed_domains_phishing for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_subscribed_domains_phishingTool)

	// application_post_subscribed_domains_phishing tool
	// Params object accepts: subscribe (list<string>), unsubscribe (list<string>)
	application_post_subscribed_domains_phishingTool := mcp.NewTool("application_post_subscribed_domains_phishing",
		mcp.WithDescription("POST subscribed_domains_phishing for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"subscribe": map[string]any{
					"type":        "array",
					"description": "subscribe parameter",
					"items":       map[string]any{"type": "string"},
				},
				"unsubscribe": map[string]any{
					"type":        "array",
					"description": "unsubscribe parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: subscribe (array<string>), unsubscribe (array<string>)"),
		),
	)
	tools = append(tools, application_post_subscribed_domains_phishingTool)

	// application_delete_subscriptions tool
	// Params object accepts: fields (list<string>), object (string)
	application_delete_subscriptionsTool := mcp.NewTool("application_delete_subscriptions",
		mcp.WithDescription("DELETE subscriptions for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"fields": map[string]any{
					"type":        "array",
					"description": "fields parameter",
					"items":       map[string]any{"type": "string"},
				},
				"object": map[string]any{
					"type":        "string",
					"description": "object parameter",
				},
			}),
			mcp.Description("Parameters object containing: fields (array<string>), object (string)"),
		),
	)
	tools = append(tools, application_delete_subscriptionsTool)

	// application_get_subscriptions tool
	application_get_subscriptionsTool := mcp.NewTool("application_get_subscriptions",
		mcp.WithDescription("GET subscriptions for Application"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_subscriptionsTool)

	// application_post_subscriptions tool
	// Params object accepts: callback_url (string), fields (list<string>), include_values (bool), object (string), verify_token (string)
	application_post_subscriptionsTool := mcp.NewTool("application_post_subscriptions",
		mcp.WithDescription("POST subscriptions for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"callback_url": map[string]any{
					"type":        "string",
					"description": "callback_url parameter",
				},
				"fields": map[string]any{
					"type":        "array",
					"description": "fields parameter",
					"items":       map[string]any{"type": "string"},
				},
				"include_values": map[string]any{
					"type":        "boolean",
					"description": "include_values parameter",
				},
				"object": map[string]any{
					"type":        "string",
					"description": "object parameter",
					"required":    true,
				},
				"verify_token": map[string]any{
					"type":        "string",
					"description": "verify_token parameter",
				},
			}),
			mcp.Description("Parameters object containing: callback_url (string), fields (array<string>), include_values (boolean), object (string) [required], verify_token (string)"),
		),
	)
	tools = append(tools, application_post_subscriptionsTool)

	// application_post_uploads tool
	// Params object accepts: file_length (unsigned int), file_name (Object), file_type (Object), session_type (applicationuploads_session_type_enum_param)
	application_post_uploadsTool := mcp.NewTool("application_post_uploads",
		mcp.WithDescription("POST uploads for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"file_length": map[string]any{
					"type":        "integer",
					"description": "file_length parameter",
				},
				"file_name": map[string]any{
					"type":        "object",
					"description": "file_name parameter",
				},
				"file_type": map[string]any{
					"type":        "object",
					"description": "file_type parameter",
				},
				"session_type": map[string]any{
					"type":        "string",
					"description": "session_type parameter",
					"enum":        []string{"attachment"},
				},
			}),
			mcp.Description("Parameters object containing: file_length (integer), file_name (object), file_type (object), session_type (enum) [attachment]"),
		),
	)
	tools = append(tools, application_post_uploadsTool)

	// application_post_whatsapp_business_solution tool
	// Params object accepts: owner_permissions (list<applicationwhatsapp_business_solution_owner_permissions_enum_param>), partner_app_id (string), partner_permissions (list<applicationwhatsapp_business_solution_partner_permissions_enum_param>), solution_name (string)
	application_post_whatsapp_business_solutionTool := mcp.NewTool("application_post_whatsapp_business_solution",
		mcp.WithDescription("POST whatsapp_business_solution for Application"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"owner_permissions": map[string]any{
					"type":        "array",
					"description": "owner_permissions parameter",
					"required":    true,
					"enum":        []string{"DEVELOP", "MANAGE", "MANAGE_EXTENSIONS", "MANAGE_PHONE", "MANAGE_PHONE_ASSETS", "MANAGE_TEMPLATES", "MESSAGING", "VIEW_COST", "VIEW_PHONE_ASSETS", "VIEW_TEMPLATES"},
					"items":       map[string]any{"type": "string"},
				},
				"partner_app_id": map[string]any{
					"type":        "string",
					"description": "partner_app_id parameter",
					"required":    true,
				},
				"partner_permissions": map[string]any{
					"type":        "array",
					"description": "partner_permissions parameter",
					"required":    true,
					"enum":        []string{"DEVELOP", "MANAGE", "MANAGE_EXTENSIONS", "MANAGE_PHONE", "MANAGE_PHONE_ASSETS", "MANAGE_TEMPLATES", "MESSAGING", "VIEW_COST", "VIEW_PHONE_ASSETS", "VIEW_TEMPLATES"},
					"items":       map[string]any{"type": "string"},
				},
				"solution_name": map[string]any{
					"type":        "string",
					"description": "solution_name parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: owner_permissions (array<enum>) [DEVELOP, MANAGE, MANAGE_EXTENSIONS, MANAGE_PHONE, MANAGE_PHONE_ASSETS, ...] [required], partner_app_id (string) [required], partner_permissions (array<enum>) [DEVELOP, MANAGE, MANAGE_EXTENSIONS, MANAGE_PHONE, MANAGE_PHONE_ASSETS, ...] [required], solution_name (string) [required]"),
		),
	)
	tools = append(tools, application_post_whatsapp_business_solutionTool)

	// application_get_whatsapp_business_solutions tool
	// Params object accepts: role (applicationwhatsapp_business_solutions_role_enum_param)
	application_get_whatsapp_business_solutionsTool := mcp.NewTool("application_get_whatsapp_business_solutions",
		mcp.WithDescription("GET whatsapp_business_solutions for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"role": map[string]any{
					"type":        "string",
					"description": "role parameter",
					"enum":        []string{"OWNER", "PARTNER"},
				},
			}),
			mcp.Description("Parameters object containing: role (enum) [OWNER, PARTNER]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_whatsapp_business_solutionsTool)

	// application_get_ tool
	// Available fields for Application: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline, auth_dialog_perms_explanation, auth_referral_default_activity_privacy, auth_referral_enabled, auth_referral_extended_perms, auth_referral_friend_perms, auth_referral_response_type, auth_referral_user_perms, auto_event_mapping_android, auto_event_mapping_ios, auto_event_setup_enabled, auto_log_app_events_default, auto_log_app_events_enabled, business, canvas_fluid_height, canvas_fluid_width, canvas_url, category, client_config, company, configured_ios_sso, contact_email, created_time, creator_uid, daily_active_users, daily_active_users_rank, deauth_callback_url, default_share_mode, description, enigma_config, financial_id, gdpv4_chrome_custom_tabs_enabled, gdpv4_enabled, gdpv4_nux_content, gdpv4_nux_enabled, has_messenger_product, hosting_url, icon_url, id, ios_bundle_id, ios_sdk_dialog_flows, ios_sdk_error_categories, ios_sfvc_attr, ios_supports_native_proxy_auth_flow, ios_supports_system_auth, ipad_app_store_id, iphone_app_store_id, latest_sdk_version, link, logging_token, logo_url, migrations, mobile_profile_section_url, mobile_web_url, monthly_active_users, monthly_active_users_rank, name, namespace, object_store_urls, owner_business, page_tab_default_name, page_tab_url, photo_url, privacy_policy_url, profile_section_url, property_id, protected_mode_rules, real_time_mode_devices, restrictions, restrictive_data_filter_params, restrictive_data_filter_rules, sdk_update_message, seamless_login, secure_canvas_url, secure_page_tab_url, server_ip_whitelist, smart_login_bookmark_icon_url, smart_login_menu_icon_url, social_discovery, subcategory, suggested_events_setting, supported_platforms, supports_apprequests_fast_app_switch, supports_attribution, supports_implicit_sdk_logging, suppress_native_ios_gdp, terms_of_service_url, url_scheme_suffix, user_support_email, user_support_url, website_url, weekly_active_users
	// Params object accepts: advertiser_id (string)
	application_get_Tool := mcp.NewTool("application_get_",
		mcp.WithDescription("GET  for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"advertiser_id": map[string]any{
					"type":        "string",
					"description": "advertiser_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: advertiser_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Application objects. Available fields: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline (and 91 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, application_get_Tool)

	// application_post_ tool
	// Params object accepts: allow_cycle_app_secret (bool), an_platforms (list<application_an_platforms>), app_domains (list<string>), app_name (string), app_type (bool), auth_dialog_headline (string), auth_dialog_perms_explanation (string), auth_referral_enabled (bool), auth_referral_extended_perms (list<string>), auth_referral_friend_perms (list<string>), auth_referral_response_type (string), auth_referral_user_perms (list<string>), canvas_fluid_height (bool), canvas_fluid_width (bool), canvas_url (string), contact_email (string), deauth_callback_url (string), mobile_web_url (string), namespace (string), page_tab_default_name (string), privacy_policy_url (string), restrictions (string), secure_canvas_url (string), secure_page_tab_url (string), server_ip_whitelist (list<string>), terms_of_service_url (string), url_scheme_suffix (string), user_support_email (string), user_support_url (string), website_url (string)
	application_post_Tool := mcp.NewTool("application_post_",
		mcp.WithDescription("POST  for Application"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"allow_cycle_app_secret": map[string]any{
					"type":        "boolean",
					"description": "allow_cycle_app_secret parameter",
				},
				"an_platforms": map[string]any{
					"type":        "array",
					"description": "an_platforms parameter",
					"enum":        []string{"ANDROID", "DESKTOP", "GALAXY", "INSTANT_ARTICLES", "IOS", "MOBILE_WEB", "OCULUS", "UNKNOWN", "XIAOMI"},
					"items":       map[string]any{"type": "string"},
				},
				"app_domains": map[string]any{
					"type":        "array",
					"description": "app_domains parameter",
					"items":       map[string]any{"type": "string"},
				},
				"app_name": map[string]any{
					"type":        "string",
					"description": "app_name parameter",
				},
				"app_type": map[string]any{
					"type":        "boolean",
					"description": "app_type parameter",
				},
				"auth_dialog_headline": map[string]any{
					"type":        "string",
					"description": "auth_dialog_headline parameter",
				},
				"auth_dialog_perms_explanation": map[string]any{
					"type":        "string",
					"description": "auth_dialog_perms_explanation parameter",
				},
				"auth_referral_enabled": map[string]any{
					"type":        "boolean",
					"description": "auth_referral_enabled parameter",
				},
				"auth_referral_extended_perms": map[string]any{
					"type":        "array",
					"description": "auth_referral_extended_perms parameter",
					"items":       map[string]any{"type": "string"},
				},
				"auth_referral_friend_perms": map[string]any{
					"type":        "array",
					"description": "auth_referral_friend_perms parameter",
					"items":       map[string]any{"type": "string"},
				},
				"auth_referral_response_type": map[string]any{
					"type":        "string",
					"description": "auth_referral_response_type parameter",
				},
				"auth_referral_user_perms": map[string]any{
					"type":        "array",
					"description": "auth_referral_user_perms parameter",
					"items":       map[string]any{"type": "string"},
				},
				"canvas_fluid_height": map[string]any{
					"type":        "boolean",
					"description": "canvas_fluid_height parameter",
				},
				"canvas_fluid_width": map[string]any{
					"type":        "boolean",
					"description": "canvas_fluid_width parameter",
				},
				"canvas_url": map[string]any{
					"type":        "string",
					"description": "canvas_url parameter",
				},
				"contact_email": map[string]any{
					"type":        "string",
					"description": "contact_email parameter",
				},
				"deauth_callback_url": map[string]any{
					"type":        "string",
					"description": "deauth_callback_url parameter",
				},
				"mobile_web_url": map[string]any{
					"type":        "string",
					"description": "mobile_web_url parameter",
				},
				"namespace": map[string]any{
					"type":        "string",
					"description": "namespace parameter",
				},
				"page_tab_default_name": map[string]any{
					"type":        "string",
					"description": "page_tab_default_name parameter",
				},
				"privacy_policy_url": map[string]any{
					"type":        "string",
					"description": "privacy_policy_url parameter",
				},
				"restrictions": map[string]any{
					"type":        "string",
					"description": "restrictions parameter",
				},
				"secure_canvas_url": map[string]any{
					"type":        "string",
					"description": "secure_canvas_url parameter",
				},
				"secure_page_tab_url": map[string]any{
					"type":        "string",
					"description": "secure_page_tab_url parameter",
				},
				"server_ip_whitelist": map[string]any{
					"type":        "array",
					"description": "server_ip_whitelist parameter",
					"items":       map[string]any{"type": "string"},
				},
				"terms_of_service_url": map[string]any{
					"type":        "string",
					"description": "terms_of_service_url parameter",
				},
				"url_scheme_suffix": map[string]any{
					"type":        "string",
					"description": "url_scheme_suffix parameter",
				},
				"user_support_email": map[string]any{
					"type":        "string",
					"description": "user_support_email parameter",
				},
				"user_support_url": map[string]any{
					"type":        "string",
					"description": "user_support_url parameter",
				},
				"website_url": map[string]any{
					"type":        "string",
					"description": "website_url parameter",
				},
			}),
			mcp.Description("Parameters object containing: allow_cycle_app_secret (boolean), an_platforms (array<application_an_platforms>) [ANDROID, DESKTOP, GALAXY, INSTANT_ARTICLES, IOS, ...], app_domains (array<string>), app_name (string), app_type (boolean), auth_dialog_headline (string), auth_dialog_perms_explanation (string), auth_referral_enabled (boolean), auth_referral_extended_perms (array<string>), auth_referral_friend_perms (array<string>), auth_referral_response_type (string), auth_referral_user_perms (array<string>), canvas_fluid_height (boolean), canvas_fluid_width (boolean), canvas_url (string), contact_email (string), deauth_callback_url (string), mobile_web_url (string), namespace (string), page_tab_default_name (string), privacy_policy_url (string), restrictions (string), secure_canvas_url (string), secure_page_tab_url (string), server_ip_whitelist (array<string>), terms_of_service_url (string), url_scheme_suffix (string), user_support_email (string), user_support_url (string), website_url (string)"),
		),
	)
	tools = append(tools, application_post_Tool)

	return tools
}

// Application handlers

// HandleApplication_delete_accounts handles the application_delete_accounts tool with context-based auth
func HandleApplication_delete_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_delete_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_delete_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_accounts handles the application_get_accounts tool with context-based auth
func HandleApplication_get_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_accounts handles the application_post_accounts tool with context-based auth
func HandleApplication_post_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Application_post_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_activities handles the application_post_activities tool with context-based auth
func HandleApplication_post_activities(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_activities(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_activities: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_ad_placement_groups handles the application_get_ad_placement_groups tool with context-based auth
func HandleApplication_get_ad_placement_groups(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_ad_placement_groups(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_ad_placement_groups: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_adnetwork_placements handles the application_get_adnetwork_placements tool with context-based auth
func HandleApplication_get_adnetwork_placements(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_adnetwork_placements(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_adnetwork_placements: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_adnetworkanalytics handles the application_get_adnetworkanalytics tool with context-based auth
func HandleApplication_get_adnetworkanalytics(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_adnetworkanalytics(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_adnetworkanalytics: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_adnetworkanalytics handles the application_post_adnetworkanalytics tool with context-based auth
func HandleApplication_post_adnetworkanalytics(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_adnetworkanalytics(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_adnetworkanalytics: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_adnetworkanalytics_results handles the application_get_adnetworkanalytics_results tool with context-based auth
func HandleApplication_get_adnetworkanalytics_results(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_adnetworkanalytics_results(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_adnetworkanalytics_results: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_aem_attribution handles the application_get_aem_attribution tool with context-based auth
func HandleApplication_get_aem_attribution(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_aem_attribution(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_aem_attribution: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_aem_conversion_configs handles the application_get_aem_conversion_configs tool with context-based auth
func HandleApplication_get_aem_conversion_configs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_aem_conversion_configs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_aem_conversion_configs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_aem_conversion_filter handles the application_get_aem_conversion_filter tool with context-based auth
func HandleApplication_get_aem_conversion_filter(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_aem_conversion_filter(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_aem_conversion_filter: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_aem_conversions handles the application_post_aem_conversions tool with context-based auth
func HandleApplication_post_aem_conversions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_aem_conversions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_aem_conversions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_aem_skan_readiness handles the application_post_aem_skan_readiness tool with context-based auth
func HandleApplication_post_aem_skan_readiness(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_aem_skan_readiness(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_aem_skan_readiness: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_agencies handles the application_get_agencies tool with context-based auth
func HandleApplication_get_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_aggregate_revenue handles the application_post_aggregate_revenue tool with context-based auth
func HandleApplication_post_aggregate_revenue(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Application_post_aggregate_revenue(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_aggregate_revenue: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_android_dialog_configs handles the application_get_android_dialog_configs tool with context-based auth
func HandleApplication_get_android_dialog_configs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_android_dialog_configs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_android_dialog_configs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_app_capi_settings handles the application_get_app_capi_settings tool with context-based auth
func HandleApplication_get_app_capi_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_app_capi_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_app_capi_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_app_event_types handles the application_get_app_event_types tool with context-based auth
func HandleApplication_get_app_event_types(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_app_event_types(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_app_event_types: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_app_indexing handles the application_post_app_indexing tool with context-based auth
func HandleApplication_post_app_indexing(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_app_indexing(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_app_indexing: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_app_indexing_session handles the application_post_app_indexing_session tool with context-based auth
func HandleApplication_post_app_indexing_session(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_app_indexing_session(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_app_indexing_session: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_app_installed_groups handles the application_get_app_installed_groups tool with context-based auth
func HandleApplication_get_app_installed_groups(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_app_installed_groups(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_app_installed_groups: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_app_push_device_token handles the application_post_app_push_device_token tool with context-based auth
func HandleApplication_post_app_push_device_token(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_app_push_device_token(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_app_push_device_token: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_appassets handles the application_get_appassets tool with context-based auth
func HandleApplication_get_appassets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_appassets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_appassets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_assets handles the application_post_assets tool with context-based auth
func HandleApplication_post_assets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_assets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_assets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_authorized_adaccounts handles the application_get_authorized_adaccounts tool with context-based auth
func HandleApplication_get_authorized_adaccounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_authorized_adaccounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_authorized_adaccounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_button_auto_detection_device_selection handles the application_get_button_auto_detection_device_selection tool with context-based auth
func HandleApplication_get_button_auto_detection_device_selection(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_button_auto_detection_device_selection(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_button_auto_detection_device_selection: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_cloudbridge_settings handles the application_get_cloudbridge_settings tool with context-based auth
func HandleApplication_get_cloudbridge_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_cloudbridge_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_cloudbridge_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_codeless_event_mappings handles the application_post_codeless_event_mappings tool with context-based auth
func HandleApplication_post_codeless_event_mappings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_codeless_event_mappings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_codeless_event_mappings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_connected_client_businesses handles the application_get_connected_client_businesses tool with context-based auth
func HandleApplication_get_connected_client_businesses(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_connected_client_businesses(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_connected_client_businesses: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_da_checks handles the application_get_da_checks tool with context-based auth
func HandleApplication_get_da_checks(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_da_checks(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_da_checks: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_domain_reports handles the application_post_domain_reports tool with context-based auth
func HandleApplication_post_domain_reports(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_domain_reports(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_domain_reports: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_iap_purchases handles the application_get_iap_purchases tool with context-based auth
func HandleApplication_get_iap_purchases(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_iap_purchases(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_iap_purchases: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_ios_dialog_configs handles the application_get_ios_dialog_configs tool with context-based auth
func HandleApplication_get_ios_dialog_configs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_ios_dialog_configs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_ios_dialog_configs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_linked_dataset handles the application_get_linked_dataset tool with context-based auth
func HandleApplication_get_linked_dataset(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_linked_dataset(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_linked_dataset: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_message_templates handles the application_get_message_templates tool with context-based auth
func HandleApplication_get_message_templates(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_message_templates(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_message_templates: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_mmp_auditing handles the application_post_mmp_auditing tool with context-based auth
func HandleApplication_post_mmp_auditing(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_mmp_auditing(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_mmp_auditing: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_mobile_sdk_gk handles the application_get_mobile_sdk_gk tool with context-based auth
func HandleApplication_get_mobile_sdk_gk(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_mobile_sdk_gk(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_mobile_sdk_gk: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_monetized_digital_store_objects handles the application_get_monetized_digital_store_objects tool with context-based auth
func HandleApplication_get_monetized_digital_store_objects(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_monetized_digital_store_objects(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_monetized_digital_store_objects: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_monetized_digital_store_objects handles the application_post_monetized_digital_store_objects tool with context-based auth
func HandleApplication_post_monetized_digital_store_objects(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_monetized_digital_store_objects(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_monetized_digital_store_objects: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_object_types handles the application_get_object_types tool with context-based auth
func HandleApplication_get_object_types(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_object_types(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_object_types: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_objects handles the application_get_objects tool with context-based auth
func HandleApplication_get_objects(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_objects(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_objects: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_occludespopups handles the application_post_occludespopups tool with context-based auth
func HandleApplication_post_occludespopups(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Application_post_occludespopups(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_occludespopups: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_permissions handles the application_get_permissions tool with context-based auth
func HandleApplication_get_permissions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_permissions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_permissions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_products handles the application_get_products tool with context-based auth
func HandleApplication_get_products(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_products(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_products: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_purchases handles the application_get_purchases tool with context-based auth
func HandleApplication_get_purchases(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_purchases(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_purchases: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_roles handles the application_get_roles tool with context-based auth
func HandleApplication_get_roles(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_roles(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_roles: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_server_domain_infos handles the application_get_server_domain_infos tool with context-based auth
func HandleApplication_get_server_domain_infos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_server_domain_infos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_server_domain_infos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_sgw_dataset_status handles the application_get_sgw_dataset_status tool with context-based auth
func HandleApplication_get_sgw_dataset_status(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_sgw_dataset_status(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_sgw_dataset_status: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_sgw_install_deferral_link handles the application_get_sgw_install_deferral_link tool with context-based auth
func HandleApplication_get_sgw_install_deferral_link(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_sgw_install_deferral_link(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_sgw_install_deferral_link: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_subscribed_domains handles the application_get_subscribed_domains tool with context-based auth
func HandleApplication_get_subscribed_domains(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_subscribed_domains(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_subscribed_domains: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_subscribed_domains handles the application_post_subscribed_domains tool with context-based auth
func HandleApplication_post_subscribed_domains(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Application_post_subscribed_domains(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_subscribed_domains: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_subscribed_domains_phishing handles the application_get_subscribed_domains_phishing tool with context-based auth
func HandleApplication_get_subscribed_domains_phishing(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_subscribed_domains_phishing(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_subscribed_domains_phishing: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_subscribed_domains_phishing handles the application_post_subscribed_domains_phishing tool with context-based auth
func HandleApplication_post_subscribed_domains_phishing(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Application_post_subscribed_domains_phishing(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_subscribed_domains_phishing: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_delete_subscriptions handles the application_delete_subscriptions tool with context-based auth
func HandleApplication_delete_subscriptions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Application_delete_subscriptions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_delete_subscriptions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_subscriptions handles the application_get_subscriptions tool with context-based auth
func HandleApplication_get_subscriptions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_subscriptions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_subscriptions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_subscriptions handles the application_post_subscriptions tool with context-based auth
func HandleApplication_post_subscriptions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_subscriptions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_subscriptions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_uploads handles the application_post_uploads tool with context-based auth
func HandleApplication_post_uploads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Application_post_uploads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_uploads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_whatsapp_business_solution handles the application_post_whatsapp_business_solution tool with context-based auth
func HandleApplication_post_whatsapp_business_solution(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Application_post_whatsapp_business_solution(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_whatsapp_business_solution: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_whatsapp_business_solutions handles the application_get_whatsapp_business_solutions tool with context-based auth
func HandleApplication_get_whatsapp_business_solutions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_whatsapp_business_solutions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_whatsapp_business_solutions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_get_ handles the application_get_ tool with context-based auth
func HandleApplication_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Application_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleApplication_post_ handles the application_post_ tool with context-based auth
func HandleApplication_post_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewApplicationClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Application_post_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute application_post_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}
