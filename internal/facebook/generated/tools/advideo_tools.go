// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetAdVideoTools returns MCP tools for AdVideo
func GetAdVideoTools() []mcp.Tool {
	var tools []mcp.Tool

	// advideo_get_boost_ads_list tool
	advideo_get_boost_ads_listTool := mcp.NewTool("advideo_get_boost_ads_list",
		mcp.WithDescription("GET boost_ads_list for AdVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_boost_ads_listTool)

	// advideo_get_captions tool
	advideo_get_captionsTool := mcp.NewTool("advideo_get_captions",
		mcp.WithDescription("GET captions for AdVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_captionsTool)

	// advideo_post_captions tool
	// Params object accepts: captions_file (file), default_locale (string), locales_to_delete (list<string>)
	advideo_post_captionsTool := mcp.NewTool("advideo_post_captions",
		mcp.WithDescription("POST captions for AdVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"captions_file": map[string]any{
					"type":        "string",
					"description": "captions_file parameter",
				},
				"default_locale": map[string]any{
					"type":        "string",
					"description": "default_locale parameter",
				},
				"locales_to_delete": map[string]any{
					"type":        "array",
					"description": "locales_to_delete parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: captions_file (file), default_locale (string), locales_to_delete (array<string>)"),
		),
	)
	tools = append(tools, advideo_post_captionsTool)

	// advideo_get_collaborators tool
	advideo_get_collaboratorsTool := mcp.NewTool("advideo_get_collaborators",
		mcp.WithDescription("GET collaborators for AdVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_collaboratorsTool)

	// advideo_post_collaborators tool
	// Params object accepts: target_id (string)
	advideo_post_collaboratorsTool := mcp.NewTool("advideo_post_collaborators",
		mcp.WithDescription("POST collaborators for AdVideo"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"target_id": map[string]any{
					"type":        "string",
					"description": "target_id parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: target_id (string) [required]"),
		),
	)
	tools = append(tools, advideo_post_collaboratorsTool)

	// advideo_get_comments tool
	// Available fields for Comment: admin_creator, application, attachment, can_comment, can_hide, can_like, can_remove, can_reply_privately, comment_count, created_time, from, id, is_hidden, is_private, like_count, live_broadcast_timestamp, message, message_tags, object, parent, permalink_url, private_reply_conversation, user_likes
	// Params object accepts: filter (videocomments_filter_enum_param), live_filter (videocomments_live_filter_enum_param), order (videocomments_order_enum_param), since (datetime)
	advideo_get_commentsTool := mcp.NewTool("advideo_get_comments",
		mcp.WithDescription("GET comments for AdVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"filter": map[string]any{
					"type":        "string",
					"description": "filter parameter",
					"enum":        []string{"stream", "toplevel"},
				},
				"live_filter": map[string]any{
					"type":        "string",
					"description": "live_filter parameter",
					"enum":        []string{"filter_low_quality", "no_filter"},
				},
				"order": map[string]any{
					"type":        "string",
					"description": "order parameter",
					"enum":        []string{"chronological", "reverse_chronological"},
				},
				"since": map[string]any{
					"type":        "string",
					"description": "since parameter",
				},
			}),
			mcp.Description("Parameters object containing: filter (enum) [stream, toplevel], live_filter (enum) [filter_low_quality, no_filter], order (enum) [chronological, reverse_chronological], since (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Comment objects. Available fields: admin_creator, application, attachment, can_comment, can_hide, can_like, can_remove, can_reply_privately, comment_count, created_time, from, id, is_hidden, is_private, like_count (and 8 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_commentsTool)

	// advideo_post_comments tool
	// Params object accepts: attachment_id (string), attachment_share_url (string), attachment_url (string), comment_privacy_value (videocomments_comment_privacy_value_enum_param), facepile_mentioned_ids (list<string>), feedback_source (string), is_offline (bool), message (string), nectar_module (string), object_id (string), parent_comment_id (Object), text (string), tracking (string)
	advideo_post_commentsTool := mcp.NewTool("advideo_post_comments",
		mcp.WithDescription("POST comments for AdVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"attachment_id": map[string]any{
					"type":        "string",
					"description": "attachment_id parameter",
				},
				"attachment_share_url": map[string]any{
					"type":        "string",
					"description": "attachment_share_url parameter",
				},
				"attachment_url": map[string]any{
					"type":        "string",
					"description": "attachment_url parameter",
				},
				"comment_privacy_value": map[string]any{
					"type":        "string",
					"description": "comment_privacy_value parameter",
					"enum":        []string{"DECLINED_BY_ADMIN_ASSISTANT", "DEFAULT_PRIVACY", "FRIENDS_AND_POST_OWNER", "FRIENDS_ONLY", "GRAPHQL_MULTIPLE_VALUE_HACK_DO_NOT_USE", "OWNER_OR_COMMENTER", "PENDING_APPROVAL", "REMOVED_BY_ADMIN_ASSISTANT", "SIDE_CONVERSATION", "SIDE_CONVERSATION_AND_POST_OWNER", "SPOTLIGHT_TAB"},
				},
				"facepile_mentioned_ids": map[string]any{
					"type":        "array",
					"description": "facepile_mentioned_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"feedback_source": map[string]any{
					"type":        "string",
					"description": "feedback_source parameter",
				},
				"is_offline": map[string]any{
					"type":        "boolean",
					"description": "is_offline parameter",
				},
				"message": map[string]any{
					"type":        "string",
					"description": "message parameter",
				},
				"nectar_module": map[string]any{
					"type":        "string",
					"description": "nectar_module parameter",
				},
				"object_id": map[string]any{
					"type":        "string",
					"description": "object_id parameter",
				},
				"parent_comment_id": map[string]any{
					"type":        "object",
					"description": "parent_comment_id parameter",
				},
				"text": map[string]any{
					"type":        "string",
					"description": "text parameter",
				},
				"tracking": map[string]any{
					"type":        "string",
					"description": "tracking parameter",
				},
			}),
			mcp.Description("Parameters object containing: attachment_id (string), attachment_share_url (string), attachment_url (string), comment_privacy_value (enum) [DECLINED_BY_ADMIN_ASSISTANT, DEFAULT_PRIVACY, FRIENDS_AND_POST_OWNER, FRIENDS_ONLY, GRAPHQL_MULTIPLE_VALUE_HACK_DO_NOT_USE, ...], facepile_mentioned_ids (array<string>), feedback_source (string), is_offline (boolean), message (string), nectar_module (string), object_id (string), parent_comment_id (object), text (string), tracking (string)"),
		),
	)
	tools = append(tools, advideo_post_commentsTool)

	// advideo_get_crosspost_shared_pages tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	advideo_get_crosspost_shared_pagesTool := mcp.NewTool("advideo_get_crosspost_shared_pages",
		mcp.WithDescription("GET crosspost_shared_pages for AdVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_crosspost_shared_pagesTool)

	// advideo_post_gaming_clip_create tool
	// Params object accepts: duration_seconds (float)
	advideo_post_gaming_clip_createTool := mcp.NewTool("advideo_post_gaming_clip_create",
		mcp.WithDescription("POST gaming_clip_create for AdVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"duration_seconds": map[string]any{
					"type":        "number",
					"description": "duration_seconds parameter",
				},
			}),
			mcp.Description("Parameters object containing: duration_seconds (number)"),
		),
	)
	tools = append(tools, advideo_post_gaming_clip_createTool)

	// advideo_get_likes tool
	// Available fields for Profile: can_post, id, link, name, pic, pic_crop, pic_large, pic_small, pic_square, profile_type, username
	advideo_get_likesTool := mcp.NewTool("advideo_get_likes",
		mcp.WithDescription("GET likes for AdVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Profile objects. Available fields: can_post, id, link, name, pic, pic_crop, pic_large, pic_small, pic_square, profile_type, username"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_likesTool)

	// advideo_post_likes tool
	// Params object accepts: feedback_source (string), nectar_module (string), notify (bool), tracking (string)
	advideo_post_likesTool := mcp.NewTool("advideo_post_likes",
		mcp.WithDescription("POST likes for AdVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"feedback_source": map[string]any{
					"type":        "string",
					"description": "feedback_source parameter",
				},
				"nectar_module": map[string]any{
					"type":        "string",
					"description": "nectar_module parameter",
				},
				"notify": map[string]any{
					"type":        "boolean",
					"description": "notify parameter",
				},
				"tracking": map[string]any{
					"type":        "string",
					"description": "tracking parameter",
				},
			}),
			mcp.Description("Parameters object containing: feedback_source (string), nectar_module (string), notify (boolean), tracking (string)"),
		),
	)
	tools = append(tools, advideo_post_likesTool)

	// advideo_get_poll_settings tool
	advideo_get_poll_settingsTool := mcp.NewTool("advideo_get_poll_settings",
		mcp.WithDescription("GET poll_settings for AdVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_poll_settingsTool)

	// advideo_get_polls tool
	// Available fields for VideoPoll: close_after_voting, default_open, id, question, show_gradient, show_results, status
	advideo_get_pollsTool := mcp.NewTool("advideo_get_polls",
		mcp.WithDescription("GET polls for AdVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for VideoPoll objects. Available fields: close_after_voting, default_open, id, question, show_gradient, show_results, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_pollsTool)

	// advideo_post_polls tool
	// Params object accepts: close_after_voting (bool), correct_option (unsigned int), default_open (bool), options (list<string>), question (string), show_gradient (bool), show_results (bool)
	advideo_post_pollsTool := mcp.NewTool("advideo_post_polls",
		mcp.WithDescription("POST polls for AdVideo"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"close_after_voting": map[string]any{
					"type":        "boolean",
					"description": "close_after_voting parameter",
				},
				"correct_option": map[string]any{
					"type":        "integer",
					"description": "correct_option parameter",
				},
				"default_open": map[string]any{
					"type":        "boolean",
					"description": "default_open parameter",
				},
				"options": map[string]any{
					"type":        "array",
					"description": "options parameter",
					"required":    true,
					"items":       map[string]any{"type": "string"},
				},
				"question": map[string]any{
					"type":        "string",
					"description": "question parameter",
					"required":    true,
				},
				"show_gradient": map[string]any{
					"type":        "boolean",
					"description": "show_gradient parameter",
				},
				"show_results": map[string]any{
					"type":        "boolean",
					"description": "show_results parameter",
				},
			}),
			mcp.Description("Parameters object containing: close_after_voting (boolean), correct_option (integer), default_open (boolean), options (array<string>) [required], question (string) [required], show_gradient (boolean), show_results (boolean)"),
		),
	)
	tools = append(tools, advideo_post_pollsTool)

	// advideo_get_sponsor_tags tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	advideo_get_sponsor_tagsTool := mcp.NewTool("advideo_get_sponsor_tags",
		mcp.WithDescription("GET sponsor_tags for AdVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_sponsor_tagsTool)

	// advideo_get_tags tool
	// Available fields for TaggableSubject: id, name
	advideo_get_tagsTool := mcp.NewTool("advideo_get_tags",
		mcp.WithDescription("GET tags for AdVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for TaggableSubject objects. Available fields: id, name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_tagsTool)

	// advideo_get_thumbnails tool
	// Available fields for VideoThumbnail: height, id, is_preferred, name, scale, uri, width
	advideo_get_thumbnailsTool := mcp.NewTool("advideo_get_thumbnails",
		mcp.WithDescription("GET thumbnails for AdVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for VideoThumbnail objects. Available fields: height, id, is_preferred, name, scale, uri, width"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_thumbnailsTool)

	// advideo_post_thumbnails tool
	// Params object accepts: is_preferred (bool), source (file)
	advideo_post_thumbnailsTool := mcp.NewTool("advideo_post_thumbnails",
		mcp.WithDescription("POST thumbnails for AdVideo"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"is_preferred": map[string]any{
					"type":        "boolean",
					"description": "is_preferred parameter",
				},
				"source": map[string]any{
					"type":        "string",
					"description": "source parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: is_preferred (boolean), source (file) [required]"),
		),
	)
	tools = append(tools, advideo_post_thumbnailsTool)

	// advideo_get_video_insights tool
	// Available fields for InsightsResult: description, description_from_api_doc, id, name, period, title, values
	// Params object accepts: metric (list<Object>), period (videovideo_insights_period_enum_param), since (datetime), until (datetime)
	advideo_get_video_insightsTool := mcp.NewTool("advideo_get_video_insights",
		mcp.WithDescription("GET video_insights for AdVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"metric": map[string]any{
					"type":        "array",
					"description": "metric parameter",
					"items":       map[string]any{"type": "object"},
				},
				"period": map[string]any{
					"type":        "string",
					"description": "period parameter",
					"enum":        []string{"day", "days_28", "lifetime", "month", "total_over_range", "week"},
				},
				"since": map[string]any{
					"type":        "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type":        "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: metric (array<object>), period (enum) [day, days_28, lifetime, month, total_over_range, ...], since (datetime), until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for InsightsResult objects. Available fields: description, description_from_api_doc, id, name, period, title, values"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_video_insightsTool)

	// advideo_delete_ tool
	advideo_delete_Tool := mcp.NewTool("advideo_delete_",
		mcp.WithDescription("DELETE  for AdVideo"),
	)
	tools = append(tools, advideo_delete_Tool)

	// advideo_get_ tool
	// Available fields for AdVideo: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html, embeddable, event, expiration, format, from, icon, id, is_crosspost_video, is_crossposting_eligible, is_episode, is_instagram_eligible, is_reference_only, length, live_audience_count, live_status, music_video_copyright, permalink_url, picture, place, post_id, post_views, premiere_living_room_status, privacy, published, scheduled_publish_time, source, spherical, status, title, universal_video_id, updated_time, views
	advideo_get_Tool := mcp.NewTool("advideo_get_",
		mcp.WithDescription("GET  for AdVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdVideo objects. Available fields: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html (and 32 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, advideo_get_Tool)

	// advideo_post_ tool
	// Params object accepts: ad_breaks (list), allow_bm_crossposting (bool), allow_crossposting_for_pages (list<Object>), backdated_time (datetime), backdated_time_granularity (video_backdated_time_granularity), call_to_action (Object), content_category (video_content_category), content_tags (list<string>), custom_labels (list<string>), description (string), direct_share_status (unsigned int), embeddable (bool), expiration (Object), expire_now (bool), increment_play_count (bool), name (string), preferred_thumbnail_id (string), privacy (string), publish_to_news_feed (bool), publish_to_videos_tab (bool), published (bool), scheduled_publish_time (unsigned int), social_actions (bool), sponsor_id (string), sponsor_relationship (unsigned int), tags (list<string>), target (string), universal_video_id (string)
	advideo_post_Tool := mcp.NewTool("advideo_post_",
		mcp.WithDescription("POST  for AdVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"ad_breaks": map[string]any{
					"type":        "string",
					"description": "ad_breaks parameter",
				},
				"allow_bm_crossposting": map[string]any{
					"type":        "boolean",
					"description": "allow_bm_crossposting parameter",
				},
				"allow_crossposting_for_pages": map[string]any{
					"type":        "array",
					"description": "allow_crossposting_for_pages parameter",
					"items":       map[string]any{"type": "object"},
				},
				"backdated_time": map[string]any{
					"type":        "string",
					"description": "backdated_time parameter",
				},
				"backdated_time_granularity": map[string]any{
					"type":        "string",
					"description": "backdated_time_granularity parameter",
					"enum":        []string{"day", "hour", "min", "month", "none", "year"},
				},
				"call_to_action": map[string]any{
					"type":        "object",
					"description": "call_to_action parameter",
				},
				"content_category": map[string]any{
					"type":        "string",
					"description": "content_category parameter",
					"enum":        []string{"BEAUTY_FASHION", "BUSINESS", "CARS_TRUCKS", "COMEDY", "CUTE_ANIMALS", "ENTERTAINMENT", "FAMILY", "FOOD_HEALTH", "HOME", "LIFESTYLE", "MUSIC", "NEWS", "OTHER", "POLITICS", "SCIENCE", "SPORTS", "TECHNOLOGY", "VIDEO_GAMING"},
				},
				"content_tags": map[string]any{
					"type":        "array",
					"description": "content_tags parameter",
					"items":       map[string]any{"type": "string"},
				},
				"custom_labels": map[string]any{
					"type":        "array",
					"description": "custom_labels parameter",
					"items":       map[string]any{"type": "string"},
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"direct_share_status": map[string]any{
					"type":        "integer",
					"description": "direct_share_status parameter",
				},
				"embeddable": map[string]any{
					"type":        "boolean",
					"description": "embeddable parameter",
				},
				"expiration": map[string]any{
					"type":        "object",
					"description": "expiration parameter",
				},
				"expire_now": map[string]any{
					"type":        "boolean",
					"description": "expire_now parameter",
				},
				"increment_play_count": map[string]any{
					"type":        "boolean",
					"description": "increment_play_count parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"preferred_thumbnail_id": map[string]any{
					"type":        "string",
					"description": "preferred_thumbnail_id parameter",
				},
				"privacy": map[string]any{
					"type":        "string",
					"description": "privacy parameter",
				},
				"publish_to_news_feed": map[string]any{
					"type":        "boolean",
					"description": "publish_to_news_feed parameter",
				},
				"publish_to_videos_tab": map[string]any{
					"type":        "boolean",
					"description": "publish_to_videos_tab parameter",
				},
				"published": map[string]any{
					"type":        "boolean",
					"description": "published parameter",
				},
				"scheduled_publish_time": map[string]any{
					"type":        "integer",
					"description": "scheduled_publish_time parameter",
				},
				"social_actions": map[string]any{
					"type":        "boolean",
					"description": "social_actions parameter",
				},
				"sponsor_id": map[string]any{
					"type":        "string",
					"description": "sponsor_id parameter",
				},
				"sponsor_relationship": map[string]any{
					"type":        "integer",
					"description": "sponsor_relationship parameter",
				},
				"tags": map[string]any{
					"type":        "array",
					"description": "tags parameter",
					"items":       map[string]any{"type": "string"},
				},
				"target": map[string]any{
					"type":        "string",
					"description": "target parameter",
				},
				"universal_video_id": map[string]any{
					"type":        "string",
					"description": "universal_video_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: ad_breaks (list), allow_bm_crossposting (boolean), allow_crossposting_for_pages (array<object>), backdated_time (datetime), backdated_time_granularity (video_backdated_time_granularity) [day, hour, min, month, none, ...], call_to_action (object), content_category (video_content_category) [BEAUTY_FASHION, BUSINESS, CARS_TRUCKS, COMEDY, CUTE_ANIMALS, ...], content_tags (array<string>), custom_labels (array<string>), description (string), direct_share_status (integer), embeddable (boolean), expiration (object), expire_now (boolean), increment_play_count (boolean), name (string), preferred_thumbnail_id (string), privacy (string), publish_to_news_feed (boolean), publish_to_videos_tab (boolean), published (boolean), scheduled_publish_time (integer), social_actions (boolean), sponsor_id (string), sponsor_relationship (integer), tags (array<string>), target (string), universal_video_id (string)"),
		),
	)
	tools = append(tools, advideo_post_Tool)

	return tools
}

// AdVideo handlers

// HandleAdvideo_get_boost_ads_list handles the advideo_get_boost_ads_list tool with context-based auth
func HandleAdvideo_get_boost_ads_list(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_boost_ads_list(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_boost_ads_list: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_captions handles the advideo_get_captions tool with context-based auth
func HandleAdvideo_get_captions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_captions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_captions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_post_captions handles the advideo_post_captions tool with context-based auth
func HandleAdvideo_post_captions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Advideo_post_captions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_post_captions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_collaborators handles the advideo_get_collaborators tool with context-based auth
func HandleAdvideo_get_collaborators(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_collaborators(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_collaborators: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_post_collaborators handles the advideo_post_collaborators tool with context-based auth
func HandleAdvideo_post_collaborators(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Advideo_post_collaborators(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_post_collaborators: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_comments handles the advideo_get_comments tool with context-based auth
func HandleAdvideo_get_comments(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_comments(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_comments: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_post_comments handles the advideo_post_comments tool with context-based auth
func HandleAdvideo_post_comments(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Advideo_post_comments(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_post_comments: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_crosspost_shared_pages handles the advideo_get_crosspost_shared_pages tool with context-based auth
func HandleAdvideo_get_crosspost_shared_pages(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_crosspost_shared_pages(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_crosspost_shared_pages: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_post_gaming_clip_create handles the advideo_post_gaming_clip_create tool with context-based auth
func HandleAdvideo_post_gaming_clip_create(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Advideo_post_gaming_clip_create(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_post_gaming_clip_create: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_likes handles the advideo_get_likes tool with context-based auth
func HandleAdvideo_get_likes(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_likes(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_likes: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_post_likes handles the advideo_post_likes tool with context-based auth
func HandleAdvideo_post_likes(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Advideo_post_likes(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_post_likes: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_poll_settings handles the advideo_get_poll_settings tool with context-based auth
func HandleAdvideo_get_poll_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_poll_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_poll_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_polls handles the advideo_get_polls tool with context-based auth
func HandleAdvideo_get_polls(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_polls(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_polls: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_post_polls handles the advideo_post_polls tool with context-based auth
func HandleAdvideo_post_polls(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Advideo_post_polls(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_post_polls: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_sponsor_tags handles the advideo_get_sponsor_tags tool with context-based auth
func HandleAdvideo_get_sponsor_tags(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_sponsor_tags(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_sponsor_tags: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_tags handles the advideo_get_tags tool with context-based auth
func HandleAdvideo_get_tags(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_tags(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_tags: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_thumbnails handles the advideo_get_thumbnails tool with context-based auth
func HandleAdvideo_get_thumbnails(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_thumbnails(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_thumbnails: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_post_thumbnails handles the advideo_post_thumbnails tool with context-based auth
func HandleAdvideo_post_thumbnails(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Advideo_post_thumbnails(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_post_thumbnails: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_video_insights handles the advideo_get_video_insights tool with context-based auth
func HandleAdvideo_get_video_insights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_video_insights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_video_insights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_delete_ handles the advideo_delete_ tool with context-based auth
func HandleAdvideo_delete_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Advideo_delete_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_delete_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_get_ handles the advideo_get_ tool with context-based auth
func HandleAdvideo_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Advideo_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdvideo_post_ handles the advideo_post_ tool with context-based auth
func HandleAdvideo_post_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Advideo_post_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute advideo_post_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}
