// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetLiveVideoTools returns MCP tools for LiveVideo
func GetLiveVideoTools() []mcp.Tool {
	var tools []mcp.Tool

	// livevideo_get_blocked_users tool
	// Available fields for User: about, age_range, avatar_2d_profile_picture, birthday, client_business_id, community, cover, currency, education, email, favorite_athletes, favorite_teams, first_name, gender, hometown, id, id_for_avatars, inspirational_people, install_type, installed, is_guest_user, is_work_account, languages, last_name, link, local_news_megaphone_dismiss_status, local_news_subscription_status, locale, location, meeting_for, middle_name, name, name_format, payment_pricepoints, political, profile_pic, quotes, relationship_status, religion, shared_login_upgrade_required_by, short_name, significant_other, sports, supports_donate_button_in_live_video, third_party_id, timezone, token_for_business, updated_time, verified, video_upload_limits, website
	// Params object accepts: uid (string)
	livevideo_get_blocked_usersTool := mcp.NewTool("livevideo_get_blocked_users",
		mcp.WithDescription("GET blocked_users for LiveVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"uid": map[string]any{
					"type":        "string",
					"description": "uid parameter",
				},
			}),
			mcp.Description("Parameters object containing: uid (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for User objects. Available fields: about, age_range, avatar_2d_profile_picture, birthday, client_business_id, community, cover, currency, education, email, favorite_athletes, favorite_teams, first_name, gender, hometown (and 36 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, livevideo_get_blocked_usersTool)

	// livevideo_get_comments tool
	// Available fields for Comment: admin_creator, application, attachment, can_comment, can_hide, can_like, can_remove, can_reply_privately, comment_count, created_time, from, id, is_hidden, is_private, like_count, live_broadcast_timestamp, message, message_tags, object, parent, permalink_url, private_reply_conversation, user_likes
	// Params object accepts: filter (livevideocomments_filter_enum_param), live_filter (livevideocomments_live_filter_enum_param), order (livevideocomments_order_enum_param), since (datetime)
	livevideo_get_commentsTool := mcp.NewTool("livevideo_get_comments",
		mcp.WithDescription("GET comments for LiveVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"filter": map[string]any{
					"type":        "string",
					"description": "filter parameter",
					"enum":        []string{"stream", "toplevel"},
				},
				"live_filter": map[string]any{
					"type":        "string",
					"description": "live_filter parameter",
					"enum":        []string{"filter_low_quality", "no_filter"},
				},
				"order": map[string]any{
					"type":        "string",
					"description": "order parameter",
					"enum":        []string{"chronological", "reverse_chronological"},
				},
				"since": map[string]any{
					"type":        "string",
					"description": "since parameter",
				},
			}),
			mcp.Description("Parameters object containing: filter (enum) [stream, toplevel], live_filter (enum) [filter_low_quality, no_filter], order (enum) [chronological, reverse_chronological], since (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Comment objects. Available fields: admin_creator, application, attachment, can_comment, can_hide, can_like, can_remove, can_reply_privately, comment_count, created_time, from, id, is_hidden, is_private, like_count (and 8 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, livevideo_get_commentsTool)

	// livevideo_get_crosspost_shared_pages tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	livevideo_get_crosspost_shared_pagesTool := mcp.NewTool("livevideo_get_crosspost_shared_pages",
		mcp.WithDescription("GET crosspost_shared_pages for LiveVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, livevideo_get_crosspost_shared_pagesTool)

	// livevideo_get_crossposted_broadcasts tool
	// Available fields for LiveVideo: ad_break_config, ad_break_failure_reason, broadcast_start_time, copyright, creation_time, dash_ingest_url, dash_preview_url, description, embed_html, from, id, ingest_streams, is_manual_mode, is_reference_only, live_views, overlay_url, permalink_url, planned_start_time, recommended_encoder_settings, seconds_left, secure_stream_url, status, stream_url, targeting, title, total_views, video
	livevideo_get_crossposted_broadcastsTool := mcp.NewTool("livevideo_get_crossposted_broadcasts",
		mcp.WithDescription("GET crossposted_broadcasts for LiveVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for LiveVideo objects. Available fields: ad_break_config, ad_break_failure_reason, broadcast_start_time, copyright, creation_time, dash_ingest_url, dash_preview_url, description, embed_html, from, id, ingest_streams, is_manual_mode, is_reference_only, live_views (and 12 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, livevideo_get_crossposted_broadcastsTool)

	// livevideo_get_errors tool
	// Available fields for LiveVideoError: creation_time, error_code, error_message, error_type
	livevideo_get_errorsTool := mcp.NewTool("livevideo_get_errors",
		mcp.WithDescription("GET errors for LiveVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for LiveVideoError objects. Available fields: creation_time, error_code, error_message, error_type"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, livevideo_get_errorsTool)

	// livevideo_post_input_streams tool
	livevideo_post_input_streamsTool := mcp.NewTool("livevideo_post_input_streams",
		mcp.WithDescription("POST input_streams for LiveVideo"),
	)
	tools = append(tools, livevideo_post_input_streamsTool)

	// livevideo_get_polls tool
	// Available fields for VideoPoll: close_after_voting, default_open, id, question, show_gradient, show_results, status
	livevideo_get_pollsTool := mcp.NewTool("livevideo_get_polls",
		mcp.WithDescription("GET polls for LiveVideo"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for VideoPoll objects. Available fields: close_after_voting, default_open, id, question, show_gradient, show_results, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, livevideo_get_pollsTool)

	// livevideo_post_polls tool
	// Params object accepts: close_after_voting (bool), correct_option (unsigned int), default_open (bool), options (list<string>), question (string), show_gradient (bool), show_results (bool)
	livevideo_post_pollsTool := mcp.NewTool("livevideo_post_polls",
		mcp.WithDescription("POST polls for LiveVideo"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"close_after_voting": map[string]any{
					"type":        "boolean",
					"description": "close_after_voting parameter",
				},
				"correct_option": map[string]any{
					"type":        "integer",
					"description": "correct_option parameter",
				},
				"default_open": map[string]any{
					"type":        "boolean",
					"description": "default_open parameter",
				},
				"options": map[string]any{
					"type":        "array",
					"description": "options parameter",
					"required":    true,
					"items":       map[string]any{"type": "string"},
				},
				"question": map[string]any{
					"type":        "string",
					"description": "question parameter",
					"required":    true,
				},
				"show_gradient": map[string]any{
					"type":        "boolean",
					"description": "show_gradient parameter",
				},
				"show_results": map[string]any{
					"type":        "boolean",
					"description": "show_results parameter",
				},
			}),
			mcp.Description("Parameters object containing: close_after_voting (boolean), correct_option (integer), default_open (boolean), options (array<string>) [required], question (string) [required], show_gradient (boolean), show_results (boolean)"),
		),
	)
	tools = append(tools, livevideo_post_pollsTool)

	// livevideo_get_reactions tool
	// Available fields for Profile: can_post, id, link, name, pic, pic_crop, pic_large, pic_small, pic_square, profile_type, username
	// Params object accepts: type (livevideoreactions_type_enum_param)
	livevideo_get_reactionsTool := mcp.NewTool("livevideo_get_reactions",
		mcp.WithDescription("GET reactions for LiveVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"ANGRY", "CARE", "FIRE", "HAHA", "HUNDRED", "LIKE", "LOVE", "NONE", "PRIDE", "SAD", "THANKFUL", "WOW"},
				},
			}),
			mcp.Description("Parameters object containing: type (enum) [ANGRY, CARE, FIRE, HAHA, HUNDRED, ...]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Profile objects. Available fields: can_post, id, link, name, pic, pic_crop, pic_large, pic_small, pic_square, profile_type, username"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, livevideo_get_reactionsTool)

	// livevideo_delete_ tool
	livevideo_delete_Tool := mcp.NewTool("livevideo_delete_",
		mcp.WithDescription("DELETE  for LiveVideo"),
	)
	tools = append(tools, livevideo_delete_Tool)

	// livevideo_get_ tool
	// Available fields for LiveVideo: ad_break_config, ad_break_failure_reason, broadcast_start_time, copyright, creation_time, dash_ingest_url, dash_preview_url, description, embed_html, from, id, ingest_streams, is_manual_mode, is_reference_only, live_views, overlay_url, permalink_url, planned_start_time, recommended_encoder_settings, seconds_left, secure_stream_url, status, stream_url, targeting, title, total_views, video
	// Params object accepts: target_token (string)
	livevideo_get_Tool := mcp.NewTool("livevideo_get_",
		mcp.WithDescription("GET  for LiveVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"target_token": map[string]any{
					"type":        "string",
					"description": "target_token parameter",
				},
			}),
			mcp.Description("Parameters object containing: target_token (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for LiveVideo objects. Available fields: ad_break_config, ad_break_failure_reason, broadcast_start_time, copyright, creation_time, dash_ingest_url, dash_preview_url, description, embed_html, from, id, ingest_streams, is_manual_mode, is_reference_only, live_views (and 12 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, livevideo_get_Tool)

	// livevideo_post_ tool
	// Params object accepts: allow_bm_crossposting (bool), content_tags (list<string>), cross_share_to_group_ids (list<string>), crossposting_actions (list<map>), custom_labels (list<string>), description (string), direct_share_status (unsigned int), embeddable (bool), end_live_video (bool), event_params (Object), is_audio_only (bool), is_manual_mode (bool), live_comment_moderation_setting (list<livevideo_live_comment_moderation_setting>), master_ingest_stream_id (string), og_icon_id (string), og_phrase (string), persistent_stream_key_status (livevideo_persistent_stream_key_status), place (Object), planned_start_time (datetime), privacy (string), published (bool), schedule_custom_profile_image (file), schedule_feed_background_image (file), sponsor_id (string), sponsor_relationship (unsigned int), status (livevideo_status), stream_type (livevideo_stream_type), tags (list<int>), targeting (Object), title (string)
	livevideo_post_Tool := mcp.NewTool("livevideo_post_",
		mcp.WithDescription("POST  for LiveVideo"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"allow_bm_crossposting": map[string]any{
					"type":        "boolean",
					"description": "allow_bm_crossposting parameter",
				},
				"content_tags": map[string]any{
					"type":        "array",
					"description": "content_tags parameter",
					"items":       map[string]any{"type": "string"},
				},
				"cross_share_to_group_ids": map[string]any{
					"type":        "array",
					"description": "cross_share_to_group_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"crossposting_actions": map[string]any{
					"type":        "array",
					"description": "crossposting_actions parameter",
					"items":       map[string]any{"type": "object"},
				},
				"custom_labels": map[string]any{
					"type":        "array",
					"description": "custom_labels parameter",
					"items":       map[string]any{"type": "string"},
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"direct_share_status": map[string]any{
					"type":        "integer",
					"description": "direct_share_status parameter",
				},
				"embeddable": map[string]any{
					"type":        "boolean",
					"description": "embeddable parameter",
				},
				"end_live_video": map[string]any{
					"type":        "boolean",
					"description": "end_live_video parameter",
				},
				"event_params": map[string]any{
					"type":        "object",
					"description": "event_params parameter",
				},
				"is_audio_only": map[string]any{
					"type":        "boolean",
					"description": "is_audio_only parameter",
				},
				"is_manual_mode": map[string]any{
					"type":        "boolean",
					"description": "is_manual_mode parameter",
				},
				"live_comment_moderation_setting": map[string]any{
					"type":        "array",
					"description": "live_comment_moderation_setting parameter",
					"enum":        []string{"DEFAULT", "DISCUSSION", "FOLLOWED", "FOLLOWER", "NO_HYPERLINK", "PROTECTED_MODE", "RESTRICTED", "SLOW", "SUPPORTER", "TAGGED"},
					"items":       map[string]any{"type": "string"},
				},
				"master_ingest_stream_id": map[string]any{
					"type":        "string",
					"description": "master_ingest_stream_id parameter",
				},
				"og_icon_id": map[string]any{
					"type":        "string",
					"description": "og_icon_id parameter",
				},
				"og_phrase": map[string]any{
					"type":        "string",
					"description": "og_phrase parameter",
				},
				"persistent_stream_key_status": map[string]any{
					"type":        "string",
					"description": "persistent_stream_key_status parameter",
					"enum":        []string{"DISABLE", "ENABLE", "REGENERATE"},
				},
				"place": map[string]any{
					"type":        "object",
					"description": "place parameter",
				},
				"planned_start_time": map[string]any{
					"type":        "string",
					"description": "planned_start_time parameter",
				},
				"privacy": map[string]any{
					"type":        "string",
					"description": "privacy parameter",
				},
				"published": map[string]any{
					"type":        "boolean",
					"description": "published parameter",
				},
				"schedule_custom_profile_image": map[string]any{
					"type":        "string",
					"description": "schedule_custom_profile_image parameter",
				},
				"schedule_feed_background_image": map[string]any{
					"type":        "string",
					"description": "schedule_feed_background_image parameter",
				},
				"sponsor_id": map[string]any{
					"type":        "string",
					"description": "sponsor_id parameter",
				},
				"sponsor_relationship": map[string]any{
					"type":        "integer",
					"description": "sponsor_relationship parameter",
				},
				"status": map[string]any{
					"type":        "string",
					"description": "status parameter",
					"enum":        []string{"LIVE_NOW", "SCHEDULED_CANCELED", "SCHEDULED_LIVE", "SCHEDULED_UNPUBLISHED", "UNPUBLISHED"},
				},
				"stream_type": map[string]any{
					"type":        "string",
					"description": "stream_type parameter",
					"enum":        []string{"AMBIENT", "REGULAR"},
				},
				"tags": map[string]any{
					"type":        "array",
					"description": "tags parameter",
					"items":       map[string]any{"type": "integer"},
				},
				"targeting": map[string]any{
					"type":        "object",
					"description": "targeting parameter",
				},
				"title": map[string]any{
					"type":        "string",
					"description": "title parameter",
				},
			}),
			mcp.Description("Parameters object containing: allow_bm_crossposting (boolean), content_tags (array<string>), cross_share_to_group_ids (array<string>), crossposting_actions (array<object>), custom_labels (array<string>), description (string), direct_share_status (integer), embeddable (boolean), end_live_video (boolean), event_params (object), is_audio_only (boolean), is_manual_mode (boolean), live_comment_moderation_setting (array<livevideo_live_comment_moderation_setting>) [DEFAULT, DISCUSSION, FOLLOWED, FOLLOWER, NO_HYPERLINK, ...], master_ingest_stream_id (string), og_icon_id (string), og_phrase (string), persistent_stream_key_status (livevideo_persistent_stream_key_status) [DISABLE, ENABLE, REGENERATE], place (object), planned_start_time (datetime), privacy (string), published (boolean), schedule_custom_profile_image (file), schedule_feed_background_image (file), sponsor_id (string), sponsor_relationship (integer), status (livevideo_status) [LIVE_NOW, SCHEDULED_CANCELED, SCHEDULED_LIVE, SCHEDULED_UNPUBLISHED, UNPUBLISHED], stream_type (livevideo_stream_type) [AMBIENT, REGULAR], tags (array<integer>), targeting (object), title (string)"),
		),
	)
	tools = append(tools, livevideo_post_Tool)

	return tools
}

// LiveVideo handlers

// HandleLivevideo_get_blocked_users handles the livevideo_get_blocked_users tool with context-based auth
func HandleLivevideo_get_blocked_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Livevideo_get_blocked_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_get_blocked_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleLivevideo_get_comments handles the livevideo_get_comments tool with context-based auth
func HandleLivevideo_get_comments(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Livevideo_get_comments(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_get_comments: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleLivevideo_get_crosspost_shared_pages handles the livevideo_get_crosspost_shared_pages tool with context-based auth
func HandleLivevideo_get_crosspost_shared_pages(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Livevideo_get_crosspost_shared_pages(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_get_crosspost_shared_pages: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleLivevideo_get_crossposted_broadcasts handles the livevideo_get_crossposted_broadcasts tool with context-based auth
func HandleLivevideo_get_crossposted_broadcasts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Livevideo_get_crossposted_broadcasts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_get_crossposted_broadcasts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleLivevideo_get_errors handles the livevideo_get_errors tool with context-based auth
func HandleLivevideo_get_errors(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Livevideo_get_errors(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_get_errors: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleLivevideo_post_input_streams handles the livevideo_post_input_streams tool with context-based auth
func HandleLivevideo_post_input_streams(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Livevideo_post_input_streams(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_post_input_streams: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleLivevideo_get_polls handles the livevideo_get_polls tool with context-based auth
func HandleLivevideo_get_polls(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Livevideo_get_polls(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_get_polls: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleLivevideo_post_polls handles the livevideo_post_polls tool with context-based auth
func HandleLivevideo_post_polls(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Livevideo_post_polls(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_post_polls: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleLivevideo_get_reactions handles the livevideo_get_reactions tool with context-based auth
func HandleLivevideo_get_reactions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Livevideo_get_reactions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_get_reactions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleLivevideo_delete_ handles the livevideo_delete_ tool with context-based auth
func HandleLivevideo_delete_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Livevideo_delete_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_delete_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleLivevideo_get_ handles the livevideo_get_ tool with context-based auth
func HandleLivevideo_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Livevideo_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleLivevideo_post_ handles the livevideo_post_ tool with context-based auth
func HandleLivevideo_post_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewLiveVideoClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Livevideo_post_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute livevideo_post_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}
