// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetCommerceOrderTools returns MCP tools for CommerceOrder
func GetCommerceOrderTools() []mcp.Tool {
	var tools []mcp.Tool

	// commerceorder_post_acknowledge_order tool
	// Params object accepts: idempotency_key (string), merchant_order_reference (string)
	commerceorder_post_acknowledge_orderTool := mcp.NewTool("commerceorder_post_acknowledge_order",
		mcp.WithDescription("POST acknowledge_order for CommerceOrder"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"idempotency_key": map[string]any{
					"type":        "string",
					"description": "idempotency_key parameter",
					"required":    true,
				},
				"merchant_order_reference": map[string]any{
					"type":        "string",
					"description": "merchant_order_reference parameter",
				},
			}),
			mcp.Description("Parameters object containing: idempotency_key (string) [required], merchant_order_reference (string)"),
		),
	)
	tools = append(tools, commerceorder_post_acknowledge_orderTool)

	// commerceorder_get_cancellations tool
	commerceorder_get_cancellationsTool := mcp.NewTool("commerceorder_get_cancellations",
		mcp.WithDescription("GET cancellations for CommerceOrder"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commerceorder_get_cancellationsTool)

	// commerceorder_post_cancellations tool
	// Params object accepts: cancel_reason (map), idempotency_key (string), items (list<map>), restock_items (bool)
	commerceorder_post_cancellationsTool := mcp.NewTool("commerceorder_post_cancellations",
		mcp.WithDescription("POST cancellations for CommerceOrder"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"cancel_reason": map[string]any{
					"type":        "object",
					"description": "cancel_reason parameter",
				},
				"idempotency_key": map[string]any{
					"type":        "string",
					"description": "idempotency_key parameter",
					"required":    true,
				},
				"items": map[string]any{
					"type":        "array",
					"description": "items parameter",
					"items":       map[string]any{"type": "object"},
				},
				"restock_items": map[string]any{
					"type":        "boolean",
					"description": "restock_items parameter",
				},
			}),
			mcp.Description("Parameters object containing: cancel_reason (object), idempotency_key (string) [required], items (array<object>), restock_items (boolean)"),
		),
	)
	tools = append(tools, commerceorder_post_cancellationsTool)

	// commerceorder_post_item_updates tool
	// Params object accepts: items (list<map>), merchant_order_reference (string)
	commerceorder_post_item_updatesTool := mcp.NewTool("commerceorder_post_item_updates",
		mcp.WithDescription("POST item_updates for CommerceOrder"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"items": map[string]any{
					"type":        "array",
					"description": "items parameter",
					"required":    true,
					"items":       map[string]any{"type": "object"},
				},
				"merchant_order_reference": map[string]any{
					"type":        "string",
					"description": "merchant_order_reference parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: items (array<object>) [required], merchant_order_reference (string) [required]"),
		),
	)
	tools = append(tools, commerceorder_post_item_updatesTool)

	// commerceorder_get_items tool
	commerceorder_get_itemsTool := mcp.NewTool("commerceorder_get_items",
		mcp.WithDescription("GET items for CommerceOrder"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commerceorder_get_itemsTool)

	// commerceorder_get_payments tool
	commerceorder_get_paymentsTool := mcp.NewTool("commerceorder_get_payments",
		mcp.WithDescription("GET payments for CommerceOrder"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commerceorder_get_paymentsTool)

	// commerceorder_get_promotion_details tool
	commerceorder_get_promotion_detailsTool := mcp.NewTool("commerceorder_get_promotion_details",
		mcp.WithDescription("GET promotion_details for CommerceOrder"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commerceorder_get_promotion_detailsTool)

	// commerceorder_get_promotions tool
	commerceorder_get_promotionsTool := mcp.NewTool("commerceorder_get_promotions",
		mcp.WithDescription("GET promotions for CommerceOrder"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commerceorder_get_promotionsTool)

	// commerceorder_get_refunds tool
	commerceorder_get_refundsTool := mcp.NewTool("commerceorder_get_refunds",
		mcp.WithDescription("GET refunds for CommerceOrder"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commerceorder_get_refundsTool)

	// commerceorder_post_refunds tool
	// Params object accepts: adjustment_amount (map), deductions (list<map>), idempotency_key (string), items (list<map>), reason_code (commerceorderrefunds_reason_code_enum_param), reason_text (string), return_id (string), shipping (map)
	commerceorder_post_refundsTool := mcp.NewTool("commerceorder_post_refunds",
		mcp.WithDescription("POST refunds for CommerceOrder"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"adjustment_amount": map[string]any{
					"type":        "object",
					"description": "adjustment_amount parameter",
				},
				"deductions": map[string]any{
					"type":        "array",
					"description": "deductions parameter",
					"items":       map[string]any{"type": "object"},
				},
				"idempotency_key": map[string]any{
					"type":        "string",
					"description": "idempotency_key parameter",
					"required":    true,
				},
				"items": map[string]any{
					"type":        "array",
					"description": "items parameter",
					"items":       map[string]any{"type": "object"},
				},
				"reason_code": map[string]any{
					"type":        "string",
					"description": "reason_code parameter",
					"required":    true,
					"enum":        []string{"BUYERS_REMORSE", "DAMAGED_GOODS", "FACEBOOK_INITIATED", "NOT_AS_DESCRIBED", "QUALITY_ISSUE", "REFUND_COMPROMISED", "REFUND_FOR_RETURN", "REFUND_REASON_OTHER", "REFUND_SFI_FAKE", "REFUND_SFI_REAL", "WRONG_ITEM"},
				},
				"reason_text": map[string]any{
					"type":        "string",
					"description": "reason_text parameter",
				},
				"return_id": map[string]any{
					"type":        "string",
					"description": "return_id parameter",
				},
				"shipping": map[string]any{
					"type":        "object",
					"description": "shipping parameter",
				},
			}),
			mcp.Description("Parameters object containing: adjustment_amount (object), deductions (array<object>), idempotency_key (string) [required], items (array<object>), reason_code (enum) [BUYERS_REMORSE, DAMAGED_GOODS, FACEBOOK_INITIATED, NOT_AS_DESCRIBED, QUALITY_ISSUE, ...] [required], reason_text (string), return_id (string), shipping (object)"),
		),
	)
	tools = append(tools, commerceorder_post_refundsTool)

	// commerceorder_get_returns tool
	// Params object accepts: merchant_return_id (string), statuses (list<commerceorderreturns_statuses_enum_param>)
	commerceorder_get_returnsTool := mcp.NewTool("commerceorder_get_returns",
		mcp.WithDescription("GET returns for CommerceOrder"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"merchant_return_id": map[string]any{
					"type":        "string",
					"description": "merchant_return_id parameter",
				},
				"statuses": map[string]any{
					"type":        "array",
					"description": "statuses parameter",
					"enum":        []string{"APPROVED", "DISAPPROVED", "MERCHANT_MARKED_COMPLETED", "REFUNDED", "REQUESTED"},
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: merchant_return_id (string), statuses (array<enum>) [APPROVED, DISAPPROVED, MERCHANT_MARKED_COMPLETED, REFUNDED, REQUESTED]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commerceorder_get_returnsTool)

	// commerceorder_post_returns tool
	// Params object accepts: items (list<map>), merchant_return_id (string), return_message (string), update (map)
	commerceorder_post_returnsTool := mcp.NewTool("commerceorder_post_returns",
		mcp.WithDescription("POST returns for CommerceOrder"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"items": map[string]any{
					"type":        "array",
					"description": "items parameter",
					"required":    true,
					"items":       map[string]any{"type": "object"},
				},
				"merchant_return_id": map[string]any{
					"type":        "string",
					"description": "merchant_return_id parameter",
				},
				"return_message": map[string]any{
					"type":        "string",
					"description": "return_message parameter",
				},
				"update": map[string]any{
					"type":        "object",
					"description": "update parameter",
				},
			}),
			mcp.Description("Parameters object containing: items (array<object>) [required], merchant_return_id (string), return_message (string), update (object)"),
		),
	)
	tools = append(tools, commerceorder_post_returnsTool)

	// commerceorder_get_shipments tool
	commerceorder_get_shipmentsTool := mcp.NewTool("commerceorder_get_shipments",
		mcp.WithDescription("GET shipments for CommerceOrder"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commerceorder_get_shipmentsTool)

	// commerceorder_post_shipments tool
	// Params object accepts: external_redemption_link (string), external_shipment_id (string), fulfillment (map), idempotency_key (string), items (list<map>), merchant_order_reference (string), shipment_origin_postal_code (string), shipping_tax_details (map), should_use_default_fulfillment_location (bool), tracking_info (map)
	commerceorder_post_shipmentsTool := mcp.NewTool("commerceorder_post_shipments",
		mcp.WithDescription("POST shipments for CommerceOrder"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"external_redemption_link": map[string]any{
					"type":        "string",
					"description": "external_redemption_link parameter",
				},
				"external_shipment_id": map[string]any{
					"type":        "string",
					"description": "external_shipment_id parameter",
				},
				"fulfillment": map[string]any{
					"type":        "object",
					"description": "fulfillment parameter",
				},
				"idempotency_key": map[string]any{
					"type":        "string",
					"description": "idempotency_key parameter",
					"required":    true,
				},
				"items": map[string]any{
					"type":        "array",
					"description": "items parameter",
					"items":       map[string]any{"type": "object"},
				},
				"merchant_order_reference": map[string]any{
					"type":        "string",
					"description": "merchant_order_reference parameter",
				},
				"shipment_origin_postal_code": map[string]any{
					"type":        "string",
					"description": "shipment_origin_postal_code parameter",
				},
				"shipping_tax_details": map[string]any{
					"type":        "object",
					"description": "shipping_tax_details parameter",
				},
				"should_use_default_fulfillment_location": map[string]any{
					"type":        "boolean",
					"description": "should_use_default_fulfillment_location parameter",
				},
				"tracking_info": map[string]any{
					"type":        "object",
					"description": "tracking_info parameter",
				},
			}),
			mcp.Description("Parameters object containing: external_redemption_link (string), external_shipment_id (string), fulfillment (object), idempotency_key (string) [required], items (array<object>), merchant_order_reference (string), shipment_origin_postal_code (string), shipping_tax_details (object), should_use_default_fulfillment_location (boolean), tracking_info (object)"),
		),
	)
	tools = append(tools, commerceorder_post_shipmentsTool)

	// commerceorder_post_update_shipment tool
	// Params object accepts: external_shipment_id (string), fulfillment_id (string), idempotency_key (string), shipment_id (string), tracking_info (map)
	commerceorder_post_update_shipmentTool := mcp.NewTool("commerceorder_post_update_shipment",
		mcp.WithDescription("POST update_shipment for CommerceOrder"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"external_shipment_id": map[string]any{
					"type":        "string",
					"description": "external_shipment_id parameter",
				},
				"fulfillment_id": map[string]any{
					"type":        "string",
					"description": "fulfillment_id parameter",
				},
				"idempotency_key": map[string]any{
					"type":        "string",
					"description": "idempotency_key parameter",
					"required":    true,
				},
				"shipment_id": map[string]any{
					"type":        "string",
					"description": "shipment_id parameter",
				},
				"tracking_info": map[string]any{
					"type":        "object",
					"description": "tracking_info parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: external_shipment_id (string), fulfillment_id (string), idempotency_key (string) [required], shipment_id (string), tracking_info (object) [required]"),
		),
	)
	tools = append(tools, commerceorder_post_update_shipmentTool)

	// commerceorder_get_ tool
	// Available fields for CommerceOrder: buyer_details, channel, contains_bopis_items, created, estimated_payment_details, id, is_group_buy, is_test_order, last_updated, merchant_order_id, order_status, pre_order_details, selected_shipping_option, ship_by_date, shipping_address
	commerceorder_get_Tool := mcp.NewTool("commerceorder_get_",
		mcp.WithDescription("GET  for CommerceOrder"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CommerceOrder objects. Available fields: buyer_details, channel, contains_bopis_items, created, estimated_payment_details, id, is_group_buy, is_test_order, last_updated, merchant_order_id, order_status, pre_order_details, selected_shipping_option, ship_by_date, shipping_address"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commerceorder_get_Tool)

	return tools
}

// CommerceOrder handlers

// HandleCommerceorder_post_acknowledge_order handles the commerceorder_post_acknowledge_order tool with context-based auth
func HandleCommerceorder_post_acknowledge_order(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Commerceorder_post_acknowledge_order(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_post_acknowledge_order: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_get_cancellations handles the commerceorder_get_cancellations tool with context-based auth
func HandleCommerceorder_get_cancellations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commerceorder_get_cancellations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_get_cancellations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_post_cancellations handles the commerceorder_post_cancellations tool with context-based auth
func HandleCommerceorder_post_cancellations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Commerceorder_post_cancellations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_post_cancellations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_post_item_updates handles the commerceorder_post_item_updates tool with context-based auth
func HandleCommerceorder_post_item_updates(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Commerceorder_post_item_updates(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_post_item_updates: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_get_items handles the commerceorder_get_items tool with context-based auth
func HandleCommerceorder_get_items(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commerceorder_get_items(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_get_items: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_get_payments handles the commerceorder_get_payments tool with context-based auth
func HandleCommerceorder_get_payments(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commerceorder_get_payments(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_get_payments: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_get_promotion_details handles the commerceorder_get_promotion_details tool with context-based auth
func HandleCommerceorder_get_promotion_details(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commerceorder_get_promotion_details(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_get_promotion_details: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_get_promotions handles the commerceorder_get_promotions tool with context-based auth
func HandleCommerceorder_get_promotions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commerceorder_get_promotions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_get_promotions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_get_refunds handles the commerceorder_get_refunds tool with context-based auth
func HandleCommerceorder_get_refunds(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commerceorder_get_refunds(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_get_refunds: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_post_refunds handles the commerceorder_post_refunds tool with context-based auth
func HandleCommerceorder_post_refunds(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Commerceorder_post_refunds(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_post_refunds: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_get_returns handles the commerceorder_get_returns tool with context-based auth
func HandleCommerceorder_get_returns(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commerceorder_get_returns(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_get_returns: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_post_returns handles the commerceorder_post_returns tool with context-based auth
func HandleCommerceorder_post_returns(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Commerceorder_post_returns(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_post_returns: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_get_shipments handles the commerceorder_get_shipments tool with context-based auth
func HandleCommerceorder_get_shipments(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commerceorder_get_shipments(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_get_shipments: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_post_shipments handles the commerceorder_post_shipments tool with context-based auth
func HandleCommerceorder_post_shipments(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Commerceorder_post_shipments(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_post_shipments: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_post_update_shipment handles the commerceorder_post_update_shipment tool with context-based auth
func HandleCommerceorder_post_update_shipment(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Commerceorder_post_update_shipment(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_post_update_shipment: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommerceorder_get_ handles the commerceorder_get_ tool with context-based auth
func HandleCommerceorder_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceOrderClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commerceorder_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commerceorder_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}
