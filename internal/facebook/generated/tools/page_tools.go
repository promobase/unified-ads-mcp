// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetPageTools returns MCP tools for Page
func GetPageTools() []mcp.Tool {
	var tools []mcp.Tool


	// page_get_ab_tests tool
	// Available fields for PagePostExperiment: auto_resolve_settings, control_video_id, creation_time, creator, declared_winning_time, declared_winning_video_id, description, experiment_video_ids, id, insight_snapshots, name, optimization_goal, publish_status, publish_time, scheduled_experiment_timestamp, updated_time
	page_get_ab_testsTool := mcp.NewTool("page_get_ab_tests",
		mcp.WithDescription("GET ab_tests for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PagePostExperiment objects. Available fields: auto_resolve_settings, control_video_id, creation_time, creator, declared_winning_time, declared_winning_video_id, description, experiment_video_ids, id, insight_snapshots, name, optimization_goal, publish_status, publish_time, scheduled_experiment_timestamp (and 1 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_ab_testsTool)

	// page_post_ab_tests tool
	// Params object accepts: control_video_id (string), description (string), duration (unsigned int), experiment_video_ids (list<string>), name (string), optimization_goal (pageab_tests_optimization_goal_enum_param), scheduled_experiment_timestamp (unsigned int)
	page_post_ab_testsTool := mcp.NewTool("page_post_ab_tests",
		mcp.WithDescription("POST ab_tests for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"control_video_id": map[string]any{
					"type": "string",
					"description": "control_video_id parameter",
					"required": true,
				},
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
					"required": true,
				},
				"duration": map[string]any{
					"type": "integer",
					"description": "duration parameter",
					"required": true,
				},
				"experiment_video_ids": map[string]any{
					"type": "array",
					"description": "experiment_video_ids parameter",
					"required": true,
					"items": map[string]any{"type": "string"},
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
					"required": true,
				},
				"optimization_goal": map[string]any{
					"type": "string",
					"description": "optimization_goal parameter",
					"required": true,
					"enum": []string{ "AUTO_RESOLVE_TO_CONTROL", "AVG_TIME_WATCHED", "COMMENTS", "IMPRESSIONS", "IMPRESSIONS_UNIQUE", "LINK_CLICKS", "OTHER", "REACTIONS", "REELS_PLAYS", "SHARES", "VIDEO_VIEWS_60S" },
				},
				"scheduled_experiment_timestamp": map[string]any{
					"type": "integer",
					"description": "scheduled_experiment_timestamp parameter",
				},
			}),
			mcp.Description("Parameters object containing: control_video_id (string) [required], description (string) [required], duration (integer) [required], experiment_video_ids (array<string>) [required], name (string) [required], optimization_goal (enum) [AUTO_RESOLVE_TO_CONTROL, AVG_TIME_WATCHED, COMMENTS, IMPRESSIONS, IMPRESSIONS_UNIQUE, ...] [required], scheduled_experiment_timestamp (integer)"),
		),
	)
	tools = append(tools, page_post_ab_testsTool)

	// page_post_acknowledge_orders tool
	// Params object accepts: idempotency_key (string), orders (list<map>)
	page_post_acknowledge_ordersTool := mcp.NewTool("page_post_acknowledge_orders",
		mcp.WithDescription("POST acknowledge_orders for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"idempotency_key": map[string]any{
					"type": "string",
					"description": "idempotency_key parameter",
					"required": true,
				},
				"orders": map[string]any{
					"type": "array",
					"description": "orders parameter",
					"required": true,
					"items": map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: idempotency_key (string) [required], orders (array<object>) [required]"),
		),
	)
	tools = append(tools, page_post_acknowledge_ordersTool)

	// page_get_ads_posts tool
	// Available fields for PagePost: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting, from, full_picture, height, icon, id, instagram_eligibility, is_app_share, is_eligible_for_promotion, is_expired, is_hidden, is_inline_created, is_instagram_eligible, is_popular, is_published, is_spherical, message, message_tags, multi_share_end_card, multi_share_optimized, parent_id, permalink_url, picture, place, privacy, promotable_id, promotion_status, properties, scheduled_publish_time, shares, status_type, story, story_tags, subscribed, target, targeting, timeline_visibility, updated_time, via, video_buying_eligibility, width
	// Params object accepts: exclude_dynamic_ads (bool), include_inline_create (bool), since (datetime), until (datetime)
	page_get_ads_postsTool := mcp.NewTool("page_get_ads_posts",
		mcp.WithDescription("GET ads_posts for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"exclude_dynamic_ads": map[string]any{
					"type": "boolean",
					"description": "exclude_dynamic_ads parameter",
				},
				"include_inline_create": map[string]any{
					"type": "boolean",
					"description": "include_inline_create parameter",
				},
				"since": map[string]any{
					"type": "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type": "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: exclude_dynamic_ads (boolean), include_inline_create (boolean), since (datetime), until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PagePost objects. Available fields: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting (and 40 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_ads_postsTool)

	// page_delete_agencies tool
	// Params object accepts: business (string)
	page_delete_agenciesTool := mcp.NewTool("page_delete_agencies",
		mcp.WithDescription("DELETE agencies for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type": "string",
					"description": "business parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required]"),
		),
	)
	tools = append(tools, page_delete_agenciesTool)

	// page_get_agencies tool
	// Available fields for Business: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id, two_factor_type, updated_by, updated_time, user_access_expire_time, verification_status, vertical, vertical_id
	page_get_agenciesTool := mcp.NewTool("page_get_agencies",
		mcp.WithDescription("GET agencies for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Business objects. Available fields: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id (and 7 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_agenciesTool)

	// page_post_agencies tool
	// Params object accepts: business (string), permitted_tasks (list<pageagencies_permitted_tasks_enum_param>)
	page_post_agenciesTool := mcp.NewTool("page_post_agencies",
		mcp.WithDescription("POST agencies for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type": "string",
					"description": "business parameter",
					"required": true,
				},
				"permitted_tasks": map[string]any{
					"type": "array",
					"description": "permitted_tasks parameter",
					"enum": []string{ "ADVERTISE", "ANALYZE", "CASHIER_ROLE", "CREATE_CONTENT", "GLOBAL_STRUCTURE_MANAGEMENT", "MANAGE", "MANAGE_JOBS", "MANAGE_LEADS", "MESSAGING", "MODERATE", "MODERATE_COMMUNITY", "PAGES_MESSAGING", "PAGES_MESSAGING_SUBSCRIPTIONS", "PROFILE_PLUS_ADVERTISE", "PROFILE_PLUS_ANALYZE", "PROFILE_PLUS_CREATE_CONTENT", "PROFILE_PLUS_FACEBOOK_ACCESS", "PROFILE_PLUS_FULL_CONTROL", "PROFILE_PLUS_MANAGE", "PROFILE_PLUS_MANAGE_LEADS", "PROFILE_PLUS_MESSAGING", "PROFILE_PLUS_MODERATE", "PROFILE_PLUS_MODERATE_DELEGATE_COMMUNITY", "PROFILE_PLUS_REVENUE", "READ_PAGE_MAILBOXES", "VIEW_MONETIZATION_INSIGHTS" },
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required], permitted_tasks (array<enum>) [ADVERTISE, ANALYZE, CASHIER_ROLE, CREATE_CONTENT, GLOBAL_STRUCTURE_MANAGEMENT, ...]"),
		),
	)
	tools = append(tools, page_post_agenciesTool)

	// page_get_albums tool
	// Available fields for Album: backdated_time, backdated_time_granularity, can_backdate, can_upload, count, cover_photo, created_time, description, edit_link, event, from, id, is_user_facing, link, location, modified_major, name, photo_count, place, privacy, type, updated_time, video_count
	page_get_albumsTool := mcp.NewTool("page_get_albums",
		mcp.WithDescription("GET albums for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Album objects. Available fields: backdated_time, backdated_time_granularity, can_backdate, can_upload, count, cover_photo, created_time, description, edit_link, event, from, id, is_user_facing, link, location (and 8 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_albumsTool)

	// page_get_ar_experience tool
	// Available fields for ArAdsDataContainer: camera_facing_override, creation_time, effect, id, is_published, last_modified_time, name
	page_get_ar_experienceTool := mcp.NewTool("page_get_ar_experience",
		mcp.WithDescription("GET ar_experience for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ArAdsDataContainer objects. Available fields: camera_facing_override, creation_time, effect, id, is_published, last_modified_time, name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_ar_experienceTool)

	// page_delete_assigned_users tool
	// Params object accepts: user (int)
	page_delete_assigned_usersTool := mcp.NewTool("page_delete_assigned_users",
		mcp.WithDescription("DELETE assigned_users for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"user": map[string]any{
					"type": "integer",
					"description": "user parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: user (integer) [required]"),
		),
	)
	tools = append(tools, page_delete_assigned_usersTool)

	// page_get_assigned_users tool
	// Available fields for AssignedUser: business, id, name, user_type
	// Params object accepts: business (string)
	page_get_assigned_usersTool := mcp.NewTool("page_get_assigned_users",
		mcp.WithDescription("GET assigned_users for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type": "string",
					"description": "business parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AssignedUser objects. Available fields: business, id, name, user_type"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_assigned_usersTool)

	// page_post_assigned_users tool
	// Params object accepts: tasks (list<pageassigned_users_tasks_enum_param>), user (int)
	page_post_assigned_usersTool := mcp.NewTool("page_post_assigned_users",
		mcp.WithDescription("POST assigned_users for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"tasks": map[string]any{
					"type": "array",
					"description": "tasks parameter",
					"enum": []string{ "ADVERTISE", "ANALYZE", "CASHIER_ROLE", "CREATE_CONTENT", "GLOBAL_STRUCTURE_MANAGEMENT", "MANAGE", "MANAGE_JOBS", "MANAGE_LEADS", "MESSAGING", "MODERATE", "MODERATE_COMMUNITY", "PAGES_MESSAGING", "PAGES_MESSAGING_SUBSCRIPTIONS", "PROFILE_PLUS_ADVERTISE", "PROFILE_PLUS_ANALYZE", "PROFILE_PLUS_CREATE_CONTENT", "PROFILE_PLUS_FACEBOOK_ACCESS", "PROFILE_PLUS_FULL_CONTROL", "PROFILE_PLUS_MANAGE", "PROFILE_PLUS_MANAGE_LEADS", "PROFILE_PLUS_MESSAGING", "PROFILE_PLUS_MODERATE", "PROFILE_PLUS_MODERATE_DELEGATE_COMMUNITY", "PROFILE_PLUS_REVENUE", "READ_PAGE_MAILBOXES", "VIEW_MONETIZATION_INSIGHTS" },
					"items": map[string]any{"type": "string"},
				},
				"user": map[string]any{
					"type": "integer",
					"description": "user parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: tasks (array<enum>) [ADVERTISE, ANALYZE, CASHIER_ROLE, CREATE_CONTENT, GLOBAL_STRUCTURE_MANAGEMENT, ...], user (integer) [required]"),
		),
	)
	tools = append(tools, page_post_assigned_usersTool)

	// page_delete_blocked tool
	// Params object accepts: asid (string), psid (int), uid (int), user (int)
	page_delete_blockedTool := mcp.NewTool("page_delete_blocked",
		mcp.WithDescription("DELETE blocked for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"asid": map[string]any{
					"type": "string",
					"description": "asid parameter",
				},
				"psid": map[string]any{
					"type": "integer",
					"description": "psid parameter",
				},
				"uid": map[string]any{
					"type": "integer",
					"description": "uid parameter",
				},
				"user": map[string]any{
					"type": "integer",
					"description": "user parameter",
				},
			}),
			mcp.Description("Parameters object containing: asid (string), psid (integer), uid (integer), user (integer)"),
		),
	)
	tools = append(tools, page_delete_blockedTool)

	// page_get_blocked tool
	// Available fields for Profile: can_post, id, link, name, pic, pic_crop, pic_large, pic_small, pic_square, profile_type, username
	// Params object accepts: uid (int), user (int)
	page_get_blockedTool := mcp.NewTool("page_get_blocked",
		mcp.WithDescription("GET blocked for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"uid": map[string]any{
					"type": "integer",
					"description": "uid parameter",
				},
				"user": map[string]any{
					"type": "integer",
					"description": "user parameter",
				},
			}),
			mcp.Description("Parameters object containing: uid (integer), user (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Profile objects. Available fields: can_post, id, link, name, pic, pic_crop, pic_large, pic_small, pic_square, profile_type, username"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_blockedTool)

	// page_post_blocked tool
	// Params object accepts: asid (list<string>), psid (list<int>), uid (list<string>), user (list<string>)
	page_post_blockedTool := mcp.NewTool("page_post_blocked",
		mcp.WithDescription("POST blocked for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"asid": map[string]any{
					"type": "array",
					"description": "asid parameter",
					"items": map[string]any{"type": "string"},
				},
				"psid": map[string]any{
					"type": "array",
					"description": "psid parameter",
					"items": map[string]any{"type": "integer"},
				},
				"uid": map[string]any{
					"type": "array",
					"description": "uid parameter",
					"items": map[string]any{"type": "string"},
				},
				"user": map[string]any{
					"type": "array",
					"description": "user parameter",
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: asid (array<string>), psid (array<integer>), uid (array<string>), user (array<string>)"),
		),
	)
	tools = append(tools, page_post_blockedTool)

	// page_post_business_data tool
	// Params object accepts: data (list<string>), partner_agent (string), processing_type (string)
	page_post_business_dataTool := mcp.NewTool("page_post_business_data",
		mcp.WithDescription("POST business_data for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"data": map[string]any{
					"type": "array",
					"description": "data parameter",
					"required": true,
					"items": map[string]any{"type": "string"},
				},
				"partner_agent": map[string]any{
					"type": "string",
					"description": "partner_agent parameter",
					"required": true,
				},
				"processing_type": map[string]any{
					"type": "string",
					"description": "processing_type parameter",
				},
			}),
			mcp.Description("Parameters object containing: data (array<string>) [required], partner_agent (string) [required], processing_type (string)"),
		),
	)
	tools = append(tools, page_post_business_dataTool)

	// page_get_businessprojects tool
	// Available fields for BusinessProject: business, created_time, creator, id, name
	// Params object accepts: business (string)
	page_get_businessprojectsTool := mcp.NewTool("page_get_businessprojects",
		mcp.WithDescription("GET businessprojects for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type": "string",
					"description": "business parameter",
				},
			}),
			mcp.Description("Parameters object containing: business (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for BusinessProject objects. Available fields: business, created_time, creator, id, name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_businessprojectsTool)

	// page_get_call_to_actions tool
	// Available fields for PageCallToAction: android_app, android_deeplink, android_destination_type, android_package_name, android_url, created_time, email_address, from, id, intl_number_with_plus, iphone_app, iphone_deeplink, iphone_destination_type, iphone_url, status, type, updated_time, web_destination_type, web_url
	page_get_call_to_actionsTool := mcp.NewTool("page_get_call_to_actions",
		mcp.WithDescription("GET call_to_actions for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PageCallToAction objects. Available fields: android_app, android_deeplink, android_destination_type, android_package_name, android_url, created_time, email_address, from, id, intl_number_with_plus, iphone_app, iphone_deeplink, iphone_destination_type, iphone_url, status (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_call_to_actionsTool)

	// page_post_calls tool
	// Params object accepts: action (pagecalls_action_enum_param), call_id (string), platform (pagecalls_platform_enum_param), session (map), to (string)
	page_post_callsTool := mcp.NewTool("page_post_calls",
		mcp.WithDescription("POST calls for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"action": map[string]any{
					"type": "string",
					"description": "action parameter",
					"required": true,
					"enum": []string{ "ACCEPT", "CONNECT", "MEDIA_UPDATE", "REJECT", "TERMINATE" },
				},
				"call_id": map[string]any{
					"type": "string",
					"description": "call_id parameter",
				},
				"platform": map[string]any{
					"type": "string",
					"description": "platform parameter",
					"enum": []string{ "INSTAGRAM", "MESSENGER" },
				},
				"session": map[string]any{
					"type": "object",
					"description": "session parameter",
				},
				"to": map[string]any{
					"type": "string",
					"description": "to parameter",
				},
			}),
			mcp.Description("Parameters object containing: action (enum) [ACCEPT, CONNECT, MEDIA_UPDATE, REJECT, TERMINATE] [required], call_id (string), platform (enum) [INSTAGRAM, MESSENGER], session (object), to (string)"),
		),
	)
	tools = append(tools, page_post_callsTool)

	// page_get_canvas_elements tool
	// Available fields for CanvasBodyElement: element
	page_get_canvas_elementsTool := mcp.NewTool("page_get_canvas_elements",
		mcp.WithDescription("GET canvas_elements for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CanvasBodyElement objects. Available fields: element"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_canvas_elementsTool)

	// page_post_canvas_elements tool
	// Params object accepts: canvas_button (Object), canvas_carousel (Object), canvas_footer (Object), canvas_header (Object), canvas_lead_form (Object), canvas_photo (Object), canvas_product_list (Object), canvas_product_set (Object), canvas_store_locator (Object), canvas_template_video (Object), canvas_text (Object), canvas_video (Object)
	page_post_canvas_elementsTool := mcp.NewTool("page_post_canvas_elements",
		mcp.WithDescription("POST canvas_elements for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"canvas_button": map[string]any{
					"type": "object",
					"description": "canvas_button parameter",
				},
				"canvas_carousel": map[string]any{
					"type": "object",
					"description": "canvas_carousel parameter",
				},
				"canvas_footer": map[string]any{
					"type": "object",
					"description": "canvas_footer parameter",
				},
				"canvas_header": map[string]any{
					"type": "object",
					"description": "canvas_header parameter",
				},
				"canvas_lead_form": map[string]any{
					"type": "object",
					"description": "canvas_lead_form parameter",
				},
				"canvas_photo": map[string]any{
					"type": "object",
					"description": "canvas_photo parameter",
				},
				"canvas_product_list": map[string]any{
					"type": "object",
					"description": "canvas_product_list parameter",
				},
				"canvas_product_set": map[string]any{
					"type": "object",
					"description": "canvas_product_set parameter",
				},
				"canvas_store_locator": map[string]any{
					"type": "object",
					"description": "canvas_store_locator parameter",
				},
				"canvas_template_video": map[string]any{
					"type": "object",
					"description": "canvas_template_video parameter",
				},
				"canvas_text": map[string]any{
					"type": "object",
					"description": "canvas_text parameter",
				},
				"canvas_video": map[string]any{
					"type": "object",
					"description": "canvas_video parameter",
				},
			}),
			mcp.Description("Parameters object containing: canvas_button (object), canvas_carousel (object), canvas_footer (object), canvas_header (object), canvas_lead_form (object), canvas_photo (object), canvas_product_list (object), canvas_product_set (object), canvas_store_locator (object), canvas_template_video (object), canvas_text (object), canvas_video (object)"),
		),
	)
	tools = append(tools, page_post_canvas_elementsTool)

	// page_get_canvases tool
	// Available fields for Canvas: background_color, body_elements, business_id, canvas_link, collection_hero_image, collection_hero_video, collection_thumbnails, dynamic_setting, element_payload, elements, fb_body_elements, id, is_hidden, is_published, last_editor, linked_documents, name, owner, property_list, source_template, store_url, style_list, tags, ui_property_list, unused_body_elements, update_time, use_retailer_item_ids
	// Params object accepts: is_hidden (bool), is_published (bool)
	page_get_canvasesTool := mcp.NewTool("page_get_canvases",
		mcp.WithDescription("GET canvases for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"is_hidden": map[string]any{
					"type": "boolean",
					"description": "is_hidden parameter",
				},
				"is_published": map[string]any{
					"type": "boolean",
					"description": "is_published parameter",
				},
			}),
			mcp.Description("Parameters object containing: is_hidden (boolean), is_published (boolean)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Canvas objects. Available fields: background_color, body_elements, business_id, canvas_link, collection_hero_image, collection_hero_video, collection_thumbnails, dynamic_setting, element_payload, elements, fb_body_elements, id, is_hidden, is_published, last_editor (and 12 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_canvasesTool)

	// page_post_canvases tool
	// Params object accepts: background_color (string), body_element_ids (list<string>), enable_swipe_to_open (bool), is_hidden (bool), is_published (bool), name (string), source_template_id (string)
	page_post_canvasesTool := mcp.NewTool("page_post_canvases",
		mcp.WithDescription("POST canvases for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"background_color": map[string]any{
					"type": "string",
					"description": "background_color parameter",
				},
				"body_element_ids": map[string]any{
					"type": "array",
					"description": "body_element_ids parameter",
					"items": map[string]any{"type": "string"},
				},
				"enable_swipe_to_open": map[string]any{
					"type": "boolean",
					"description": "enable_swipe_to_open parameter",
				},
				"is_hidden": map[string]any{
					"type": "boolean",
					"description": "is_hidden parameter",
				},
				"is_published": map[string]any{
					"type": "boolean",
					"description": "is_published parameter",
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
				},
				"source_template_id": map[string]any{
					"type": "string",
					"description": "source_template_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: background_color (string), body_element_ids (array<string>), enable_swipe_to_open (boolean), is_hidden (boolean), is_published (boolean), name (string), source_template_id (string)"),
		),
	)
	tools = append(tools, page_post_canvasesTool)

	// page_get_chat_plugin tool
	// Available fields for ChatPlugin: alignment, desktop_bottom_spacing, desktop_side_spacing, entry_point_icon, entry_point_label, greeting_dialog_display, guest_chat_mode, mobile_bottom_spacing, mobile_chat_display, mobile_side_spacing, theme_color, welcome_screen_greeting
	page_get_chat_pluginTool := mcp.NewTool("page_get_chat_plugin",
		mcp.WithDescription("GET chat_plugin for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ChatPlugin objects. Available fields: alignment, desktop_bottom_spacing, desktop_side_spacing, entry_point_icon, entry_point_label, greeting_dialog_display, guest_chat_mode, mobile_bottom_spacing, mobile_chat_display, mobile_side_spacing, theme_color, welcome_screen_greeting"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_chat_pluginTool)

	// page_get_commerce_merchant_settings tool
	// Available fields for CommerceMerchantSettings: checkout_config, checkout_message, contact_email, cta, display_name, facebook_channel, id, instagram_channel, korea_ftc_listing, merchant_page, merchant_status, onsite_commerce_merchant, payment_provider, privacy_policy_localized, return_policy_localized, review_rejection_messages, review_rejection_reasons, terms
	page_get_commerce_merchant_settingsTool := mcp.NewTool("page_get_commerce_merchant_settings",
		mcp.WithDescription("GET commerce_merchant_settings for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CommerceMerchantSettings objects. Available fields: checkout_config, checkout_message, contact_email, cta, display_name, facebook_channel, id, instagram_channel, korea_ftc_listing, merchant_page, merchant_status, onsite_commerce_merchant, payment_provider, privacy_policy_localized, return_policy_localized (and 3 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_commerce_merchant_settingsTool)

	// page_get_commerce_orders tool
	// Available fields for CommerceOrder: buyer_details, channel, contains_bopis_items, created, estimated_payment_details, id, is_group_buy, is_test_order, last_updated, merchant_order_id, order_status, pre_order_details, selected_shipping_option, ship_by_date, shipping_address
	// Params object accepts: filters (list<pagecommerce_orders_filters_enum_param>), state (list<pagecommerce_orders_state_enum_param>), updated_after (datetime), updated_before (datetime)
	page_get_commerce_ordersTool := mcp.NewTool("page_get_commerce_orders",
		mcp.WithDescription("GET commerce_orders for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"filters": map[string]any{
					"type": "array",
					"description": "filters parameter",
					"enum": []string{ "HAS_CANCELLATIONS", "HAS_FULFILLMENTS", "HAS_REFUNDS", "NO_CANCELLATIONS", "NO_REFUNDS", "NO_SHIPMENTS" },
					"items": map[string]any{"type": "string"},
				},
				"state": map[string]any{
					"type": "array",
					"description": "state parameter",
					"enum": []string{ "COMPLETED", "CREATED", "FB_PROCESSING", "IN_PROGRESS" },
					"items": map[string]any{"type": "string"},
				},
				"updated_after": map[string]any{
					"type": "string",
					"description": "updated_after parameter",
				},
				"updated_before": map[string]any{
					"type": "string",
					"description": "updated_before parameter",
				},
			}),
			mcp.Description("Parameters object containing: filters (array<enum>) [HAS_CANCELLATIONS, HAS_FULFILLMENTS, HAS_REFUNDS, NO_CANCELLATIONS, NO_REFUNDS, ...], state (array<enum>) [COMPLETED, CREATED, FB_PROCESSING, IN_PROGRESS], updated_after (datetime), updated_before (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CommerceOrder objects. Available fields: buyer_details, channel, contains_bopis_items, created, estimated_payment_details, id, is_group_buy, is_test_order, last_updated, merchant_order_id, order_status, pre_order_details, selected_shipping_option, ship_by_date, shipping_address"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_commerce_ordersTool)

	// page_get_commerce_payouts tool
	// Available fields for CommercePayout: amount, payout_date, payout_reference_id, status, transfer_id
	// Params object accepts: end_time (datetime), start_time (datetime)
	page_get_commerce_payoutsTool := mcp.NewTool("page_get_commerce_payouts",
		mcp.WithDescription("GET commerce_payouts for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"end_time": map[string]any{
					"type": "string",
					"description": "end_time parameter",
				},
				"start_time": map[string]any{
					"type": "string",
					"description": "start_time parameter",
				},
			}),
			mcp.Description("Parameters object containing: end_time (datetime), start_time (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CommercePayout objects. Available fields: amount, payout_date, payout_reference_id, status, transfer_id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_commerce_payoutsTool)

	// page_get_commerce_transactions tool
	// Available fields for CommerceOrderTransactionDetail: merchant_order_id, net_payment_amount, order_created, order_details, order_id, payout_reference_id, postal_code, processing_fee, state, tax_rate, transaction_date, transaction_type, transfer_id
	// Params object accepts: end_time (datetime), payout_reference_id (string), start_time (datetime)
	page_get_commerce_transactionsTool := mcp.NewTool("page_get_commerce_transactions",
		mcp.WithDescription("GET commerce_transactions for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"end_time": map[string]any{
					"type": "string",
					"description": "end_time parameter",
				},
				"payout_reference_id": map[string]any{
					"type": "string",
					"description": "payout_reference_id parameter",
				},
				"start_time": map[string]any{
					"type": "string",
					"description": "start_time parameter",
				},
			}),
			mcp.Description("Parameters object containing: end_time (datetime), payout_reference_id (string), start_time (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CommerceOrderTransactionDetail objects. Available fields: merchant_order_id, net_payment_amount, order_created, order_details, order_id, payout_reference_id, postal_code, processing_fee, state, tax_rate, transaction_date, transaction_type, transfer_id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_commerce_transactionsTool)

	// page_get_conversations tool
	// Available fields for UnifiedThread: can_reply, folder, former_participants, id, is_subscribed, link, linked_group, message_count, name, participants, scoped_thread_key, senders, snippet, subject, unread_count, updated_time, wallpaper
	// Params object accepts: folder (string), platform (pageconversations_platform_enum_param), tags (list<string>), user_id (string)
	page_get_conversationsTool := mcp.NewTool("page_get_conversations",
		mcp.WithDescription("GET conversations for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"folder": map[string]any{
					"type": "string",
					"description": "folder parameter",
				},
				"platform": map[string]any{
					"type": "string",
					"description": "platform parameter",
					"enum": []string{ "INSTAGRAM", "MESSENGER" },
				},
				"tags": map[string]any{
					"type": "array",
					"description": "tags parameter",
					"items": map[string]any{"type": "string"},
				},
				"user_id": map[string]any{
					"type": "string",
					"description": "user_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: folder (string), platform (enum) [INSTAGRAM, MESSENGER], tags (array<string>), user_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for UnifiedThread objects. Available fields: can_reply, folder, former_participants, id, is_subscribed, link, linked_group, message_count, name, participants, scoped_thread_key, senders, snippet, subject, unread_count (and 2 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_conversationsTool)

	// page_post_copyright_manual_claims tool
	// Params object accepts: action (pagecopyright_manual_claims_action_enum_param), action_reason (pagecopyright_manual_claims_action_reason_enum_param), countries (Object), match_content_type (pagecopyright_manual_claims_match_content_type_enum_param), matched_asset_id (string), reference_asset_id (string), selected_segments (list<map>)
	page_post_copyright_manual_claimsTool := mcp.NewTool("page_post_copyright_manual_claims",
		mcp.WithDescription("POST copyright_manual_claims for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"action": map[string]any{
					"type": "string",
					"description": "action parameter",
					"enum": []string{ "BLOCK", "CLAIM_AD_EARNINGS", "MANUAL_REVIEW", "MONITOR", "REQUEST_TAKEDOWN" },
				},
				"action_reason": map[string]any{
					"type": "string",
					"description": "action_reason parameter",
					"enum": []string{ "ARTICLE_17_PREFLAGGING", "ARTIST_OBJECTION", "OBJECTIONABLE_CONTENT", "PREMIUM_MUSIC_VIDEO", "PRERELEASE_CONTENT", "PRODUCT_PARAMETERS", "RESTRICTED_CONTENT", "UNAUTHORIZED_COMMERCIAL_USE" },
				},
				"countries": map[string]any{
					"type": "object",
					"description": "countries parameter",
				},
				"match_content_type": map[string]any{
					"type": "string",
					"description": "match_content_type parameter",
					"required": true,
					"enum": []string{ "AUDIO_ONLY", "VIDEO_AND_AUDIO", "VIDEO_ONLY" },
				},
				"matched_asset_id": map[string]any{
					"type": "string",
					"description": "matched_asset_id parameter",
					"required": true,
				},
				"reference_asset_id": map[string]any{
					"type": "string",
					"description": "reference_asset_id parameter",
					"required": true,
				},
				"selected_segments": map[string]any{
					"type": "array",
					"description": "selected_segments parameter",
					"items": map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: action (enum) [BLOCK, CLAIM_AD_EARNINGS, MANUAL_REVIEW, MONITOR, REQUEST_TAKEDOWN], action_reason (enum) [ARTICLE_17_PREFLAGGING, ARTIST_OBJECTION, OBJECTIONABLE_CONTENT, PREMIUM_MUSIC_VIDEO, PRERELEASE_CONTENT, ...], countries (object), match_content_type (enum) [AUDIO_ONLY, VIDEO_AND_AUDIO, VIDEO_ONLY] [required], matched_asset_id (string) [required], reference_asset_id (string) [required], selected_segments (array<object>)"),
		),
	)
	tools = append(tools, page_post_copyright_manual_claimsTool)

	// page_get_crosspost_whitelisted_pages tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	page_get_crosspost_whitelisted_pagesTool := mcp.NewTool("page_get_crosspost_whitelisted_pages",
		mcp.WithDescription("GET crosspost_whitelisted_pages for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_crosspost_whitelisted_pagesTool)

	// page_get_ctx_optimization_eligibility tool
	// Available fields for CTXOptimizationEligibility: ctm
	page_get_ctx_optimization_eligibilityTool := mcp.NewTool("page_get_ctx_optimization_eligibility",
		mcp.WithDescription("GET ctx_optimization_eligibility for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CTXOptimizationEligibility objects. Available fields: ctm"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_ctx_optimization_eligibilityTool)

	// page_get_custom_labels tool
	// Available fields for PageUserMessageThreadLabel: id, page_label_name
	page_get_custom_labelsTool := mcp.NewTool("page_get_custom_labels",
		mcp.WithDescription("GET custom_labels for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PageUserMessageThreadLabel objects. Available fields: id, page_label_name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_custom_labelsTool)

	// page_post_custom_labels tool
	// Params object accepts: name (string), page_label_name (string)
	page_post_custom_labelsTool := mcp.NewTool("page_post_custom_labels",
		mcp.WithDescription("POST custom_labels for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
				},
				"page_label_name": map[string]any{
					"type": "string",
					"description": "page_label_name parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: name (string), page_label_name (string) [required]"),
		),
	)
	tools = append(tools, page_post_custom_labelsTool)

	// page_delete_custom_user_settings tool
	// Params object accepts: params (list<pagecustom_user_settings_params_enum_param>), psid (string)
	page_delete_custom_user_settingsTool := mcp.NewTool("page_delete_custom_user_settings",
		mcp.WithDescription("DELETE custom_user_settings for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"params": map[string]any{
					"type": "array",
					"description": "params parameter",
					"required": true,
					"enum": []string{ "PERSISTENT_MENU" },
					"items": map[string]any{"type": "string"},
				},
				"psid": map[string]any{
					"type": "string",
					"description": "psid parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: params (array<enum>) [PERSISTENT_MENU] [required], psid (string) [required]"),
		),
	)
	tools = append(tools, page_delete_custom_user_settingsTool)

	// page_get_custom_user_settings tool
	// Available fields for CustomUserSettings: page_level_persistent_menu, user_level_persistent_menu
	// Params object accepts: psid (string)
	page_get_custom_user_settingsTool := mcp.NewTool("page_get_custom_user_settings",
		mcp.WithDescription("GET custom_user_settings for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"psid": map[string]any{
					"type": "string",
					"description": "psid parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: psid (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CustomUserSettings objects. Available fields: page_level_persistent_menu, user_level_persistent_menu"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_custom_user_settingsTool)

	// page_post_custom_user_settings tool
	// Params object accepts: persistent_menu (list<Object>), psid (string)
	page_post_custom_user_settingsTool := mcp.NewTool("page_post_custom_user_settings",
		mcp.WithDescription("POST custom_user_settings for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"persistent_menu": map[string]any{
					"type": "array",
					"description": "persistent_menu parameter",
					"items": map[string]any{"type": "object"},
				},
				"psid": map[string]any{
					"type": "string",
					"description": "psid parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: persistent_menu (array<object>), psid (string) [required]"),
		),
	)
	tools = append(tools, page_post_custom_user_settingsTool)

	// page_get_dataset tool
	// Available fields for Dataset: id, name
	page_get_datasetTool := mcp.NewTool("page_get_dataset",
		mcp.WithDescription("GET dataset for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Dataset objects. Available fields: id, name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_datasetTool)

	// page_post_dataset tool
	// Params object accepts: dataset_name (string)
	page_post_datasetTool := mcp.NewTool("page_post_dataset",
		mcp.WithDescription("POST dataset for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"dataset_name": map[string]any{
					"type": "string",
					"description": "dataset_name parameter",
				},
			}),
			mcp.Description("Parameters object containing: dataset_name (string)"),
		),
	)
	tools = append(tools, page_post_datasetTool)

	// page_get_events tool
	// Available fields for Event: attending_count, can_guests_invite, category, cover, created_time, declined_count, description, discount_code_enabled, end_time, event_times, guest_list_enabled, id, interested_count, is_canceled, is_draft, is_online, is_page_owned, maybe_count, name, noreply_count, online_event_format, online_event_third_party_url, owner, parent_group, place, registration_setting, scheduled_publish_time, start_time, sub_categories, ticket_selling_status, ticket_setting, ticket_uri, ticket_uri_start_sales_time, ticketing_privacy_uri, ticketing_terms_uri, timezone, type, updated_time
	// Params object accepts: event_state_filter (list<pageevents_event_state_filter_enum_param>), include_canceled (bool), time_filter (pageevents_time_filter_enum_param), type (pageevents_type_enum_param)
	page_get_eventsTool := mcp.NewTool("page_get_events",
		mcp.WithDescription("GET events for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"event_state_filter": map[string]any{
					"type": "array",
					"description": "event_state_filter parameter",
					"enum": []string{ "canceled", "draft", "published", "scheduled_draft_for_publication" },
					"items": map[string]any{"type": "string"},
				},
				"include_canceled": map[string]any{
					"type": "boolean",
					"description": "include_canceled parameter",
				},
				"time_filter": map[string]any{
					"type": "string",
					"description": "time_filter parameter",
					"enum": []string{ "past", "upcoming" },
				},
				"type": map[string]any{
					"type": "string",
					"description": "type parameter",
					"enum": []string{ "attending", "created", "declined", "maybe", "not_replied" },
				},
			}),
			mcp.Description("Parameters object containing: event_state_filter (array<enum>) [canceled, draft, published, scheduled_draft_for_publication], include_canceled (boolean), time_filter (enum) [past, upcoming], type (enum) [attending, created, declined, maybe, not_replied]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Event objects. Available fields: attending_count, can_guests_invite, category, cover, created_time, declined_count, description, discount_code_enabled, end_time, event_times, guest_list_enabled, id, interested_count, is_canceled, is_draft (and 23 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_eventsTool)

	// page_post_extend_thread_control tool
	// Params object accepts: duration (unsigned int), recipient (Object)
	page_post_extend_thread_controlTool := mcp.NewTool("page_post_extend_thread_control",
		mcp.WithDescription("POST extend_thread_control for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"duration": map[string]any{
					"type": "integer",
					"description": "duration parameter",
				},
				"recipient": map[string]any{
					"type": "object",
					"description": "recipient parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: duration (integer), recipient (object) [required]"),
		),
	)
	tools = append(tools, page_post_extend_thread_controlTool)

	// page_get_fantasy_games tool
	// Available fields for FantasyGame: id, name
	page_get_fantasy_gamesTool := mcp.NewTool("page_get_fantasy_games",
		mcp.WithDescription("GET fantasy_games for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for FantasyGame objects. Available fields: id, name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_fantasy_gamesTool)

	// page_get_feed tool
	// Available fields for PagePost: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting, from, full_picture, height, icon, id, instagram_eligibility, is_app_share, is_eligible_for_promotion, is_expired, is_hidden, is_inline_created, is_instagram_eligible, is_popular, is_published, is_spherical, message, message_tags, multi_share_end_card, multi_share_optimized, parent_id, permalink_url, picture, place, privacy, promotable_id, promotion_status, properties, scheduled_publish_time, shares, status_type, story, story_tags, subscribed, target, targeting, timeline_visibility, updated_time, via, video_buying_eligibility, width
	// Params object accepts: include_hidden (bool), limit (unsigned int), show_expired (bool), with (pagefeed_with_enum_param)
	page_get_feedTool := mcp.NewTool("page_get_feed",
		mcp.WithDescription("GET feed for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"include_hidden": map[string]any{
					"type": "boolean",
					"description": "include_hidden parameter",
				},
				"limit": map[string]any{
					"type": "integer",
					"description": "limit parameter",
				},
				"show_expired": map[string]any{
					"type": "boolean",
					"description": "show_expired parameter",
				},
				"with": map[string]any{
					"type": "string",
					"description": "with parameter",
					"enum": []string{ "LOCATION" },
				},
			}),
			mcp.Description("Parameters object containing: include_hidden (boolean), limit (integer), show_expired (boolean), with (enum) [LOCATION]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PagePost objects. Available fields: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting (and 40 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_feedTool)

	// page_post_feed tool
	// Params object accepts: actions (Object), album_id (string), android_key_hash (string), application_id (string), asked_fun_fact_prompt_id (unsigned int), asset3d_id (string), associated_id (string), attach_place_suggestion (bool), attached_media (list<Object>), audience_exp (bool), backdated_time (datetime), backdated_time_granularity (pagefeed_backdated_time_granularity_enum_param), breaking_news (bool), breaking_news_expiration (unsigned int), call_to_action (Object), caption (string), child_attachments (list<Object>), client_mutation_id (string), composer_entry_picker (string), composer_entry_point (string), composer_entry_time (unsigned int), composer_session_events_log (string), composer_session_id (string), composer_source_surface (string), composer_type (string), connection_class (string), content_attachment (string), coordinates (Object), cta_link (string), cta_type (string), description (string), direct_share_status (unsigned int), enforce_link_ownership (bool), expanded_height (unsigned int), expanded_width (unsigned int), feed_targeting (Object), formatting (pagefeed_formatting_enum_param), fun_fact_prompt_id (string), fun_fact_toastee_id (unsigned int), height (unsigned int), home_checkin_city_id (Object), image_crops (map), implicit_with_tags (list<int>), instant_game_entry_point_data (string), ios_bundle_id (string), is_backout_draft (bool), is_boost_intended (bool), is_explicit_location (bool), is_explicit_share (bool), is_group_linking_post (bool), is_photo_container (bool), link (string), location_source_id (string), manual_privacy (bool), message (string), multi_share_end_card (bool), multi_share_optimized (bool), name (string), nectar_module (string), object_attachment (string), og_action_type_id (string), og_hide_object_attachment (bool), og_icon_id (string), og_object_id (string), og_phrase (string), og_set_profile_badge (bool), og_suggestion_mechanism (string), page_recommendation (string), picture (string), place (Object), place_attachment_setting (pagefeed_place_attachment_setting_enum_param), place_list (string), place_list_data (list), post_surfaces_blacklist (list<pagefeed_post_surfaces_blacklist_enum_param>), posting_to_redspace (pagefeed_posting_to_redspace_enum_param), privacy (string), prompt_id (string), prompt_tracking_string (string), properties (Object), proxied_app_id (string), publish_event_id (unsigned int), published (bool), quote (string), ref (list<string>), referenceable_image_ids (list<string>), referral_id (string), scheduled_publish_time (datetime), source (string), sponsor_id (string), sponsor_relationship (unsigned int), suggested_place_id (Object), tags (list<int>), target_surface (pagefeed_target_surface_enum_param), targeting (Object), text_format_metadata (string), text_format_preset_id (string), text_only_place (string), thumbnail (file), time_since_original_post (unsigned int), title (string), tracking_info (string), unpublished_content_type (pagefeed_unpublished_content_type_enum_param), user_selected_tags (bool), video_start_time_ms (unsigned int), viewer_coordinates (Object), width (unsigned int)
	page_post_feedTool := mcp.NewTool("page_post_feed",
		mcp.WithDescription("POST feed for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"actions": map[string]any{
					"type": "object",
					"description": "actions parameter",
				},
				"album_id": map[string]any{
					"type": "string",
					"description": "album_id parameter",
				},
				"android_key_hash": map[string]any{
					"type": "string",
					"description": "android_key_hash parameter",
				},
				"application_id": map[string]any{
					"type": "string",
					"description": "application_id parameter",
				},
				"asked_fun_fact_prompt_id": map[string]any{
					"type": "integer",
					"description": "asked_fun_fact_prompt_id parameter",
				},
				"asset3d_id": map[string]any{
					"type": "string",
					"description": "asset3d_id parameter",
				},
				"associated_id": map[string]any{
					"type": "string",
					"description": "associated_id parameter",
				},
				"attach_place_suggestion": map[string]any{
					"type": "boolean",
					"description": "attach_place_suggestion parameter",
				},
				"attached_media": map[string]any{
					"type": "array",
					"description": "attached_media parameter",
					"items": map[string]any{"type": "object"},
				},
				"audience_exp": map[string]any{
					"type": "boolean",
					"description": "audience_exp parameter",
				},
				"backdated_time": map[string]any{
					"type": "string",
					"description": "backdated_time parameter",
				},
				"backdated_time_granularity": map[string]any{
					"type": "string",
					"description": "backdated_time_granularity parameter",
					"enum": []string{ "day", "hour", "min", "month", "none", "year" },
				},
				"breaking_news": map[string]any{
					"type": "boolean",
					"description": "breaking_news parameter",
				},
				"breaking_news_expiration": map[string]any{
					"type": "integer",
					"description": "breaking_news_expiration parameter",
				},
				"call_to_action": map[string]any{
					"type": "object",
					"description": "call_to_action parameter",
				},
				"caption": map[string]any{
					"type": "string",
					"description": "caption parameter",
				},
				"child_attachments": map[string]any{
					"type": "array",
					"description": "child_attachments parameter",
					"items": map[string]any{"type": "object"},
				},
				"client_mutation_id": map[string]any{
					"type": "string",
					"description": "client_mutation_id parameter",
				},
				"composer_entry_picker": map[string]any{
					"type": "string",
					"description": "composer_entry_picker parameter",
				},
				"composer_entry_point": map[string]any{
					"type": "string",
					"description": "composer_entry_point parameter",
				},
				"composer_entry_time": map[string]any{
					"type": "integer",
					"description": "composer_entry_time parameter",
				},
				"composer_session_events_log": map[string]any{
					"type": "string",
					"description": "composer_session_events_log parameter",
				},
				"composer_session_id": map[string]any{
					"type": "string",
					"description": "composer_session_id parameter",
				},
				"composer_source_surface": map[string]any{
					"type": "string",
					"description": "composer_source_surface parameter",
				},
				"composer_type": map[string]any{
					"type": "string",
					"description": "composer_type parameter",
				},
				"connection_class": map[string]any{
					"type": "string",
					"description": "connection_class parameter",
				},
				"content_attachment": map[string]any{
					"type": "string",
					"description": "content_attachment parameter",
				},
				"coordinates": map[string]any{
					"type": "object",
					"description": "coordinates parameter",
				},
				"cta_link": map[string]any{
					"type": "string",
					"description": "cta_link parameter",
				},
				"cta_type": map[string]any{
					"type": "string",
					"description": "cta_type parameter",
				},
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
				},
				"direct_share_status": map[string]any{
					"type": "integer",
					"description": "direct_share_status parameter",
				},
				"enforce_link_ownership": map[string]any{
					"type": "boolean",
					"description": "enforce_link_ownership parameter",
				},
				"expanded_height": map[string]any{
					"type": "integer",
					"description": "expanded_height parameter",
				},
				"expanded_width": map[string]any{
					"type": "integer",
					"description": "expanded_width parameter",
				},
				"feed_targeting": map[string]any{
					"type": "object",
					"description": "feed_targeting parameter",
				},
				"formatting": map[string]any{
					"type": "string",
					"description": "formatting parameter",
					"enum": []string{ "MARKDOWN", "PLAINTEXT" },
				},
				"fun_fact_prompt_id": map[string]any{
					"type": "string",
					"description": "fun_fact_prompt_id parameter",
				},
				"fun_fact_toastee_id": map[string]any{
					"type": "integer",
					"description": "fun_fact_toastee_id parameter",
				},
				"height": map[string]any{
					"type": "integer",
					"description": "height parameter",
				},
				"home_checkin_city_id": map[string]any{
					"type": "object",
					"description": "home_checkin_city_id parameter",
				},
				"image_crops": map[string]any{
					"type": "object",
					"description": "image_crops parameter",
				},
				"implicit_with_tags": map[string]any{
					"type": "array",
					"description": "implicit_with_tags parameter",
					"items": map[string]any{"type": "integer"},
				},
				"instant_game_entry_point_data": map[string]any{
					"type": "string",
					"description": "instant_game_entry_point_data parameter",
				},
				"ios_bundle_id": map[string]any{
					"type": "string",
					"description": "ios_bundle_id parameter",
				},
				"is_backout_draft": map[string]any{
					"type": "boolean",
					"description": "is_backout_draft parameter",
				},
				"is_boost_intended": map[string]any{
					"type": "boolean",
					"description": "is_boost_intended parameter",
				},
				"is_explicit_location": map[string]any{
					"type": "boolean",
					"description": "is_explicit_location parameter",
				},
				"is_explicit_share": map[string]any{
					"type": "boolean",
					"description": "is_explicit_share parameter",
				},
				"is_group_linking_post": map[string]any{
					"type": "boolean",
					"description": "is_group_linking_post parameter",
				},
				"is_photo_container": map[string]any{
					"type": "boolean",
					"description": "is_photo_container parameter",
				},
				"link": map[string]any{
					"type": "string",
					"description": "link parameter",
				},
				"location_source_id": map[string]any{
					"type": "string",
					"description": "location_source_id parameter",
				},
				"manual_privacy": map[string]any{
					"type": "boolean",
					"description": "manual_privacy parameter",
				},
				"message": map[string]any{
					"type": "string",
					"description": "message parameter",
				},
				"multi_share_end_card": map[string]any{
					"type": "boolean",
					"description": "multi_share_end_card parameter",
				},
				"multi_share_optimized": map[string]any{
					"type": "boolean",
					"description": "multi_share_optimized parameter",
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
				},
				"nectar_module": map[string]any{
					"type": "string",
					"description": "nectar_module parameter",
				},
				"object_attachment": map[string]any{
					"type": "string",
					"description": "object_attachment parameter",
				},
				"og_action_type_id": map[string]any{
					"type": "string",
					"description": "og_action_type_id parameter",
				},
				"og_hide_object_attachment": map[string]any{
					"type": "boolean",
					"description": "og_hide_object_attachment parameter",
				},
				"og_icon_id": map[string]any{
					"type": "string",
					"description": "og_icon_id parameter",
				},
				"og_object_id": map[string]any{
					"type": "string",
					"description": "og_object_id parameter",
				},
				"og_phrase": map[string]any{
					"type": "string",
					"description": "og_phrase parameter",
				},
				"og_set_profile_badge": map[string]any{
					"type": "boolean",
					"description": "og_set_profile_badge parameter",
				},
				"og_suggestion_mechanism": map[string]any{
					"type": "string",
					"description": "og_suggestion_mechanism parameter",
				},
				"page_recommendation": map[string]any{
					"type": "string",
					"description": "page_recommendation parameter",
				},
				"picture": map[string]any{
					"type": "string",
					"description": "picture parameter",
				},
				"place": map[string]any{
					"type": "object",
					"description": "place parameter",
				},
				"place_attachment_setting": map[string]any{
					"type": "string",
					"description": "place_attachment_setting parameter",
					"enum": []string{ "1", "2" },
				},
				"place_list": map[string]any{
					"type": "string",
					"description": "place_list parameter",
				},
				"place_list_data": map[string]any{
					"type": "string",
					"description": "place_list_data parameter",
				},
				"post_surfaces_blacklist": map[string]any{
					"type": "array",
					"description": "post_surfaces_blacklist parameter",
					"enum": []string{ "1", "2", "3", "4", "5" },
					"items": map[string]any{"type": "string"},
				},
				"posting_to_redspace": map[string]any{
					"type": "string",
					"description": "posting_to_redspace parameter",
					"enum": []string{ "disabled", "enabled" },
				},
				"privacy": map[string]any{
					"type": "string",
					"description": "privacy parameter",
				},
				"prompt_id": map[string]any{
					"type": "string",
					"description": "prompt_id parameter",
				},
				"prompt_tracking_string": map[string]any{
					"type": "string",
					"description": "prompt_tracking_string parameter",
				},
				"properties": map[string]any{
					"type": "object",
					"description": "properties parameter",
				},
				"proxied_app_id": map[string]any{
					"type": "string",
					"description": "proxied_app_id parameter",
				},
				"publish_event_id": map[string]any{
					"type": "integer",
					"description": "publish_event_id parameter",
				},
				"published": map[string]any{
					"type": "boolean",
					"description": "published parameter",
				},
				"quote": map[string]any{
					"type": "string",
					"description": "quote parameter",
				},
				"ref": map[string]any{
					"type": "array",
					"description": "ref parameter",
					"items": map[string]any{"type": "string"},
				},
				"referenceable_image_ids": map[string]any{
					"type": "array",
					"description": "referenceable_image_ids parameter",
					"items": map[string]any{"type": "string"},
				},
				"referral_id": map[string]any{
					"type": "string",
					"description": "referral_id parameter",
				},
				"scheduled_publish_time": map[string]any{
					"type": "string",
					"description": "scheduled_publish_time parameter",
				},
				"source": map[string]any{
					"type": "string",
					"description": "source parameter",
				},
				"sponsor_id": map[string]any{
					"type": "string",
					"description": "sponsor_id parameter",
				},
				"sponsor_relationship": map[string]any{
					"type": "integer",
					"description": "sponsor_relationship parameter",
				},
				"suggested_place_id": map[string]any{
					"type": "object",
					"description": "suggested_place_id parameter",
				},
				"tags": map[string]any{
					"type": "array",
					"description": "tags parameter",
					"items": map[string]any{"type": "integer"},
				},
				"target_surface": map[string]any{
					"type": "string",
					"description": "target_surface parameter",
					"enum": []string{ "STORY", "TIMELINE" },
				},
				"targeting": map[string]any{
					"type": "object",
					"description": "targeting parameter",
				},
				"text_format_metadata": map[string]any{
					"type": "string",
					"description": "text_format_metadata parameter",
				},
				"text_format_preset_id": map[string]any{
					"type": "string",
					"description": "text_format_preset_id parameter",
				},
				"text_only_place": map[string]any{
					"type": "string",
					"description": "text_only_place parameter",
				},
				"thumbnail": map[string]any{
					"type": "string",
					"description": "thumbnail parameter",
				},
				"time_since_original_post": map[string]any{
					"type": "integer",
					"description": "time_since_original_post parameter",
				},
				"title": map[string]any{
					"type": "string",
					"description": "title parameter",
				},
				"tracking_info": map[string]any{
					"type": "string",
					"description": "tracking_info parameter",
				},
				"unpublished_content_type": map[string]any{
					"type": "string",
					"description": "unpublished_content_type parameter",
					"enum": []string{ "ADS_POST", "DRAFT", "INLINE_CREATED", "PUBLISHED", "REVIEWABLE_BRANDED_CONTENT", "SCHEDULED", "SCHEDULED_RECURRING" },
				},
				"user_selected_tags": map[string]any{
					"type": "boolean",
					"description": "user_selected_tags parameter",
				},
				"video_start_time_ms": map[string]any{
					"type": "integer",
					"description": "video_start_time_ms parameter",
				},
				"viewer_coordinates": map[string]any{
					"type": "object",
					"description": "viewer_coordinates parameter",
				},
				"width": map[string]any{
					"type": "integer",
					"description": "width parameter",
				},
			}),
			mcp.Description("Parameters object containing: actions (object), album_id (string), android_key_hash (string), application_id (string), asked_fun_fact_prompt_id (integer), asset3d_id (string), associated_id (string), attach_place_suggestion (boolean), attached_media (array<object>), audience_exp (boolean), backdated_time (datetime), backdated_time_granularity (enum) [day, hour, min, month, none, ...], breaking_news (boolean), breaking_news_expiration (integer), call_to_action (object), caption (string), child_attachments (array<object>), client_mutation_id (string), composer_entry_picker (string), composer_entry_point (string), composer_entry_time (integer), composer_session_events_log (string), composer_session_id (string), composer_source_surface (string), composer_type (string), connection_class (string), content_attachment (string), coordinates (object), cta_link (string), cta_type (string), description (string), direct_share_status (integer), enforce_link_ownership (boolean), expanded_height (integer), expanded_width (integer), feed_targeting (object), formatting (enum) [MARKDOWN, PLAINTEXT], fun_fact_prompt_id (string), fun_fact_toastee_id (integer), height (integer), home_checkin_city_id (object), image_crops (object), implicit_with_tags (array<integer>), instant_game_entry_point_data (string), ios_bundle_id (string), is_backout_draft (boolean), is_boost_intended (boolean), is_explicit_location (boolean), is_explicit_share (boolean), is_group_linking_post (boolean), is_photo_container (boolean), link (string), location_source_id (string), manual_privacy (boolean), message (string), multi_share_end_card (boolean), multi_share_optimized (boolean), name (string), nectar_module (string), object_attachment (string), og_action_type_id (string), og_hide_object_attachment (boolean), og_icon_id (string), og_object_id (string), og_phrase (string), og_set_profile_badge (boolean), og_suggestion_mechanism (string), page_recommendation (string), picture (string), place (object), place_attachment_setting (enum) [1, 2], place_list (string), place_list_data (list), post_surfaces_blacklist (array<enum>) [1, 2, 3, 4, 5], posting_to_redspace (enum) [disabled, enabled], privacy (string), prompt_id (string), prompt_tracking_string (string), properties (object), proxied_app_id (string), publish_event_id (integer), published (boolean), quote (string), ref (array<string>), referenceable_image_ids (array<string>), referral_id (string), scheduled_publish_time (datetime), source (string), sponsor_id (string), sponsor_relationship (integer), suggested_place_id (object), tags (array<integer>), target_surface (enum) [STORY, TIMELINE], targeting (object), text_format_metadata (string), text_format_preset_id (string), text_only_place (string), thumbnail (file), time_since_original_post (integer), title (string), tracking_info (string), unpublished_content_type (enum) [ADS_POST, DRAFT, INLINE_CREATED, PUBLISHED, REVIEWABLE_BRANDED_CONTENT, ...], user_selected_tags (boolean), video_start_time_ms (integer), viewer_coordinates (object), width (integer)"),
		),
	)
	tools = append(tools, page_post_feedTool)

	// page_get_global_brand_children tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	page_get_global_brand_childrenTool := mcp.NewTool("page_get_global_brand_children",
		mcp.WithDescription("GET global_brand_children for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_global_brand_childrenTool)

	// page_get_image_copyrights tool
	// Available fields for ImageCopyright: artist, copyright_monitoring_status, creation_time, creator, custom_id, description, filename, id, image, matches_count, original_content_creation_date, ownership_countries, tags, title, update_time
	page_get_image_copyrightsTool := mcp.NewTool("page_get_image_copyrights",
		mcp.WithDescription("GET image_copyrights for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ImageCopyright objects. Available fields: artist, copyright_monitoring_status, creation_time, creator, custom_id, description, filename, id, image, matches_count, original_content_creation_date, ownership_countries, tags, title, update_time"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_image_copyrightsTool)

	// page_post_image_copyrights tool
	// Params object accepts: artist (string), attribution_link (string), creator (string), custom_id (string), description (string), filename (string), geo_ownership (list<pageimage_copyrights_geo_ownership_enum_param>), original_content_creation_date (unsigned int), reference_photo (string), title (string)
	page_post_image_copyrightsTool := mcp.NewTool("page_post_image_copyrights",
		mcp.WithDescription("POST image_copyrights for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"artist": map[string]any{
					"type": "string",
					"description": "artist parameter",
				},
				"attribution_link": map[string]any{
					"type": "string",
					"description": "attribution_link parameter",
				},
				"creator": map[string]any{
					"type": "string",
					"description": "creator parameter",
				},
				"custom_id": map[string]any{
					"type": "string",
					"description": "custom_id parameter",
				},
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
				},
				"filename": map[string]any{
					"type": "string",
					"description": "filename parameter",
					"required": true,
				},
				"geo_ownership": map[string]any{
					"type": "array",
					"description": "geo_ownership parameter",
					"required": true,
					"enum": []string{ "AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TP", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "XK", "YE", "YT", "ZA", "ZM", "ZW" },
					"items": map[string]any{"type": "string"},
				},
				"original_content_creation_date": map[string]any{
					"type": "integer",
					"description": "original_content_creation_date parameter",
				},
				"reference_photo": map[string]any{
					"type": "string",
					"description": "reference_photo parameter",
					"required": true,
				},
				"title": map[string]any{
					"type": "string",
					"description": "title parameter",
				},
			}),
			mcp.Description("Parameters object containing: artist (string), attribution_link (string), creator (string), custom_id (string), description (string), filename (string) [required], geo_ownership (array<enum>) [AD, AE, AF, AG, AI, ...] [required], original_content_creation_date (integer), reference_photo (string) [required], title (string)"),
		),
	)
	tools = append(tools, page_post_image_copyrightsTool)

	// page_get_indexed_videos tool
	// Available fields for AdVideo: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html, embeddable, event, expiration, format, from, icon, id, is_crosspost_video, is_crossposting_eligible, is_episode, is_instagram_eligible, is_reference_only, length, live_audience_count, live_status, music_video_copyright, permalink_url, picture, place, post_id, post_views, premiere_living_room_status, privacy, published, scheduled_publish_time, source, spherical, status, title, universal_video_id, updated_time, views
	page_get_indexed_videosTool := mcp.NewTool("page_get_indexed_videos",
		mcp.WithDescription("GET indexed_videos for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdVideo objects. Available fields: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html (and 32 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_indexed_videosTool)

	// page_get_insights tool
	// Available fields for InsightsResult: description, description_from_api_doc, id, name, period, title, values
	// Params object accepts: breakdown (list<Object>), date_preset (pageinsights_date_preset_enum_param), metric (list<Object>), period (pageinsights_period_enum_param), show_description_from_api_doc (bool), since (datetime), until (datetime)
	page_get_insightsTool := mcp.NewTool("page_get_insights",
		mcp.WithDescription("GET insights for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"breakdown": map[string]any{
					"type": "array",
					"description": "breakdown parameter",
					"items": map[string]any{"type": "object"},
				},
				"date_preset": map[string]any{
					"type": "string",
					"description": "date_preset parameter",
					"enum": []string{ "data_maximum", "last_14d", "last_28d", "last_30d", "last_3d", "last_7d", "last_90d", "last_month", "last_quarter", "last_week_mon_sun", "last_week_sun_sat", "last_year", "maximum", "this_month", "this_quarter", "this_week_mon_today", "this_week_sun_today", "this_year", "today", "yesterday" },
				},
				"metric": map[string]any{
					"type": "array",
					"description": "metric parameter",
					"items": map[string]any{"type": "object"},
				},
				"period": map[string]any{
					"type": "string",
					"description": "period parameter",
					"enum": []string{ "day", "days_28", "lifetime", "month", "total_over_range", "week" },
				},
				"show_description_from_api_doc": map[string]any{
					"type": "boolean",
					"description": "show_description_from_api_doc parameter",
				},
				"since": map[string]any{
					"type": "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type": "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: breakdown (array<object>), date_preset (enum) [data_maximum, last_14d, last_28d, last_30d, last_3d, ...], metric (array<object>), period (enum) [day, days_28, lifetime, month, total_over_range, ...], show_description_from_api_doc (boolean), since (datetime), until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for InsightsResult objects. Available fields: description, description_from_api_doc, id, name, period, title, values"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_insightsTool)

	// page_get_instagram_accounts tool
	// Available fields for IGUser: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url, shopping_product_tag_eligibility, shopping_review_status, username, website
	page_get_instagram_accountsTool := mcp.NewTool("page_get_instagram_accounts",
		mcp.WithDescription("GET instagram_accounts for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGUser objects. Available fields: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_instagram_accountsTool)

	// page_get_leadgen_forms tool
	// Available fields for LeadgenForm: allow_organic_lead, block_display_for_non_targeted_viewer, context_card, created_time, creator, expired_leads_count, follow_up_action_text, follow_up_action_url, id, is_optimized_for_quality, leads_count, legal_content, locale, name, organic_leads_count, page, page_id, privacy_policy_url, question_page_custom_headline, questions, status, thank_you_page, tracking_parameters
	page_get_leadgen_formsTool := mcp.NewTool("page_get_leadgen_forms",
		mcp.WithDescription("GET leadgen_forms for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for LeadgenForm objects. Available fields: allow_organic_lead, block_display_for_non_targeted_viewer, context_card, created_time, creator, expired_leads_count, follow_up_action_text, follow_up_action_url, id, is_optimized_for_quality, leads_count, legal_content, locale, name, organic_leads_count (and 8 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_leadgen_formsTool)

	// page_post_leadgen_forms tool
	// Params object accepts: allow_organic_lead_retrieval (bool), block_display_for_non_targeted_viewer (bool), context_card (Object), cover_photo (file), custom_disclaimer (Object), follow_up_action_url (string), is_for_canvas (bool), is_optimized_for_quality (bool), locale (pageleadgen_forms_locale_enum_param), name (string), privacy_policy (Object), question_page_custom_headline (string), questions (list<Object>), thank_you_page (Object), tracking_parameters (map), upload_gated_file (file)
	page_post_leadgen_formsTool := mcp.NewTool("page_post_leadgen_forms",
		mcp.WithDescription("POST leadgen_forms for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"allow_organic_lead_retrieval": map[string]any{
					"type": "boolean",
					"description": "allow_organic_lead_retrieval parameter",
				},
				"block_display_for_non_targeted_viewer": map[string]any{
					"type": "boolean",
					"description": "block_display_for_non_targeted_viewer parameter",
				},
				"context_card": map[string]any{
					"type": "object",
					"description": "context_card parameter",
				},
				"cover_photo": map[string]any{
					"type": "string",
					"description": "cover_photo parameter",
				},
				"custom_disclaimer": map[string]any{
					"type": "object",
					"description": "custom_disclaimer parameter",
				},
				"follow_up_action_url": map[string]any{
					"type": "string",
					"description": "follow_up_action_url parameter",
				},
				"is_for_canvas": map[string]any{
					"type": "boolean",
					"description": "is_for_canvas parameter",
				},
				"is_optimized_for_quality": map[string]any{
					"type": "boolean",
					"description": "is_optimized_for_quality parameter",
				},
				"locale": map[string]any{
					"type": "string",
					"description": "locale parameter",
					"enum": []string{ "AR_AR", "CS_CZ", "DA_DK", "DE_DE", "EL_GR", "EN_GB", "EN_US", "ES_ES", "ES_LA", "FI_FI", "FR_FR", "HE_IL", "HI_IN", "HU_HU", "ID_ID", "IT_IT", "JA_JP", "KO_KR", "NB_NO", "NL_NL", "PL_PL", "PT_BR", "PT_PT", "RO_RO", "RU_RU", "SV_SE", "TH_TH", "TR_TR", "VI_VN", "ZH_CN", "ZH_HK", "ZH_TW" },
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
					"required": true,
				},
				"privacy_policy": map[string]any{
					"type": "object",
					"description": "privacy_policy parameter",
				},
				"question_page_custom_headline": map[string]any{
					"type": "string",
					"description": "question_page_custom_headline parameter",
				},
				"questions": map[string]any{
					"type": "array",
					"description": "questions parameter",
					"required": true,
					"items": map[string]any{"type": "object"},
				},
				"thank_you_page": map[string]any{
					"type": "object",
					"description": "thank_you_page parameter",
				},
				"tracking_parameters": map[string]any{
					"type": "object",
					"description": "tracking_parameters parameter",
				},
				"upload_gated_file": map[string]any{
					"type": "string",
					"description": "upload_gated_file parameter",
				},
			}),
			mcp.Description("Parameters object containing: allow_organic_lead_retrieval (boolean), block_display_for_non_targeted_viewer (boolean), context_card (object), cover_photo (file), custom_disclaimer (object), follow_up_action_url (string), is_for_canvas (boolean), is_optimized_for_quality (boolean), locale (enum) [AR_AR, CS_CZ, DA_DK, DE_DE, EL_GR, ...], name (string) [required], privacy_policy (object), question_page_custom_headline (string), questions (array<object>) [required], thank_you_page (object), tracking_parameters (object), upload_gated_file (file)"),
		),
	)
	tools = append(tools, page_post_leadgen_formsTool)

	// page_get_likes tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	// Params object accepts: target_id (string)
	page_get_likesTool := mcp.NewTool("page_get_likes",
		mcp.WithDescription("GET likes for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"target_id": map[string]any{
					"type": "string",
					"description": "target_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: target_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_likesTool)

	// page_get_live_videos tool
	// Available fields for LiveVideo: ad_break_config, ad_break_failure_reason, broadcast_start_time, copyright, creation_time, dash_ingest_url, dash_preview_url, description, embed_html, from, id, ingest_streams, is_manual_mode, is_reference_only, live_views, overlay_url, permalink_url, planned_start_time, recommended_encoder_settings, seconds_left, secure_stream_url, status, stream_url, targeting, title, total_views, video
	// Params object accepts: broadcast_status (list<pagelive_videos_broadcast_status_enum_param>), source (pagelive_videos_source_enum_param)
	page_get_live_videosTool := mcp.NewTool("page_get_live_videos",
		mcp.WithDescription("GET live_videos for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"broadcast_status": map[string]any{
					"type": "array",
					"description": "broadcast_status parameter",
					"enum": []string{ "LIVE", "LIVE_STOPPED", "PROCESSING", "SCHEDULED_CANCELED", "SCHEDULED_EXPIRED", "SCHEDULED_LIVE", "SCHEDULED_UNPUBLISHED", "UNPUBLISHED", "VOD" },
					"items": map[string]any{"type": "string"},
				},
				"source": map[string]any{
					"type": "string",
					"description": "source parameter",
					"enum": []string{ "owner", "target" },
				},
			}),
			mcp.Description("Parameters object containing: broadcast_status (array<enum>) [LIVE, LIVE_STOPPED, PROCESSING, SCHEDULED_CANCELED, SCHEDULED_EXPIRED, ...], source (enum) [owner, target]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for LiveVideo objects. Available fields: ad_break_config, ad_break_failure_reason, broadcast_start_time, copyright, creation_time, dash_ingest_url, dash_preview_url, description, embed_html, from, id, ingest_streams, is_manual_mode, is_reference_only, live_views (and 12 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_live_videosTool)

	// page_post_live_videos tool
	// Params object accepts: content_tags (list<string>), crossposting_actions (list<map>), custom_labels (list<string>), description (string), enable_backup_ingest (bool), encoding_settings (string), event_params (Object), fisheye_video_cropped (bool), front_z_rotation (float), game_show (map), is_audio_only (bool), is_spherical (bool), original_fov (unsigned int), privacy (string), projection (pagelive_videos_projection_enum_param), published (bool), schedule_custom_profile_image (file), spatial_audio_format (pagelive_videos_spatial_audio_format_enum_param), status (pagelive_videos_status_enum_param), stereoscopic_mode (pagelive_videos_stereoscopic_mode_enum_param), stop_on_delete_stream (bool), stream_type (pagelive_videos_stream_type_enum_param), targeting (Object), title (string)
	page_post_live_videosTool := mcp.NewTool("page_post_live_videos",
		mcp.WithDescription("POST live_videos for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"content_tags": map[string]any{
					"type": "array",
					"description": "content_tags parameter",
					"items": map[string]any{"type": "string"},
				},
				"crossposting_actions": map[string]any{
					"type": "array",
					"description": "crossposting_actions parameter",
					"items": map[string]any{"type": "object"},
				},
				"custom_labels": map[string]any{
					"type": "array",
					"description": "custom_labels parameter",
					"items": map[string]any{"type": "string"},
				},
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
				},
				"enable_backup_ingest": map[string]any{
					"type": "boolean",
					"description": "enable_backup_ingest parameter",
				},
				"encoding_settings": map[string]any{
					"type": "string",
					"description": "encoding_settings parameter",
				},
				"event_params": map[string]any{
					"type": "object",
					"description": "event_params parameter",
				},
				"fisheye_video_cropped": map[string]any{
					"type": "boolean",
					"description": "fisheye_video_cropped parameter",
				},
				"front_z_rotation": map[string]any{
					"type": "number",
					"description": "front_z_rotation parameter",
				},
				"game_show": map[string]any{
					"type": "object",
					"description": "game_show parameter",
				},
				"is_audio_only": map[string]any{
					"type": "boolean",
					"description": "is_audio_only parameter",
				},
				"is_spherical": map[string]any{
					"type": "boolean",
					"description": "is_spherical parameter",
				},
				"original_fov": map[string]any{
					"type": "integer",
					"description": "original_fov parameter",
				},
				"privacy": map[string]any{
					"type": "string",
					"description": "privacy parameter",
				},
				"projection": map[string]any{
					"type": "string",
					"description": "projection parameter",
					"enum": []string{ "CUBEMAP", "EQUIRECTANGULAR", "HALF_EQUIRECTANGULAR" },
				},
				"published": map[string]any{
					"type": "boolean",
					"description": "published parameter",
				},
				"schedule_custom_profile_image": map[string]any{
					"type": "string",
					"description": "schedule_custom_profile_image parameter",
				},
				"spatial_audio_format": map[string]any{
					"type": "string",
					"description": "spatial_audio_format parameter",
					"enum": []string{ "ambiX_4" },
				},
				"status": map[string]any{
					"type": "string",
					"description": "status parameter",
					"enum": []string{ "LIVE_NOW", "SCHEDULED_CANCELED", "SCHEDULED_LIVE", "SCHEDULED_UNPUBLISHED", "UNPUBLISHED" },
				},
				"stereoscopic_mode": map[string]any{
					"type": "string",
					"description": "stereoscopic_mode parameter",
					"enum": []string{ "LEFT_RIGHT", "MONO", "TOP_BOTTOM" },
				},
				"stop_on_delete_stream": map[string]any{
					"type": "boolean",
					"description": "stop_on_delete_stream parameter",
				},
				"stream_type": map[string]any{
					"type": "string",
					"description": "stream_type parameter",
					"enum": []string{ "AMBIENT", "REGULAR" },
				},
				"targeting": map[string]any{
					"type": "object",
					"description": "targeting parameter",
				},
				"title": map[string]any{
					"type": "string",
					"description": "title parameter",
				},
			}),
			mcp.Description("Parameters object containing: content_tags (array<string>), crossposting_actions (array<object>), custom_labels (array<string>), description (string), enable_backup_ingest (boolean), encoding_settings (string), event_params (object), fisheye_video_cropped (boolean), front_z_rotation (number), game_show (object), is_audio_only (boolean), is_spherical (boolean), original_fov (integer), privacy (string), projection (enum) [CUBEMAP, EQUIRECTANGULAR, HALF_EQUIRECTANGULAR], published (boolean), schedule_custom_profile_image (file), spatial_audio_format (enum) [ambiX_4], status (enum) [LIVE_NOW, SCHEDULED_CANCELED, SCHEDULED_LIVE, SCHEDULED_UNPUBLISHED, UNPUBLISHED], stereoscopic_mode (enum) [LEFT_RIGHT, MONO, TOP_BOTTOM], stop_on_delete_stream (boolean), stream_type (enum) [AMBIENT, REGULAR], targeting (object), title (string)"),
		),
	)
	tools = append(tools, page_post_live_videosTool)

	// page_delete_locations tool
	// Params object accepts: location_page_ids (list<string>), store_numbers (list<unsigned int>)
	page_delete_locationsTool := mcp.NewTool("page_delete_locations",
		mcp.WithDescription("DELETE locations for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"location_page_ids": map[string]any{
					"type": "array",
					"description": "location_page_ids parameter",
					"required": true,
					"items": map[string]any{"type": "string"},
				},
				"store_numbers": map[string]any{
					"type": "array",
					"description": "store_numbers parameter",
					"required": true,
					"items": map[string]any{"type": "integer"},
				},
			}),
			mcp.Description("Parameters object containing: location_page_ids (array<string>) [required], store_numbers (array<integer>) [required]"),
		),
	)
	tools = append(tools, page_delete_locationsTool)

	// page_get_locations tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	page_get_locationsTool := mcp.NewTool("page_get_locations",
		mcp.WithDescription("GET locations for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_locationsTool)

	// page_post_locations tool
	// Params object accepts: always_open (bool), delivery_and_pickup_option_info (list<string>), differently_open_offerings (map), hours (map), ignore_warnings (bool), location (Object), location_page_id (string), old_store_number (unsigned int), page_username (string), permanently_closed (bool), phone (string), pickup_options (list<pagelocations_pickup_options_enum_param>), place_topics (list<string>), price_range (string), store_code (string), store_location_descriptor (string), store_name (string), store_number (unsigned int), temporary_status (pagelocations_temporary_status_enum_param), website (string)
	page_post_locationsTool := mcp.NewTool("page_post_locations",
		mcp.WithDescription("POST locations for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"always_open": map[string]any{
					"type": "boolean",
					"description": "always_open parameter",
				},
				"delivery_and_pickup_option_info": map[string]any{
					"type": "array",
					"description": "delivery_and_pickup_option_info parameter",
					"items": map[string]any{"type": "string"},
				},
				"differently_open_offerings": map[string]any{
					"type": "object",
					"description": "differently_open_offerings parameter",
				},
				"hours": map[string]any{
					"type": "object",
					"description": "hours parameter",
				},
				"ignore_warnings": map[string]any{
					"type": "boolean",
					"description": "ignore_warnings parameter",
				},
				"location": map[string]any{
					"type": "object",
					"description": "location parameter",
				},
				"location_page_id": map[string]any{
					"type": "string",
					"description": "location_page_id parameter",
				},
				"old_store_number": map[string]any{
					"type": "integer",
					"description": "old_store_number parameter",
				},
				"page_username": map[string]any{
					"type": "string",
					"description": "page_username parameter",
				},
				"permanently_closed": map[string]any{
					"type": "boolean",
					"description": "permanently_closed parameter",
				},
				"phone": map[string]any{
					"type": "string",
					"description": "phone parameter",
				},
				"pickup_options": map[string]any{
					"type": "array",
					"description": "pickup_options parameter",
					"enum": []string{ "CURBSIDE", "IN_STORE", "OTHER" },
					"items": map[string]any{"type": "string"},
				},
				"place_topics": map[string]any{
					"type": "array",
					"description": "place_topics parameter",
					"items": map[string]any{"type": "string"},
				},
				"price_range": map[string]any{
					"type": "string",
					"description": "price_range parameter",
				},
				"store_code": map[string]any{
					"type": "string",
					"description": "store_code parameter",
				},
				"store_location_descriptor": map[string]any{
					"type": "string",
					"description": "store_location_descriptor parameter",
				},
				"store_name": map[string]any{
					"type": "string",
					"description": "store_name parameter",
				},
				"store_number": map[string]any{
					"type": "integer",
					"description": "store_number parameter",
					"required": true,
				},
				"temporary_status": map[string]any{
					"type": "string",
					"description": "temporary_status parameter",
					"enum": []string{ "DIFFERENTLY_OPEN", "NO_DATA", "OPERATING_AS_USUAL", "TEMPORARILY_CLOSED" },
				},
				"website": map[string]any{
					"type": "string",
					"description": "website parameter",
				},
			}),
			mcp.Description("Parameters object containing: always_open (boolean), delivery_and_pickup_option_info (array<string>), differently_open_offerings (object), hours (object), ignore_warnings (boolean), location (object), location_page_id (string), old_store_number (integer), page_username (string), permanently_closed (boolean), phone (string), pickup_options (array<enum>) [CURBSIDE, IN_STORE, OTHER], place_topics (array<string>), price_range (string), store_code (string), store_location_descriptor (string), store_name (string), store_number (integer) [required], temporary_status (enum) [DIFFERENTLY_OPEN, NO_DATA, OPERATING_AS_USUAL, TEMPORARILY_CLOSED], website (string)"),
		),
	)
	tools = append(tools, page_post_locationsTool)

	// page_get_media_fingerprints tool
	// Available fields for MediaFingerprint: duration_in_sec, fingerprint_content_type, fingerprint_type, id, metadata, title, universal_content_id
	// Params object accepts: universal_content_id (string)
	page_get_media_fingerprintsTool := mcp.NewTool("page_get_media_fingerprints",
		mcp.WithDescription("GET media_fingerprints for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"universal_content_id": map[string]any{
					"type": "string",
					"description": "universal_content_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: universal_content_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for MediaFingerprint objects. Available fields: duration_in_sec, fingerprint_content_type, fingerprint_type, id, metadata, title, universal_content_id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_media_fingerprintsTool)

	// page_post_media_fingerprints tool
	// Params object accepts: fingerprint_content_type (pagemedia_fingerprints_fingerprint_content_type_enum_param), metadata (list), source (string), title (string), universal_content_id (string)
	page_post_media_fingerprintsTool := mcp.NewTool("page_post_media_fingerprints",
		mcp.WithDescription("POST media_fingerprints for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"fingerprint_content_type": map[string]any{
					"type": "string",
					"description": "fingerprint_content_type parameter",
					"required": true,
					"enum": []string{ "AM_SONGTRACK", "EPISODE", "MOVIE", "OTHER", "SONGTRACK" },
				},
				"metadata": map[string]any{
					"type": "string",
					"description": "metadata parameter",
					"required": true,
				},
				"source": map[string]any{
					"type": "string",
					"description": "source parameter",
					"required": true,
				},
				"title": map[string]any{
					"type": "string",
					"description": "title parameter",
					"required": true,
				},
				"universal_content_id": map[string]any{
					"type": "string",
					"description": "universal_content_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: fingerprint_content_type (enum) [AM_SONGTRACK, EPISODE, MOVIE, OTHER, SONGTRACK] [required], metadata (list) [required], source (string) [required], title (string) [required], universal_content_id (string)"),
		),
	)
	tools = append(tools, page_post_media_fingerprintsTool)

	// page_post_message_attachments tool
	// Params object accepts: message (Object), platform (pagemessage_attachments_platform_enum_param)
	page_post_message_attachmentsTool := mcp.NewTool("page_post_message_attachments",
		mcp.WithDescription("POST message_attachments for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"message": map[string]any{
					"type": "object",
					"description": "message parameter",
					"required": true,
				},
				"platform": map[string]any{
					"type": "string",
					"description": "platform parameter",
					"enum": []string{ "INSTAGRAM", "MESSENGER" },
				},
			}),
			mcp.Description("Parameters object containing: message (object) [required], platform (enum) [INSTAGRAM, MESSENGER]"),
		),
	)
	tools = append(tools, page_post_message_attachmentsTool)

	// page_delete_message_templates tool
	// Params object accepts: name (string), template_id (string)
	page_delete_message_templatesTool := mcp.NewTool("page_delete_message_templates",
		mcp.WithDescription("DELETE message_templates for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
					"required": true,
				},
				"template_id": map[string]any{
					"type": "string",
					"description": "template_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: name (string) [required], template_id (string)"),
		),
	)
	tools = append(tools, page_delete_message_templatesTool)

	// page_get_message_templates tool
	// Available fields for MessengerBusinessTemplate: category, components, creation_time, id, language, language_count, last_updated_time, library_template_name, name, rejected_reason, rejection_reasons, specific_rejection_reasons, status
	// Params object accepts: category (list<pagemessage_templates_category_enum_param>), content (string), language (list<string>), name (string), name_or_content (string), status (list<pagemessage_templates_status_enum_param>)
	page_get_message_templatesTool := mcp.NewTool("page_get_message_templates",
		mcp.WithDescription("GET message_templates for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"category": map[string]any{
					"type": "array",
					"description": "category parameter",
					"enum": []string{ "UTILITY" },
					"items": map[string]any{"type": "string"},
				},
				"content": map[string]any{
					"type": "string",
					"description": "content parameter",
				},
				"language": map[string]any{
					"type": "array",
					"description": "language parameter",
					"items": map[string]any{"type": "string"},
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
				},
				"name_or_content": map[string]any{
					"type": "string",
					"description": "name_or_content parameter",
				},
				"status": map[string]any{
					"type": "array",
					"description": "status parameter",
					"enum": []string{ "APPROVED", "ARCHIVED", "DELETED", "DISABLED", "IN_APPEAL", "LIMIT_EXCEEDED", "PAUSED", "PENDING", "PENDING_DELETION", "REJECTED" },
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: category (array<enum>) [UTILITY], content (string), language (array<string>), name (string), name_or_content (string), status (array<enum>) [APPROVED, ARCHIVED, DELETED, DISABLED, IN_APPEAL, ...]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for MessengerBusinessTemplate objects. Available fields: category, components, creation_time, id, language, language_count, last_updated_time, library_template_name, name, rejected_reason, rejection_reasons, specific_rejection_reasons, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_message_templatesTool)

	// page_post_message_templates tool
	// Params object accepts: category (pagemessage_templates_category_enum_param), components (list<map>), language (string), library_template_button_inputs (list<map>), library_template_name (string), name (string)
	page_post_message_templatesTool := mcp.NewTool("page_post_message_templates",
		mcp.WithDescription("POST message_templates for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"category": map[string]any{
					"type": "string",
					"description": "category parameter",
					"required": true,
					"enum": []string{ "UTILITY" },
				},
				"components": map[string]any{
					"type": "array",
					"description": "components parameter",
					"items": map[string]any{"type": "object"},
				},
				"language": map[string]any{
					"type": "string",
					"description": "language parameter",
					"required": true,
				},
				"library_template_button_inputs": map[string]any{
					"type": "array",
					"description": "library_template_button_inputs parameter",
					"items": map[string]any{"type": "object"},
				},
				"library_template_name": map[string]any{
					"type": "string",
					"description": "library_template_name parameter",
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: category (enum) [UTILITY] [required], components (array<object>), language (string) [required], library_template_button_inputs (array<object>), library_template_name (string), name (string) [required]"),
		),
	)
	tools = append(tools, page_post_message_templatesTool)

	// page_post_messages tool
	// Params object accepts: message (Object), messaging_type (pagemessages_messaging_type_enum_param), notification_type (pagemessages_notification_type_enum_param), payload (string), persona_id (string), recipient (Object), reply_to (string), sender_action (pagemessages_sender_action_enum_param), suggestion_action (pagemessages_suggestion_action_enum_param), tag (Object), thread_control (Object)
	page_post_messagesTool := mcp.NewTool("page_post_messages",
		mcp.WithDescription("POST messages for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"message": map[string]any{
					"type": "object",
					"description": "message parameter",
				},
				"messaging_type": map[string]any{
					"type": "string",
					"description": "messaging_type parameter",
					"enum": []string{ "MESSAGE_TAG", "RESPONSE", "UPDATE", "UTILITY" },
				},
				"notification_type": map[string]any{
					"type": "string",
					"description": "notification_type parameter",
					"enum": []string{ "NO_PUSH", "REGULAR", "SILENT_PUSH" },
				},
				"payload": map[string]any{
					"type": "string",
					"description": "payload parameter",
				},
				"persona_id": map[string]any{
					"type": "string",
					"description": "persona_id parameter",
				},
				"recipient": map[string]any{
					"type": "object",
					"description": "recipient parameter",
					"required": true,
				},
				"reply_to": map[string]any{
					"type": "string",
					"description": "reply_to parameter",
				},
				"sender_action": map[string]any{
					"type": "string",
					"description": "sender_action parameter",
					"enum": []string{ "MARK_SEEN", "REACT", "TYPING_OFF", "TYPING_ON", "UNREACT" },
				},
				"suggestion_action": map[string]any{
					"type": "string",
					"description": "suggestion_action parameter",
					"enum": []string{ "ACCEPT", "DISMISS", "IMPRESSION" },
				},
				"tag": map[string]any{
					"type": "object",
					"description": "tag parameter",
				},
				"thread_control": map[string]any{
					"type": "object",
					"description": "thread_control parameter",
				},
			}),
			mcp.Description("Parameters object containing: message (object), messaging_type (enum) [MESSAGE_TAG, RESPONSE, UPDATE, UTILITY], notification_type (enum) [NO_PUSH, REGULAR, SILENT_PUSH], payload (string), persona_id (string), recipient (object) [required], reply_to (string), sender_action (enum) [MARK_SEEN, REACT, TYPING_OFF, TYPING_ON, UNREACT], suggestion_action (enum) [ACCEPT, DISMISS, IMPRESSION], tag (object), thread_control (object)"),
		),
	)
	tools = append(tools, page_post_messagesTool)

	// page_get_messaging_feature_review tool
	// Available fields for MessagingFeatureReview: feature, status
	page_get_messaging_feature_reviewTool := mcp.NewTool("page_get_messaging_feature_review",
		mcp.WithDescription("GET messaging_feature_review for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for MessagingFeatureReview objects. Available fields: feature, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_messaging_feature_reviewTool)

	// page_get_messenger_call_settings tool
	// Available fields for MessengerCallSettings: audio_enabled, call_hours, call_routing, icon_enabled
	page_get_messenger_call_settingsTool := mcp.NewTool("page_get_messenger_call_settings",
		mcp.WithDescription("GET messenger_call_settings for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for MessengerCallSettings objects. Available fields: audio_enabled, call_hours, call_routing, icon_enabled"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_messenger_call_settingsTool)

	// page_post_messenger_call_settings tool
	// Params object accepts: audio_enabled (bool), call_hours (map), call_routing (map), icon_enabled (bool)
	page_post_messenger_call_settingsTool := mcp.NewTool("page_post_messenger_call_settings",
		mcp.WithDescription("POST messenger_call_settings for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"audio_enabled": map[string]any{
					"type": "boolean",
					"description": "audio_enabled parameter",
				},
				"call_hours": map[string]any{
					"type": "object",
					"description": "call_hours parameter",
				},
				"call_routing": map[string]any{
					"type": "object",
					"description": "call_routing parameter",
				},
				"icon_enabled": map[string]any{
					"type": "boolean",
					"description": "icon_enabled parameter",
				},
			}),
			mcp.Description("Parameters object containing: audio_enabled (boolean), call_hours (object), call_routing (object), icon_enabled (boolean)"),
		),
	)
	tools = append(tools, page_post_messenger_call_settingsTool)

	// page_get_messenger_lead_forms tool
	// Available fields for MessengerAdsPartialAutomatedStepList: fblead_form, first_step_id, id, page, privacy_url, reminder_text, stop_question_message
	page_get_messenger_lead_formsTool := mcp.NewTool("page_get_messenger_lead_forms",
		mcp.WithDescription("GET messenger_lead_forms for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for MessengerAdsPartialAutomatedStepList objects. Available fields: fblead_form, first_step_id, id, page, privacy_url, reminder_text, stop_question_message"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_messenger_lead_formsTool)

	// page_post_messenger_lead_forms tool
	// Params object accepts: account_id (unsigned int), block_send_api (bool), exit_keyphrases (string), handover_app_id (unsigned int), handover_summary (bool), privacy_url (string), reminder_text (string), step_list (list<map>), stop_question_message (string), template_name (string), tracking_parameters (map)
	page_post_messenger_lead_formsTool := mcp.NewTool("page_post_messenger_lead_forms",
		mcp.WithDescription("POST messenger_lead_forms for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"account_id": map[string]any{
					"type": "integer",
					"description": "account_id parameter",
				},
				"block_send_api": map[string]any{
					"type": "boolean",
					"description": "block_send_api parameter",
				},
				"exit_keyphrases": map[string]any{
					"type": "string",
					"description": "exit_keyphrases parameter",
				},
				"handover_app_id": map[string]any{
					"type": "integer",
					"description": "handover_app_id parameter",
				},
				"handover_summary": map[string]any{
					"type": "boolean",
					"description": "handover_summary parameter",
				},
				"privacy_url": map[string]any{
					"type": "string",
					"description": "privacy_url parameter",
				},
				"reminder_text": map[string]any{
					"type": "string",
					"description": "reminder_text parameter",
				},
				"step_list": map[string]any{
					"type": "array",
					"description": "step_list parameter",
					"required": true,
					"items": map[string]any{"type": "object"},
				},
				"stop_question_message": map[string]any{
					"type": "string",
					"description": "stop_question_message parameter",
				},
				"template_name": map[string]any{
					"type": "string",
					"description": "template_name parameter",
				},
				"tracking_parameters": map[string]any{
					"type": "object",
					"description": "tracking_parameters parameter",
				},
			}),
			mcp.Description("Parameters object containing: account_id (integer), block_send_api (boolean), exit_keyphrases (string), handover_app_id (integer), handover_summary (boolean), privacy_url (string), reminder_text (string), step_list (array<object>) [required], stop_question_message (string), template_name (string), tracking_parameters (object)"),
		),
	)
	tools = append(tools, page_post_messenger_lead_formsTool)

	// page_delete_messenger_profile tool
	// Params object accepts: fields (list<pagemessenger_profile_fields_enum_param>), platform (pagemessenger_profile_platform_enum_param)
	page_delete_messenger_profileTool := mcp.NewTool("page_delete_messenger_profile",
		mcp.WithDescription("DELETE messenger_profile for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"fields": map[string]any{
					"type": "array",
					"description": "fields parameter",
					"required": true,
					"enum": []string{ "ACCOUNT_LINKING_URL", "COMMANDS", "DESCRIPTION", "GET_STARTED", "GREETING", "HOME_URL", "ICE_BREAKERS", "PERSISTENT_MENU", "PLATFORM", "SUBJECT_TO_NEW_EU_PRIVACY_RULES", "TITLE", "WHITELISTED_DOMAINS" },
					"items": map[string]any{"type": "string"},
				},
				"platform": map[string]any{
					"type": "string",
					"description": "platform parameter",
					"enum": []string{ "INSTAGRAM", "MESSENGER" },
				},
			}),
			mcp.Description("Parameters object containing: fields (array<enum>) [ACCOUNT_LINKING_URL, COMMANDS, DESCRIPTION, GET_STARTED, GREETING, ...] [required], platform (enum) [INSTAGRAM, MESSENGER]"),
		),
	)
	tools = append(tools, page_delete_messenger_profileTool)

	// page_get_messenger_profile tool
	// Available fields for MessengerProfile: account_linking_url, commands, get_started, greeting, ice_breakers, persistent_menu, subject_to_new_eu_privacy_rules, whitelisted_domains
	// Params object accepts: platform (pagemessenger_profile_platform_enum_param)
	page_get_messenger_profileTool := mcp.NewTool("page_get_messenger_profile",
		mcp.WithDescription("GET messenger_profile for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"platform": map[string]any{
					"type": "string",
					"description": "platform parameter",
					"enum": []string{ "INSTAGRAM", "MESSENGER" },
				},
			}),
			mcp.Description("Parameters object containing: platform (enum) [INSTAGRAM, MESSENGER]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for MessengerProfile objects. Available fields: account_linking_url, commands, get_started, greeting, ice_breakers, persistent_menu, subject_to_new_eu_privacy_rules, whitelisted_domains"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_messenger_profileTool)

	// page_post_messenger_profile tool
	// Params object accepts: account_linking_url (string), commands (list<Object>), description (list<Object>), get_started (Object), greeting (list<Object>), ice_breakers (list<map>), persistent_menu (list<Object>), platform (pagemessenger_profile_platform_enum_param), title (list<Object>), whitelisted_domains (list<string>)
	page_post_messenger_profileTool := mcp.NewTool("page_post_messenger_profile",
		mcp.WithDescription("POST messenger_profile for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"account_linking_url": map[string]any{
					"type": "string",
					"description": "account_linking_url parameter",
				},
				"commands": map[string]any{
					"type": "array",
					"description": "commands parameter",
					"items": map[string]any{"type": "object"},
				},
				"description": map[string]any{
					"type": "array",
					"description": "description parameter",
					"items": map[string]any{"type": "object"},
				},
				"get_started": map[string]any{
					"type": "object",
					"description": "get_started parameter",
				},
				"greeting": map[string]any{
					"type": "array",
					"description": "greeting parameter",
					"items": map[string]any{"type": "object"},
				},
				"ice_breakers": map[string]any{
					"type": "array",
					"description": "ice_breakers parameter",
					"items": map[string]any{"type": "object"},
				},
				"persistent_menu": map[string]any{
					"type": "array",
					"description": "persistent_menu parameter",
					"items": map[string]any{"type": "object"},
				},
				"platform": map[string]any{
					"type": "string",
					"description": "platform parameter",
					"enum": []string{ "INSTAGRAM", "MESSENGER" },
				},
				"title": map[string]any{
					"type": "array",
					"description": "title parameter",
					"items": map[string]any{"type": "object"},
				},
				"whitelisted_domains": map[string]any{
					"type": "array",
					"description": "whitelisted_domains parameter",
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: account_linking_url (string), commands (array<object>), description (array<object>), get_started (object), greeting (array<object>), ice_breakers (array<object>), persistent_menu (array<object>), platform (enum) [INSTAGRAM, MESSENGER], title (array<object>), whitelisted_domains (array<string>)"),
		),
	)
	tools = append(tools, page_post_messenger_profileTool)

	// page_post_moderate_conversations tool
	// Params object accepts: actions (list<pagemoderate_conversations_actions_enum_param>), user_ids (list<map>)
	page_post_moderate_conversationsTool := mcp.NewTool("page_post_moderate_conversations",
		mcp.WithDescription("POST moderate_conversations for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"actions": map[string]any{
					"type": "array",
					"description": "actions parameter",
					"required": true,
					"enum": []string{ "BAN_USER", "BLOCK_USER", "MOVE_TO_SPAM", "UNBAN_USER", "UNBLOCK_USER" },
					"items": map[string]any{"type": "string"},
				},
				"user_ids": map[string]any{
					"type": "array",
					"description": "user_ids parameter",
					"required": true,
					"items": map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: actions (array<enum>) [BAN_USER, BLOCK_USER, MOVE_TO_SPAM, UNBAN_USER, UNBLOCK_USER] [required], user_ids (array<object>) [required]"),
		),
	)
	tools = append(tools, page_post_moderate_conversationsTool)

	// page_post_nlp_configs tool
	// Params object accepts: api_version (Object), custom_token (string), model (pagenlp_configs_model_enum_param), n_best (unsigned int), nlp_enabled (bool), other_language_support (map), verbose (bool)
	page_post_nlp_configsTool := mcp.NewTool("page_post_nlp_configs",
		mcp.WithDescription("POST nlp_configs for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"api_version": map[string]any{
					"type": "object",
					"description": "api_version parameter",
				},
				"custom_token": map[string]any{
					"type": "string",
					"description": "custom_token parameter",
				},
				"model": map[string]any{
					"type": "string",
					"description": "model parameter",
					"enum": []string{ "ARABIC", "CHINESE", "CROATIAN", "CUSTOM", "DANISH", "DUTCH", "ENGLISH", "FRENCH_STANDARD", "GEORGIAN", "GERMAN_STANDARD", "GREEK", "HEBREW", "HUNGARIAN", "IRISH", "ITALIAN_STANDARD", "KOREAN", "NORWEGIAN_BOKMAL", "POLISH", "PORTUGUESE", "ROMANIAN", "SPANISH", "SWEDISH", "VIETNAMESE" },
				},
				"n_best": map[string]any{
					"type": "integer",
					"description": "n_best parameter",
				},
				"nlp_enabled": map[string]any{
					"type": "boolean",
					"description": "nlp_enabled parameter",
				},
				"other_language_support": map[string]any{
					"type": "object",
					"description": "other_language_support parameter",
				},
				"verbose": map[string]any{
					"type": "boolean",
					"description": "verbose parameter",
				},
			}),
			mcp.Description("Parameters object containing: api_version (object), custom_token (string), model (enum) [ARABIC, CHINESE, CROATIAN, CUSTOM, DANISH, ...], n_best (integer), nlp_enabled (boolean), other_language_support (object), verbose (boolean)"),
		),
	)
	tools = append(tools, page_post_nlp_configsTool)

	// page_get_notification_message_tokens tool
	// Available fields for UserPageOneTimeOptInTokenSettings: creation_timestamp, next_eligible_time, notification_messages_frequency, notification_messages_reoptin, notification_messages_timezone, notification_messages_token, recipient_id, token_expiry_timestamp, topic_title, user_token_status
	page_get_notification_message_tokensTool := mcp.NewTool("page_get_notification_message_tokens",
		mcp.WithDescription("GET notification_message_tokens for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for UserPageOneTimeOptInTokenSettings objects. Available fields: creation_timestamp, next_eligible_time, notification_messages_frequency, notification_messages_reoptin, notification_messages_timezone, notification_messages_token, recipient_id, token_expiry_timestamp, topic_title, user_token_status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_notification_message_tokensTool)

	// page_post_notification_messages_dev_support tool
	// Params object accepts: developer_action (pagenotification_messages_dev_support_developer_action_enum_param), recipient (Object)
	page_post_notification_messages_dev_supportTool := mcp.NewTool("page_post_notification_messages_dev_support",
		mcp.WithDescription("POST notification_messages_dev_support for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"developer_action": map[string]any{
					"type": "string",
					"description": "developer_action parameter",
					"required": true,
					"enum": []string{ "ENABLE_FOLLOWUP_MESSAGE" },
				},
				"recipient": map[string]any{
					"type": "object",
					"description": "recipient parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: developer_action (enum) [ENABLE_FOLLOWUP_MESSAGE] [required], recipient (object) [required]"),
		),
	)
	tools = append(tools, page_post_notification_messages_dev_supportTool)

	// page_get_page_backed_instagram_accounts tool
	// Available fields for IGUser: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url, shopping_product_tag_eligibility, shopping_review_status, username, website
	page_get_page_backed_instagram_accountsTool := mcp.NewTool("page_get_page_backed_instagram_accounts",
		mcp.WithDescription("GET page_backed_instagram_accounts for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGUser objects. Available fields: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_page_backed_instagram_accountsTool)

	// page_post_page_backed_instagram_accounts tool
	page_post_page_backed_instagram_accountsTool := mcp.NewTool("page_post_page_backed_instagram_accounts",
		mcp.WithDescription("POST page_backed_instagram_accounts for Page"),
	)
	tools = append(tools, page_post_page_backed_instagram_accountsTool)

	// page_post_page_whatsapp_number_verification tool
	// Params object accepts: verification_code (string), whatsapp_number (string)
	page_post_page_whatsapp_number_verificationTool := mcp.NewTool("page_post_page_whatsapp_number_verification",
		mcp.WithDescription("POST page_whatsapp_number_verification for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"verification_code": map[string]any{
					"type": "string",
					"description": "verification_code parameter",
				},
				"whatsapp_number": map[string]any{
					"type": "string",
					"description": "whatsapp_number parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: verification_code (string), whatsapp_number (string) [required]"),
		),
	)
	tools = append(tools, page_post_page_whatsapp_number_verificationTool)

	// page_post_pass_thread_control tool
	// Params object accepts: metadata (string), recipient (Object), target_app_id (string)
	page_post_pass_thread_controlTool := mcp.NewTool("page_post_pass_thread_control",
		mcp.WithDescription("POST pass_thread_control for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"metadata": map[string]any{
					"type": "string",
					"description": "metadata parameter",
				},
				"recipient": map[string]any{
					"type": "object",
					"description": "recipient parameter",
					"required": true,
				},
				"target_app_id": map[string]any{
					"type": "string",
					"description": "target_app_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: metadata (string), recipient (object) [required], target_app_id (string)"),
		),
	)
	tools = append(tools, page_post_pass_thread_controlTool)

	// page_get_personas tool
	// Available fields for Persona: id, name, profile_picture_url
	page_get_personasTool := mcp.NewTool("page_get_personas",
		mcp.WithDescription("GET personas for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Persona objects. Available fields: id, name, profile_picture_url"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_personasTool)

	// page_post_personas tool
	// Params object accepts: name (string), profile_picture_url (string)
	page_post_personasTool := mcp.NewTool("page_post_personas",
		mcp.WithDescription("POST personas for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
					"required": true,
				},
				"profile_picture_url": map[string]any{
					"type": "string",
					"description": "profile_picture_url parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: name (string) [required], profile_picture_url (string) [required]"),
		),
	)
	tools = append(tools, page_post_personasTool)

	// page_post_photo_stories tool
	// Params object accepts: photo_id (string)
	page_post_photo_storiesTool := mcp.NewTool("page_post_photo_stories",
		mcp.WithDescription("POST photo_stories for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"photo_id": map[string]any{
					"type": "string",
					"description": "photo_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: photo_id (string)"),
		),
	)
	tools = append(tools, page_post_photo_storiesTool)

	// page_get_photos tool
	// Available fields for Photo: album, alt_text, alt_text_custom, backdated_time, backdated_time_granularity, can_backdate, can_delete, can_tag, created_time, event, from, height, icon, id, images, link, name, name_tags, page_story_id, picture, place, position, source, target, updated_time, webp_images, width
	// Params object accepts: biz_tag_id (unsigned int), business_id (string), type (pagephotos_type_enum_param)
	page_get_photosTool := mcp.NewTool("page_get_photos",
		mcp.WithDescription("GET photos for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"biz_tag_id": map[string]any{
					"type": "integer",
					"description": "biz_tag_id parameter",
				},
				"business_id": map[string]any{
					"type": "string",
					"description": "business_id parameter",
				},
				"type": map[string]any{
					"type": "string",
					"description": "type parameter",
					"enum": []string{ "profile", "tagged", "uploaded" },
				},
			}),
			mcp.Description("Parameters object containing: biz_tag_id (integer), business_id (string), type (enum) [profile, tagged, uploaded]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Photo objects. Available fields: album, alt_text, alt_text_custom, backdated_time, backdated_time_granularity, can_backdate, can_delete, can_tag, created_time, event, from, height, icon, id, images (and 12 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_photosTool)

	// page_post_photos tool
	// Params object accepts: aid (string), allow_spherical_photo (bool), alt_text_custom (string), android_key_hash (string), application_id (string), attempt (unsigned int), audience_exp (bool), backdated_time (datetime), backdated_time_granularity (pagephotos_backdated_time_granularity_enum_param), caption (string), composer_session_id (string), direct_share_status (unsigned int), feed_targeting (Object), filter_type (unsigned int), full_res_is_coming_later (bool), initial_view_heading_override_degrees (unsigned int), initial_view_pitch_override_degrees (unsigned int), initial_view_vertical_fov_override_degrees (unsigned int), ios_bundle_id (string), is_explicit_location (bool), is_explicit_place (bool), location_source_id (string), manual_privacy (bool), message (string), name (string), nectar_module (string), no_story (bool), offline_id (unsigned int), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_set_profile_badge (bool), og_suggestion_mechanism (string), parent_media_id (unsigned int), place (Object), privacy (string), profile_id (int), provenance_info (map), proxied_app_id (string), published (bool), qn (string), scheduled_publish_time (unsigned int), spherical_metadata (map), sponsor_id (string), sponsor_relationship (unsigned int), tags (list<Object>), target_id (int), targeting (Object), temporary (bool), time_since_original_post (unsigned int), uid (int), unpublished_content_type (pagephotos_unpublished_content_type_enum_param), url (string), user_selected_tags (bool), vault_image_id (string)
	page_post_photosTool := mcp.NewTool("page_post_photos",
		mcp.WithDescription("POST photos for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"aid": map[string]any{
					"type": "string",
					"description": "aid parameter",
				},
				"allow_spherical_photo": map[string]any{
					"type": "boolean",
					"description": "allow_spherical_photo parameter",
				},
				"alt_text_custom": map[string]any{
					"type": "string",
					"description": "alt_text_custom parameter",
				},
				"android_key_hash": map[string]any{
					"type": "string",
					"description": "android_key_hash parameter",
				},
				"application_id": map[string]any{
					"type": "string",
					"description": "application_id parameter",
				},
				"attempt": map[string]any{
					"type": "integer",
					"description": "attempt parameter",
				},
				"audience_exp": map[string]any{
					"type": "boolean",
					"description": "audience_exp parameter",
				},
				"backdated_time": map[string]any{
					"type": "string",
					"description": "backdated_time parameter",
				},
				"backdated_time_granularity": map[string]any{
					"type": "string",
					"description": "backdated_time_granularity parameter",
					"enum": []string{ "day", "hour", "min", "month", "none", "year" },
				},
				"caption": map[string]any{
					"type": "string",
					"description": "caption parameter",
				},
				"composer_session_id": map[string]any{
					"type": "string",
					"description": "composer_session_id parameter",
				},
				"direct_share_status": map[string]any{
					"type": "integer",
					"description": "direct_share_status parameter",
				},
				"feed_targeting": map[string]any{
					"type": "object",
					"description": "feed_targeting parameter",
				},
				"filter_type": map[string]any{
					"type": "integer",
					"description": "filter_type parameter",
				},
				"full_res_is_coming_later": map[string]any{
					"type": "boolean",
					"description": "full_res_is_coming_later parameter",
				},
				"initial_view_heading_override_degrees": map[string]any{
					"type": "integer",
					"description": "initial_view_heading_override_degrees parameter",
				},
				"initial_view_pitch_override_degrees": map[string]any{
					"type": "integer",
					"description": "initial_view_pitch_override_degrees parameter",
				},
				"initial_view_vertical_fov_override_degrees": map[string]any{
					"type": "integer",
					"description": "initial_view_vertical_fov_override_degrees parameter",
				},
				"ios_bundle_id": map[string]any{
					"type": "string",
					"description": "ios_bundle_id parameter",
				},
				"is_explicit_location": map[string]any{
					"type": "boolean",
					"description": "is_explicit_location parameter",
				},
				"is_explicit_place": map[string]any{
					"type": "boolean",
					"description": "is_explicit_place parameter",
				},
				"location_source_id": map[string]any{
					"type": "string",
					"description": "location_source_id parameter",
				},
				"manual_privacy": map[string]any{
					"type": "boolean",
					"description": "manual_privacy parameter",
				},
				"message": map[string]any{
					"type": "string",
					"description": "message parameter",
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
				},
				"nectar_module": map[string]any{
					"type": "string",
					"description": "nectar_module parameter",
				},
				"no_story": map[string]any{
					"type": "boolean",
					"description": "no_story parameter",
				},
				"offline_id": map[string]any{
					"type": "integer",
					"description": "offline_id parameter",
				},
				"og_action_type_id": map[string]any{
					"type": "string",
					"description": "og_action_type_id parameter",
				},
				"og_icon_id": map[string]any{
					"type": "string",
					"description": "og_icon_id parameter",
				},
				"og_object_id": map[string]any{
					"type": "string",
					"description": "og_object_id parameter",
				},
				"og_phrase": map[string]any{
					"type": "string",
					"description": "og_phrase parameter",
				},
				"og_set_profile_badge": map[string]any{
					"type": "boolean",
					"description": "og_set_profile_badge parameter",
				},
				"og_suggestion_mechanism": map[string]any{
					"type": "string",
					"description": "og_suggestion_mechanism parameter",
				},
				"parent_media_id": map[string]any{
					"type": "integer",
					"description": "parent_media_id parameter",
				},
				"place": map[string]any{
					"type": "object",
					"description": "place parameter",
				},
				"privacy": map[string]any{
					"type": "string",
					"description": "privacy parameter",
				},
				"profile_id": map[string]any{
					"type": "integer",
					"description": "profile_id parameter",
				},
				"provenance_info": map[string]any{
					"type": "object",
					"description": "provenance_info parameter",
				},
				"proxied_app_id": map[string]any{
					"type": "string",
					"description": "proxied_app_id parameter",
				},
				"published": map[string]any{
					"type": "boolean",
					"description": "published parameter",
				},
				"qn": map[string]any{
					"type": "string",
					"description": "qn parameter",
				},
				"scheduled_publish_time": map[string]any{
					"type": "integer",
					"description": "scheduled_publish_time parameter",
				},
				"spherical_metadata": map[string]any{
					"type": "object",
					"description": "spherical_metadata parameter",
				},
				"sponsor_id": map[string]any{
					"type": "string",
					"description": "sponsor_id parameter",
				},
				"sponsor_relationship": map[string]any{
					"type": "integer",
					"description": "sponsor_relationship parameter",
				},
				"tags": map[string]any{
					"type": "array",
					"description": "tags parameter",
					"items": map[string]any{"type": "object"},
				},
				"target_id": map[string]any{
					"type": "integer",
					"description": "target_id parameter",
				},
				"targeting": map[string]any{
					"type": "object",
					"description": "targeting parameter",
				},
				"temporary": map[string]any{
					"type": "boolean",
					"description": "temporary parameter",
				},
				"time_since_original_post": map[string]any{
					"type": "integer",
					"description": "time_since_original_post parameter",
				},
				"uid": map[string]any{
					"type": "integer",
					"description": "uid parameter",
				},
				"unpublished_content_type": map[string]any{
					"type": "string",
					"description": "unpublished_content_type parameter",
					"enum": []string{ "ADS_POST", "DRAFT", "INLINE_CREATED", "PUBLISHED", "REVIEWABLE_BRANDED_CONTENT", "SCHEDULED", "SCHEDULED_RECURRING" },
				},
				"url": map[string]any{
					"type": "string",
					"description": "url parameter",
				},
				"user_selected_tags": map[string]any{
					"type": "boolean",
					"description": "user_selected_tags parameter",
				},
				"vault_image_id": map[string]any{
					"type": "string",
					"description": "vault_image_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: aid (string), allow_spherical_photo (boolean), alt_text_custom (string), android_key_hash (string), application_id (string), attempt (integer), audience_exp (boolean), backdated_time (datetime), backdated_time_granularity (enum) [day, hour, min, month, none, ...], caption (string), composer_session_id (string), direct_share_status (integer), feed_targeting (object), filter_type (integer), full_res_is_coming_later (boolean), initial_view_heading_override_degrees (integer), initial_view_pitch_override_degrees (integer), initial_view_vertical_fov_override_degrees (integer), ios_bundle_id (string), is_explicit_location (boolean), is_explicit_place (boolean), location_source_id (string), manual_privacy (boolean), message (string), name (string), nectar_module (string), no_story (boolean), offline_id (integer), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_set_profile_badge (boolean), og_suggestion_mechanism (string), parent_media_id (integer), place (object), privacy (string), profile_id (integer), provenance_info (object), proxied_app_id (string), published (boolean), qn (string), scheduled_publish_time (integer), spherical_metadata (object), sponsor_id (string), sponsor_relationship (integer), tags (array<object>), target_id (integer), targeting (object), temporary (boolean), time_since_original_post (integer), uid (integer), unpublished_content_type (enum) [ADS_POST, DRAFT, INLINE_CREATED, PUBLISHED, REVIEWABLE_BRANDED_CONTENT, ...], url (string), user_selected_tags (boolean), vault_image_id (string)"),
		),
	)
	tools = append(tools, page_post_photosTool)

	// page_get_picture tool
	// Available fields for ProfilePictureSource: bottom, cache_key, height, is_silhouette, left, right, top, url, width
	// Params object accepts: height (int), redirect (bool), type (pagepicture_type_enum_param), width (int)
	page_get_pictureTool := mcp.NewTool("page_get_picture",
		mcp.WithDescription("GET picture for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"height": map[string]any{
					"type": "integer",
					"description": "height parameter",
				},
				"redirect": map[string]any{
					"type": "boolean",
					"description": "redirect parameter",
				},
				"type": map[string]any{
					"type": "string",
					"description": "type parameter",
					"enum": []string{ "album", "large", "normal", "small", "square" },
				},
				"width": map[string]any{
					"type": "integer",
					"description": "width parameter",
				},
			}),
			mcp.Description("Parameters object containing: height (integer), redirect (boolean), type (enum) [album, large, normal, small, square], width (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProfilePictureSource objects. Available fields: bottom, cache_key, height, is_silhouette, left, right, top, url, width"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_pictureTool)

	// page_post_picture tool
	// Params object accepts: android_key_hash (string), burn_media_effect (bool), caption (string), composer_session_id (string), frame_entrypoint (string), has_umg (bool), height (unsigned int), ios_bundle_id (string), media_effect_ids (list<int>), media_effect_source_object_id (int), msqrd_mask_id (string), photo (string), picture (string), profile_pic_method (string), profile_pic_source (string), proxied_app_id (int), qn (string), reuse (bool), scaled_crop_rect (Object), set_profile_photo_shield (string), sticker_id (int), sticker_source_object_id (int), suppress_stories (bool), width (unsigned int), x (unsigned int), y (unsigned int)
	page_post_pictureTool := mcp.NewTool("page_post_picture",
		mcp.WithDescription("POST picture for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"android_key_hash": map[string]any{
					"type": "string",
					"description": "android_key_hash parameter",
				},
				"burn_media_effect": map[string]any{
					"type": "boolean",
					"description": "burn_media_effect parameter",
				},
				"caption": map[string]any{
					"type": "string",
					"description": "caption parameter",
				},
				"composer_session_id": map[string]any{
					"type": "string",
					"description": "composer_session_id parameter",
				},
				"frame_entrypoint": map[string]any{
					"type": "string",
					"description": "frame_entrypoint parameter",
				},
				"has_umg": map[string]any{
					"type": "boolean",
					"description": "has_umg parameter",
				},
				"height": map[string]any{
					"type": "integer",
					"description": "height parameter",
				},
				"ios_bundle_id": map[string]any{
					"type": "string",
					"description": "ios_bundle_id parameter",
				},
				"media_effect_ids": map[string]any{
					"type": "array",
					"description": "media_effect_ids parameter",
					"items": map[string]any{"type": "integer"},
				},
				"media_effect_source_object_id": map[string]any{
					"type": "integer",
					"description": "media_effect_source_object_id parameter",
				},
				"msqrd_mask_id": map[string]any{
					"type": "string",
					"description": "msqrd_mask_id parameter",
				},
				"photo": map[string]any{
					"type": "string",
					"description": "photo parameter",
				},
				"picture": map[string]any{
					"type": "string",
					"description": "picture parameter",
				},
				"profile_pic_method": map[string]any{
					"type": "string",
					"description": "profile_pic_method parameter",
				},
				"profile_pic_source": map[string]any{
					"type": "string",
					"description": "profile_pic_source parameter",
				},
				"proxied_app_id": map[string]any{
					"type": "integer",
					"description": "proxied_app_id parameter",
				},
				"qn": map[string]any{
					"type": "string",
					"description": "qn parameter",
				},
				"reuse": map[string]any{
					"type": "boolean",
					"description": "reuse parameter",
				},
				"scaled_crop_rect": map[string]any{
					"type": "object",
					"description": "scaled_crop_rect parameter",
				},
				"set_profile_photo_shield": map[string]any{
					"type": "string",
					"description": "set_profile_photo_shield parameter",
				},
				"sticker_id": map[string]any{
					"type": "integer",
					"description": "sticker_id parameter",
				},
				"sticker_source_object_id": map[string]any{
					"type": "integer",
					"description": "sticker_source_object_id parameter",
				},
				"suppress_stories": map[string]any{
					"type": "boolean",
					"description": "suppress_stories parameter",
				},
				"width": map[string]any{
					"type": "integer",
					"description": "width parameter",
				},
				"x": map[string]any{
					"type": "integer",
					"description": "x parameter",
				},
				"y": map[string]any{
					"type": "integer",
					"description": "y parameter",
				},
			}),
			mcp.Description("Parameters object containing: android_key_hash (string), burn_media_effect (boolean), caption (string), composer_session_id (string), frame_entrypoint (string), has_umg (boolean), height (integer), ios_bundle_id (string), media_effect_ids (array<integer>), media_effect_source_object_id (integer), msqrd_mask_id (string), photo (string), picture (string), profile_pic_method (string), profile_pic_source (string), proxied_app_id (integer), qn (string), reuse (boolean), scaled_crop_rect (object), set_profile_photo_shield (string), sticker_id (integer), sticker_source_object_id (integer), suppress_stories (boolean), width (integer), x (integer), y (integer)"),
		),
	)
	tools = append(tools, page_post_pictureTool)

	// page_get_posts tool
	// Available fields for PagePost: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting, from, full_picture, height, icon, id, instagram_eligibility, is_app_share, is_eligible_for_promotion, is_expired, is_hidden, is_inline_created, is_instagram_eligible, is_popular, is_published, is_spherical, message, message_tags, multi_share_end_card, multi_share_optimized, parent_id, permalink_url, picture, place, privacy, promotable_id, promotion_status, properties, scheduled_publish_time, shares, status_type, story, story_tags, subscribed, target, targeting, timeline_visibility, updated_time, via, video_buying_eligibility, width
	// Params object accepts: include_hidden (bool), limit (unsigned int), q (string), show_expired (bool), with (pageposts_with_enum_param)
	page_get_postsTool := mcp.NewTool("page_get_posts",
		mcp.WithDescription("GET posts for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"include_hidden": map[string]any{
					"type": "boolean",
					"description": "include_hidden parameter",
				},
				"limit": map[string]any{
					"type": "integer",
					"description": "limit parameter",
				},
				"q": map[string]any{
					"type": "string",
					"description": "q parameter",
				},
				"show_expired": map[string]any{
					"type": "boolean",
					"description": "show_expired parameter",
				},
				"with": map[string]any{
					"type": "string",
					"description": "with parameter",
					"enum": []string{ "LOCATION" },
				},
			}),
			mcp.Description("Parameters object containing: include_hidden (boolean), limit (integer), q (string), show_expired (boolean), with (enum) [LOCATION]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PagePost objects. Available fields: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting (and 40 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_postsTool)

	// page_get_product_catalogs tool
	// Available fields for ProductCatalog: ad_account_to_collaborative_ads_share_settings, agency_collaborative_ads_share_settings, business, catalog_store, commerce_merchant_settings, creator_user, da_display_settings, default_image_url, fallback_image_url, feed_count, id, is_catalog_segment, is_local_catalog, name, owner_business, product_count, store_catalog_settings, user_access_expire_time, vertical
	page_get_product_catalogsTool := mcp.NewTool("page_get_product_catalogs",
		mcp.WithDescription("GET product_catalogs for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductCatalog objects. Available fields: ad_account_to_collaborative_ads_share_settings, agency_collaborative_ads_share_settings, business, catalog_store, commerce_merchant_settings, creator_user, da_display_settings, default_image_url, fallback_image_url, feed_count, id, is_catalog_segment, is_local_catalog, name, owner_business (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_product_catalogsTool)

	// page_get_published_posts tool
	// Available fields for PagePost: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting, from, full_picture, height, icon, id, instagram_eligibility, is_app_share, is_eligible_for_promotion, is_expired, is_hidden, is_inline_created, is_instagram_eligible, is_popular, is_published, is_spherical, message, message_tags, multi_share_end_card, multi_share_optimized, parent_id, permalink_url, picture, place, privacy, promotable_id, promotion_status, properties, scheduled_publish_time, shares, status_type, story, story_tags, subscribed, target, targeting, timeline_visibility, updated_time, via, video_buying_eligibility, width
	// Params object accepts: include_hidden (bool), limit (unsigned int), show_expired (bool), with (pagepublished_posts_with_enum_param)
	page_get_published_postsTool := mcp.NewTool("page_get_published_posts",
		mcp.WithDescription("GET published_posts for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"include_hidden": map[string]any{
					"type": "boolean",
					"description": "include_hidden parameter",
				},
				"limit": map[string]any{
					"type": "integer",
					"description": "limit parameter",
				},
				"show_expired": map[string]any{
					"type": "boolean",
					"description": "show_expired parameter",
				},
				"with": map[string]any{
					"type": "string",
					"description": "with parameter",
					"enum": []string{ "LOCATION" },
				},
			}),
			mcp.Description("Parameters object containing: include_hidden (boolean), limit (integer), show_expired (boolean), with (enum) [LOCATION]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PagePost objects. Available fields: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting (and 40 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_published_postsTool)

	// page_post_release_thread_control tool
	// Params object accepts: recipient (Object)
	page_post_release_thread_controlTool := mcp.NewTool("page_post_release_thread_control",
		mcp.WithDescription("POST release_thread_control for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"recipient": map[string]any{
					"type": "object",
					"description": "recipient parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: recipient (object) [required]"),
		),
	)
	tools = append(tools, page_post_release_thread_controlTool)

	// page_post_request_thread_control tool
	// Params object accepts: metadata (string), recipient (Object)
	page_post_request_thread_controlTool := mcp.NewTool("page_post_request_thread_control",
		mcp.WithDescription("POST request_thread_control for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"metadata": map[string]any{
					"type": "string",
					"description": "metadata parameter",
				},
				"recipient": map[string]any{
					"type": "object",
					"description": "recipient parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: metadata (string), recipient (object) [required]"),
		),
	)
	tools = append(tools, page_post_request_thread_controlTool)

	// page_get_roles tool
	// Available fields for User: about, age_range, avatar_2d_profile_picture, birthday, client_business_id, community, cover, currency, education, email, favorite_athletes, favorite_teams, first_name, gender, hometown, id, id_for_avatars, inspirational_people, install_type, installed, is_guest_user, is_work_account, languages, last_name, link, local_news_megaphone_dismiss_status, local_news_subscription_status, locale, location, meeting_for, middle_name, name, name_format, payment_pricepoints, political, profile_pic, quotes, relationship_status, religion, shared_login_upgrade_required_by, short_name, significant_other, sports, supports_donate_button_in_live_video, third_party_id, timezone, token_for_business, updated_time, verified, video_upload_limits, website
	// Params object accepts: include_deactivated (bool), uid (int)
	page_get_rolesTool := mcp.NewTool("page_get_roles",
		mcp.WithDescription("GET roles for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"include_deactivated": map[string]any{
					"type": "boolean",
					"description": "include_deactivated parameter",
				},
				"uid": map[string]any{
					"type": "integer",
					"description": "uid parameter",
				},
			}),
			mcp.Description("Parameters object containing: include_deactivated (boolean), uid (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for User objects. Available fields: about, age_range, avatar_2d_profile_picture, birthday, client_business_id, community, cover, currency, education, email, favorite_athletes, favorite_teams, first_name, gender, hometown (and 36 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_rolesTool)

	// page_get_rtb_dynamic_posts tool
	// Available fields for RTBDynamicPost: child_attachments, created, description, id, image_url, link, message, owner_id, place_id, product_id, title
	page_get_rtb_dynamic_postsTool := mcp.NewTool("page_get_rtb_dynamic_posts",
		mcp.WithDescription("GET rtb_dynamic_posts for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for RTBDynamicPost objects. Available fields: child_attachments, created, description, id, image_url, link, message, owner_id, place_id, product_id, title"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_rtb_dynamic_postsTool)

	// page_get_scheduled_posts tool
	// Available fields for PagePost: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting, from, full_picture, height, icon, id, instagram_eligibility, is_app_share, is_eligible_for_promotion, is_expired, is_hidden, is_inline_created, is_instagram_eligible, is_popular, is_published, is_spherical, message, message_tags, multi_share_end_card, multi_share_optimized, parent_id, permalink_url, picture, place, privacy, promotable_id, promotion_status, properties, scheduled_publish_time, shares, status_type, story, story_tags, subscribed, target, targeting, timeline_visibility, updated_time, via, video_buying_eligibility, width
	page_get_scheduled_postsTool := mcp.NewTool("page_get_scheduled_posts",
		mcp.WithDescription("GET scheduled_posts for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PagePost objects. Available fields: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting (and 40 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_scheduled_postsTool)

	// page_get_secondary_receivers tool
	// Available fields for Application: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline, auth_dialog_perms_explanation, auth_referral_default_activity_privacy, auth_referral_enabled, auth_referral_extended_perms, auth_referral_friend_perms, auth_referral_response_type, auth_referral_user_perms, auto_event_mapping_android, auto_event_mapping_ios, auto_event_setup_enabled, auto_log_app_events_default, auto_log_app_events_enabled, business, canvas_fluid_height, canvas_fluid_width, canvas_url, category, client_config, company, configured_ios_sso, contact_email, created_time, creator_uid, daily_active_users, daily_active_users_rank, deauth_callback_url, default_share_mode, description, enigma_config, financial_id, gdpv4_chrome_custom_tabs_enabled, gdpv4_enabled, gdpv4_nux_content, gdpv4_nux_enabled, has_messenger_product, hosting_url, icon_url, id, ios_bundle_id, ios_sdk_dialog_flows, ios_sdk_error_categories, ios_sfvc_attr, ios_supports_native_proxy_auth_flow, ios_supports_system_auth, ipad_app_store_id, iphone_app_store_id, latest_sdk_version, link, logging_token, logo_url, migrations, mobile_profile_section_url, mobile_web_url, monthly_active_users, monthly_active_users_rank, name, namespace, object_store_urls, owner_business, page_tab_default_name, page_tab_url, photo_url, privacy_policy_url, profile_section_url, property_id, protected_mode_rules, real_time_mode_devices, restrictions, restrictive_data_filter_params, restrictive_data_filter_rules, sdk_update_message, seamless_login, secure_canvas_url, secure_page_tab_url, server_ip_whitelist, smart_login_bookmark_icon_url, smart_login_menu_icon_url, social_discovery, subcategory, suggested_events_setting, supported_platforms, supports_apprequests_fast_app_switch, supports_attribution, supports_implicit_sdk_logging, suppress_native_ios_gdp, terms_of_service_url, url_scheme_suffix, user_support_email, user_support_url, website_url, weekly_active_users
	// Params object accepts: platform (pagesecondary_receivers_platform_enum_param)
	page_get_secondary_receiversTool := mcp.NewTool("page_get_secondary_receivers",
		mcp.WithDescription("GET secondary_receivers for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"platform": map[string]any{
					"type": "string",
					"description": "platform parameter",
					"enum": []string{ "INSTAGRAM", "MESSENGER" },
				},
			}),
			mcp.Description("Parameters object containing: platform (enum) [INSTAGRAM, MESSENGER]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Application objects. Available fields: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline (and 91 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_secondary_receiversTool)

	// page_get_settings tool
	// Available fields for PageSettings: setting, value
	page_get_settingsTool := mcp.NewTool("page_get_settings",
		mcp.WithDescription("GET settings for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PageSettings objects. Available fields: setting, value"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_settingsTool)

	// page_post_settings tool
	// Params object accepts: option (Object)
	page_post_settingsTool := mcp.NewTool("page_post_settings",
		mcp.WithDescription("POST settings for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"option": map[string]any{
					"type": "object",
					"description": "option parameter",
				},
			}),
			mcp.Description("Parameters object containing: option (object)"),
		),
	)
	tools = append(tools, page_post_settingsTool)

	// page_get_shop_setup_status tool
	// Available fields for CommerceMerchantSettingsSetupStatus: deals_setup, marketplace_approval_status, marketplace_approval_status_details, payment_setup, review_status, shop_setup
	page_get_shop_setup_statusTool := mcp.NewTool("page_get_shop_setup_status",
		mcp.WithDescription("GET shop_setup_status for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CommerceMerchantSettingsSetupStatus objects. Available fields: deals_setup, marketplace_approval_status, marketplace_approval_status_details, payment_setup, review_status, shop_setup"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_shop_setup_statusTool)

	// page_get_store_locations tool
	// Available fields for StoreLocation: full_address, hours, id, phone_number, pickup_options, price_range, store_code, zip_code
	page_get_store_locationsTool := mcp.NewTool("page_get_store_locations",
		mcp.WithDescription("GET store_locations for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for StoreLocation objects. Available fields: full_address, hours, id, phone_number, pickup_options, price_range, store_code, zip_code"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_store_locationsTool)

	// page_get_stories tool
	// Available fields for Stories: creation_time, media_id, media_type, post_id, status, url
	// Params object accepts: since (datetime), status (list<pagestories_status_enum_param>), until (datetime)
	page_get_storiesTool := mcp.NewTool("page_get_stories",
		mcp.WithDescription("GET stories for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"since": map[string]any{
					"type": "string",
					"description": "since parameter",
				},
				"status": map[string]any{
					"type": "array",
					"description": "status parameter",
					"enum": []string{ "ARCHIVED", "PUBLISHED" },
					"items": map[string]any{"type": "string"},
				},
				"until": map[string]any{
					"type": "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: since (datetime), status (array<enum>) [ARCHIVED, PUBLISHED], until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Stories objects. Available fields: creation_time, media_id, media_type, post_id, status, url"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_storiesTool)

	// page_delete_subscribed_apps tool
	page_delete_subscribed_appsTool := mcp.NewTool("page_delete_subscribed_apps",
		mcp.WithDescription("DELETE subscribed_apps for Page"),
	)
	tools = append(tools, page_delete_subscribed_appsTool)

	// page_get_subscribed_apps tool
	// Available fields for Application: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline, auth_dialog_perms_explanation, auth_referral_default_activity_privacy, auth_referral_enabled, auth_referral_extended_perms, auth_referral_friend_perms, auth_referral_response_type, auth_referral_user_perms, auto_event_mapping_android, auto_event_mapping_ios, auto_event_setup_enabled, auto_log_app_events_default, auto_log_app_events_enabled, business, canvas_fluid_height, canvas_fluid_width, canvas_url, category, client_config, company, configured_ios_sso, contact_email, created_time, creator_uid, daily_active_users, daily_active_users_rank, deauth_callback_url, default_share_mode, description, enigma_config, financial_id, gdpv4_chrome_custom_tabs_enabled, gdpv4_enabled, gdpv4_nux_content, gdpv4_nux_enabled, has_messenger_product, hosting_url, icon_url, id, ios_bundle_id, ios_sdk_dialog_flows, ios_sdk_error_categories, ios_sfvc_attr, ios_supports_native_proxy_auth_flow, ios_supports_system_auth, ipad_app_store_id, iphone_app_store_id, latest_sdk_version, link, logging_token, logo_url, migrations, mobile_profile_section_url, mobile_web_url, monthly_active_users, monthly_active_users_rank, name, namespace, object_store_urls, owner_business, page_tab_default_name, page_tab_url, photo_url, privacy_policy_url, profile_section_url, property_id, protected_mode_rules, real_time_mode_devices, restrictions, restrictive_data_filter_params, restrictive_data_filter_rules, sdk_update_message, seamless_login, secure_canvas_url, secure_page_tab_url, server_ip_whitelist, smart_login_bookmark_icon_url, smart_login_menu_icon_url, social_discovery, subcategory, suggested_events_setting, supported_platforms, supports_apprequests_fast_app_switch, supports_attribution, supports_implicit_sdk_logging, suppress_native_ios_gdp, terms_of_service_url, url_scheme_suffix, user_support_email, user_support_url, website_url, weekly_active_users
	page_get_subscribed_appsTool := mcp.NewTool("page_get_subscribed_apps",
		mcp.WithDescription("GET subscribed_apps for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Application objects. Available fields: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline (and 91 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_subscribed_appsTool)

	// page_post_subscribed_apps tool
	// Params object accepts: subscribed_fields (list<pagesubscribed_apps_subscribed_fields_enum_param>)
	page_post_subscribed_appsTool := mcp.NewTool("page_post_subscribed_apps",
		mcp.WithDescription("POST subscribed_apps for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"subscribed_fields": map[string]any{
					"type": "array",
					"description": "subscribed_fields parameter",
					"required": true,
					"enum": []string{ "affiliation", "attire", "awards", "bio", "birthday", "call_permission_reply", "calls", "category", "checkins", "company_overview", "conversations", "culinary_team", "current_location", "description", "email", "feature_access_list", "feed", "founded", "general_info", "general_manager", "group_feed", "hometown", "hours", "inbox_labels", "invalid_topic_placeholder", "invoice_access_bank_slip_events", "invoice_access_invoice_change", "invoice_access_invoice_draft_change", "invoice_access_onboarding_status_active", "leadgen", "leadgen_fat", "live_videos", "local_delivery", "location", "marketing_message_delivery_failed", "mcom_invoice_change", "members", "mention", "merchant_review", "message_context", "message_deliveries", "message_echoes", "message_edits", "message_mention", "message_reactions", "message_reads", "message_template_status_update", "messages", "messaging_account_linking", "messaging_appointments", "messaging_checkout_updates", "messaging_customer_information", "messaging_direct_sends", "messaging_fblogin_account_linking", "messaging_feedback", "messaging_game_plays", "messaging_handovers", "messaging_in_thread_lead_form_submit", "messaging_integrity", "messaging_optins", "messaging_optouts", "messaging_payments", "messaging_policy_enforcement", "messaging_postbacks", "messaging_pre_checkouts", "messaging_referrals", "mission", "name", "page_about_story", "page_change_proposal", "page_upcoming_change", "parking", "payment_options", "payment_request_update", "personal_info", "personal_interests", "phone", "picture", "price_range", "product_review", "products", "public_transit", "publisher_subscriptions", "ratings", "registration", "response_feedback", "send_cart", "standby", "user_action", "video_text_question_responses", "videos", "website" },
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: subscribed_fields (array<enum>) [affiliation, attire, awards, bio, birthday, ...] [required]"),
		),
	)
	tools = append(tools, page_post_subscribed_appsTool)

	// page_get_tabs tool
	// Available fields for Tab: application, custom_image_url, custom_name, id, image_url, is_non_connection_landing_tab, is_permanent, link, name, position
	// Params object accepts: tab (list<string>)
	page_get_tabsTool := mcp.NewTool("page_get_tabs",
		mcp.WithDescription("GET tabs for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"tab": map[string]any{
					"type": "array",
					"description": "tab parameter",
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: tab (array<string>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Tab objects. Available fields: application, custom_image_url, custom_name, id, image_url, is_non_connection_landing_tab, is_permanent, link, name, position"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_tabsTool)

	// page_get_tagged tool
	// Available fields for PagePost: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting, from, full_picture, height, icon, id, instagram_eligibility, is_app_share, is_eligible_for_promotion, is_expired, is_hidden, is_inline_created, is_instagram_eligible, is_popular, is_published, is_spherical, message, message_tags, multi_share_end_card, multi_share_optimized, parent_id, permalink_url, picture, place, privacy, promotable_id, promotion_status, properties, scheduled_publish_time, shares, status_type, story, story_tags, subscribed, target, targeting, timeline_visibility, updated_time, via, video_buying_eligibility, width
	page_get_taggedTool := mcp.NewTool("page_get_tagged",
		mcp.WithDescription("GET tagged for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PagePost objects. Available fields: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting (and 40 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_taggedTool)

	// page_post_take_thread_control tool
	// Params object accepts: metadata (string), recipient (Object)
	page_post_take_thread_controlTool := mcp.NewTool("page_post_take_thread_control",
		mcp.WithDescription("POST take_thread_control for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"metadata": map[string]any{
					"type": "string",
					"description": "metadata parameter",
				},
				"recipient": map[string]any{
					"type": "object",
					"description": "recipient parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: metadata (string), recipient (object) [required]"),
		),
	)
	tools = append(tools, page_post_take_thread_controlTool)

	// page_get_thread_owner tool
	// Available fields for PageThreadOwner: thread_owner
	// Params object accepts: recipient (string)
	page_get_thread_ownerTool := mcp.NewTool("page_get_thread_owner",
		mcp.WithDescription("GET thread_owner for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"recipient": map[string]any{
					"type": "string",
					"description": "recipient parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: recipient (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PageThreadOwner objects. Available fields: thread_owner"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_thread_ownerTool)

	// page_get_threads tool
	// Available fields for UnifiedThread: can_reply, folder, former_participants, id, is_subscribed, link, linked_group, message_count, name, participants, scoped_thread_key, senders, snippet, subject, unread_count, updated_time, wallpaper
	// Params object accepts: folder (string), platform (pagethreads_platform_enum_param), tags (list<string>), user_id (string)
	page_get_threadsTool := mcp.NewTool("page_get_threads",
		mcp.WithDescription("GET threads for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"folder": map[string]any{
					"type": "string",
					"description": "folder parameter",
				},
				"platform": map[string]any{
					"type": "string",
					"description": "platform parameter",
					"enum": []string{ "INSTAGRAM", "MESSENGER" },
				},
				"tags": map[string]any{
					"type": "array",
					"description": "tags parameter",
					"items": map[string]any{"type": "string"},
				},
				"user_id": map[string]any{
					"type": "string",
					"description": "user_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: folder (string), platform (enum) [INSTAGRAM, MESSENGER], tags (array<string>), user_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for UnifiedThread objects. Available fields: can_reply, folder, former_participants, id, is_subscribed, link, linked_group, message_count, name, participants, scoped_thread_key, senders, snippet, subject, unread_count (and 2 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_threadsTool)

	// page_post_unlink_accounts tool
	// Params object accepts: psid (string)
	page_post_unlink_accountsTool := mcp.NewTool("page_post_unlink_accounts",
		mcp.WithDescription("POST unlink_accounts for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"psid": map[string]any{
					"type": "string",
					"description": "psid parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: psid (string) [required]"),
		),
	)
	tools = append(tools, page_post_unlink_accountsTool)

	// page_get_video_copyright_rules tool
	// Available fields for VideoCopyrightRule: condition_groups, copyrights, created_date, creator, id, is_in_migration, name
	// Params object accepts: selected_rule_id (string), source (pagevideo_copyright_rules_source_enum_param)
	page_get_video_copyright_rulesTool := mcp.NewTool("page_get_video_copyright_rules",
		mcp.WithDescription("GET video_copyright_rules for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"selected_rule_id": map[string]any{
					"type": "string",
					"description": "selected_rule_id parameter",
				},
				"source": map[string]any{
					"type": "string",
					"description": "source parameter",
					"enum": []string{ "MATCH_SETTINGS_DIALOG", "RULES_SELECTOR", "RULES_TAB" },
				},
			}),
			mcp.Description("Parameters object containing: selected_rule_id (string), source (enum) [MATCH_SETTINGS_DIALOG, RULES_SELECTOR, RULES_TAB]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for VideoCopyrightRule objects. Available fields: condition_groups, copyrights, created_date, creator, id, is_in_migration, name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_video_copyright_rulesTool)

	// page_post_video_copyright_rules tool
	// Params object accepts: condition_groups (list<Object>), name (string)
	page_post_video_copyright_rulesTool := mcp.NewTool("page_post_video_copyright_rules",
		mcp.WithDescription("POST video_copyright_rules for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"condition_groups": map[string]any{
					"type": "array",
					"description": "condition_groups parameter",
					"required": true,
					"items": map[string]any{"type": "object"},
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: condition_groups (array<object>) [required], name (string) [required]"),
		),
	)
	tools = append(tools, page_post_video_copyright_rulesTool)

	// page_post_video_copyrights tool
	// Params object accepts: attribution_id (string), content_category (pagevideo_copyrights_content_category_enum_param), copyright_content_id (string), excluded_ownership_countries (list<string>), excluded_ownership_segments (list<Object>), is_reference_disabled (bool), is_reference_video (bool), monitoring_type (pagevideo_copyrights_monitoring_type_enum_param), ownership_countries (list<string>), rule_id (string), tags (list<string>), whitelisted_ids (list<string>), whitelisted_ig_user_ids (list<string>)
	page_post_video_copyrightsTool := mcp.NewTool("page_post_video_copyrights",
		mcp.WithDescription("POST video_copyrights for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"attribution_id": map[string]any{
					"type": "string",
					"description": "attribution_id parameter",
				},
				"content_category": map[string]any{
					"type": "string",
					"description": "content_category parameter",
					"enum": []string{ "episode", "movie", "web" },
				},
				"copyright_content_id": map[string]any{
					"type": "string",
					"description": "copyright_content_id parameter",
					"required": true,
				},
				"excluded_ownership_countries": map[string]any{
					"type": "array",
					"description": "excluded_ownership_countries parameter",
					"items": map[string]any{"type": "string"},
				},
				"excluded_ownership_segments": map[string]any{
					"type": "array",
					"description": "excluded_ownership_segments parameter",
					"items": map[string]any{"type": "object"},
				},
				"is_reference_disabled": map[string]any{
					"type": "boolean",
					"description": "is_reference_disabled parameter",
				},
				"is_reference_video": map[string]any{
					"type": "boolean",
					"description": "is_reference_video parameter",
				},
				"monitoring_type": map[string]any{
					"type": "string",
					"description": "monitoring_type parameter",
					"enum": []string{ "AUDIO_ONLY", "VIDEO_AND_AUDIO", "VIDEO_ONLY" },
				},
				"ownership_countries": map[string]any{
					"type": "array",
					"description": "ownership_countries parameter",
					"items": map[string]any{"type": "string"},
				},
				"rule_id": map[string]any{
					"type": "string",
					"description": "rule_id parameter",
				},
				"tags": map[string]any{
					"type": "array",
					"description": "tags parameter",
					"items": map[string]any{"type": "string"},
				},
				"whitelisted_ids": map[string]any{
					"type": "array",
					"description": "whitelisted_ids parameter",
					"items": map[string]any{"type": "string"},
				},
				"whitelisted_ig_user_ids": map[string]any{
					"type": "array",
					"description": "whitelisted_ig_user_ids parameter",
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: attribution_id (string), content_category (enum) [episode, movie, web], copyright_content_id (string) [required], excluded_ownership_countries (array<string>), excluded_ownership_segments (array<object>), is_reference_disabled (boolean), is_reference_video (boolean), monitoring_type (enum) [AUDIO_ONLY, VIDEO_AND_AUDIO, VIDEO_ONLY], ownership_countries (array<string>), rule_id (string), tags (array<string>), whitelisted_ids (array<string>), whitelisted_ig_user_ids (array<string>)"),
		),
	)
	tools = append(tools, page_post_video_copyrightsTool)

	// page_get_video_lists tool
	// Available fields for VideoList: creation_time, description, id, last_modified, owner, season_number, thumbnail, title, videos_count
	page_get_video_listsTool := mcp.NewTool("page_get_video_lists",
		mcp.WithDescription("GET video_lists for Page"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for VideoList objects. Available fields: creation_time, description, id, last_modified, owner, season_number, thumbnail, title, videos_count"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_video_listsTool)

	// page_get_video_reels tool
	// Available fields for AdVideo: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html, embeddable, event, expiration, format, from, icon, id, is_crosspost_video, is_crossposting_eligible, is_episode, is_instagram_eligible, is_reference_only, length, live_audience_count, live_status, music_video_copyright, permalink_url, picture, place, post_id, post_views, premiere_living_room_status, privacy, published, scheduled_publish_time, source, spherical, status, title, universal_video_id, updated_time, views
	// Params object accepts: since (datetime), until (datetime)
	page_get_video_reelsTool := mcp.NewTool("page_get_video_reels",
		mcp.WithDescription("GET video_reels for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"since": map[string]any{
					"type": "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type": "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: since (datetime), until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdVideo objects. Available fields: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html (and 32 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_video_reelsTool)

	// page_post_video_reels tool
	// Params object accepts: description (string), feed_targeting (Object), place (string), scheduled_publish_time (datetime), targeting (Object), title (string), upload_phase (pagevideo_reels_upload_phase_enum_param), video_id (string), video_state (pagevideo_reels_video_state_enum_param)
	page_post_video_reelsTool := mcp.NewTool("page_post_video_reels",
		mcp.WithDescription("POST video_reels for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
				},
				"feed_targeting": map[string]any{
					"type": "object",
					"description": "feed_targeting parameter",
				},
				"place": map[string]any{
					"type": "string",
					"description": "place parameter",
				},
				"scheduled_publish_time": map[string]any{
					"type": "string",
					"description": "scheduled_publish_time parameter",
				},
				"targeting": map[string]any{
					"type": "object",
					"description": "targeting parameter",
				},
				"title": map[string]any{
					"type": "string",
					"description": "title parameter",
				},
				"upload_phase": map[string]any{
					"type": "string",
					"description": "upload_phase parameter",
					"required": true,
					"enum": []string{ "FINISH", "START" },
				},
				"video_id": map[string]any{
					"type": "string",
					"description": "video_id parameter",
				},
				"video_state": map[string]any{
					"type": "string",
					"description": "video_state parameter",
					"enum": []string{ "DRAFT", "PUBLISHED", "SCHEDULED" },
				},
			}),
			mcp.Description("Parameters object containing: description (string), feed_targeting (object), place (string), scheduled_publish_time (datetime), targeting (object), title (string), upload_phase (enum) [FINISH, START] [required], video_id (string), video_state (enum) [DRAFT, PUBLISHED, SCHEDULED]"),
		),
	)
	tools = append(tools, page_post_video_reelsTool)

	// page_post_video_stories tool
	// Params object accepts: description (string), feed_targeting (Object), place (string), scheduled_publish_time (datetime), targeting (Object), title (string), upload_phase (pagevideo_stories_upload_phase_enum_param), video_id (string), video_state (pagevideo_stories_video_state_enum_param)
	page_post_video_storiesTool := mcp.NewTool("page_post_video_stories",
		mcp.WithDescription("POST video_stories for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
				},
				"feed_targeting": map[string]any{
					"type": "object",
					"description": "feed_targeting parameter",
				},
				"place": map[string]any{
					"type": "string",
					"description": "place parameter",
				},
				"scheduled_publish_time": map[string]any{
					"type": "string",
					"description": "scheduled_publish_time parameter",
				},
				"targeting": map[string]any{
					"type": "object",
					"description": "targeting parameter",
				},
				"title": map[string]any{
					"type": "string",
					"description": "title parameter",
				},
				"upload_phase": map[string]any{
					"type": "string",
					"description": "upload_phase parameter",
					"required": true,
					"enum": []string{ "FINISH", "START" },
				},
				"video_id": map[string]any{
					"type": "string",
					"description": "video_id parameter",
				},
				"video_state": map[string]any{
					"type": "string",
					"description": "video_state parameter",
					"enum": []string{ "DRAFT", "PUBLISHED", "SCHEDULED" },
				},
			}),
			mcp.Description("Parameters object containing: description (string), feed_targeting (object), place (string), scheduled_publish_time (datetime), targeting (object), title (string), upload_phase (enum) [FINISH, START] [required], video_id (string), video_state (enum) [DRAFT, PUBLISHED, SCHEDULED]"),
		),
	)
	tools = append(tools, page_post_video_storiesTool)

	// page_get_videos tool
	// Available fields for AdVideo: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html, embeddable, event, expiration, format, from, icon, id, is_crosspost_video, is_crossposting_eligible, is_episode, is_instagram_eligible, is_reference_only, length, live_audience_count, live_status, music_video_copyright, permalink_url, picture, place, post_id, post_views, premiere_living_room_status, privacy, published, scheduled_publish_time, source, spherical, status, title, universal_video_id, updated_time, views
	// Params object accepts: type (pagevideos_type_enum_param)
	page_get_videosTool := mcp.NewTool("page_get_videos",
		mcp.WithDescription("GET videos for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"type": map[string]any{
					"type": "string",
					"description": "type parameter",
					"enum": []string{ "TAGGED", "UPLOADED" },
				},
			}),
			mcp.Description("Parameters object containing: type (enum) [TAGGED, UPLOADED]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdVideo objects. Available fields: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html (and 32 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_videosTool)

	// page_post_videos tool
	// Params object accepts: ad_breaks (list), application_id (string), asked_fun_fact_prompt_id (unsigned int), audio_story_wave_animation_handle (string), backdated_post (list), call_to_action (Object), composer_entry_picker (string), composer_entry_point (string), composer_entry_time (unsigned int), composer_session_events_log (string), composer_session_id (string), composer_source_surface (string), composer_type (string), container_type (pagevideos_container_type_enum_param), content_category (pagevideos_content_category_enum_param), content_tags (list<string>), creative_tools (string), crossposted_video_id (string), custom_labels (list<string>), description (string), direct_share_status (unsigned int), embeddable (bool), end_offset (unsigned int), expiration (Object), fbuploader_video_file_chunk (string), feed_targeting (Object), file_size (unsigned int), file_url (string), fisheye_video_cropped (bool), formatting (pagevideos_formatting_enum_param), fov (unsigned int), front_z_rotation (float), fun_fact_prompt_id (string), fun_fact_toastee_id (unsigned int), guide (list<list<unsigned int>>), guide_enabled (bool), initial_heading (unsigned int), initial_pitch (unsigned int), instant_game_entry_point_data (string), is_boost_intended (bool), is_explicit_share (bool), is_group_linking_post (bool), is_partnership_ad (bool), is_voice_clip (bool), location_source_id (string), manual_privacy (bool), multilingual_data (list<Object>), no_story (bool), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_suggestion_mechanism (string), original_fov (unsigned int), original_projection_type (pagevideos_original_projection_type_enum_param), partnership_ad_ad_code (string), publish_event_id (unsigned int), published (bool), reference_only (bool), referenced_sticker_id (string), replace_video_id (string), scheduled_publish_time (unsigned int), secret (bool), slideshow_spec (map), social_actions (bool), source (string), source_instagram_media_id (string), specified_dialect (string), spherical (bool), sponsor_id (string), sponsor_relationship (unsigned int), start_offset (unsigned int), swap_mode (pagevideos_swap_mode_enum_param), targeting (Object), text_format_metadata (string), thumb (file), time_since_original_post (unsigned int), title (string), transcode_setting_properties (string), universal_video_id (string), unpublished_content_type (pagevideos_unpublished_content_type_enum_param), upload_phase (pagevideos_upload_phase_enum_param), upload_session_id (string), upload_setting_properties (string), video_asset_id (string), video_file_chunk (string), video_id_original (string), video_start_time_ms (unsigned int), waterfall_id (string)
	page_post_videosTool := mcp.NewTool("page_post_videos",
		mcp.WithDescription("POST videos for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"ad_breaks": map[string]any{
					"type": "string",
					"description": "ad_breaks parameter",
				},
				"application_id": map[string]any{
					"type": "string",
					"description": "application_id parameter",
				},
				"asked_fun_fact_prompt_id": map[string]any{
					"type": "integer",
					"description": "asked_fun_fact_prompt_id parameter",
				},
				"audio_story_wave_animation_handle": map[string]any{
					"type": "string",
					"description": "audio_story_wave_animation_handle parameter",
				},
				"backdated_post": map[string]any{
					"type": "string",
					"description": "backdated_post parameter",
				},
				"call_to_action": map[string]any{
					"type": "object",
					"description": "call_to_action parameter",
				},
				"composer_entry_picker": map[string]any{
					"type": "string",
					"description": "composer_entry_picker parameter",
				},
				"composer_entry_point": map[string]any{
					"type": "string",
					"description": "composer_entry_point parameter",
				},
				"composer_entry_time": map[string]any{
					"type": "integer",
					"description": "composer_entry_time parameter",
				},
				"composer_session_events_log": map[string]any{
					"type": "string",
					"description": "composer_session_events_log parameter",
				},
				"composer_session_id": map[string]any{
					"type": "string",
					"description": "composer_session_id parameter",
				},
				"composer_source_surface": map[string]any{
					"type": "string",
					"description": "composer_source_surface parameter",
				},
				"composer_type": map[string]any{
					"type": "string",
					"description": "composer_type parameter",
				},
				"container_type": map[string]any{
					"type": "string",
					"description": "container_type parameter",
					"enum": []string{ "ACO_VIDEO_VARIATION", "ADS_AI_GENERATED", "AD_BREAK_PREVIEW", "AD_DERIVATIVE", "AD_LIBRARY_WATERMARK", "ALBUM_MULTIMEDIA_POST", "ALOHA_SUPERFRAME", "APP_REREVIEW_SCREENCAST", "APP_REVIEW_SCREENCAST", "ASSET_MANAGER", "ATLAS_VIDEO", "AUDIO_BROADCAST", "AUDIO_COMMENT", "BROADCAST", "CANVAS", "CMS_MEDIA_MANAGER", "CONTAINED_POST_ATTACHMENT", "CONTAINED_POST_AUDIO_BROADCAST", "CONTAINED_POST_COPYRIGHT_REFERENCE_BROADCAST", "COPYRIGHT_REFERENCE_BROADCAST", "COPYRIGHT_REFERENCE_IG_XPOST_VIDEO", "COPYRIGHT_REFERENCE_VIDEO", "CREATION_ML_PRECREATION", "CREATOR_FAN_CHALLENGE", "CREATOR_STOREFRONT_PERSONALIZED_VIDEO", "DATAGENIX_VIDEO", "DCO_AD_ASSET_FEED", "DCO_AUTOGEN_VIDEO", "DCO_TRIMMED_VIDEO", "DIM_SUM", "DIRECTED_POST_ATTACHMENT", "DIRECT_INBOX", "DROPS_SHOPPING_EVENT_PAGE", "DYNAMIC_ITEM_VIDEO", "DYNAMIC_TEMPLATE_VIDEO", "EVENT_COVER_VIDEO", "EVENT_TOUR", "FACECAST_DVR", "FB_AVATAR_ANIMATED_SATP", "FB_COLLECTIBLE_VIDEO", "FB_SHORTS", "FB_SHORTS_CONTENT_REMIXABLE", "FB_SHORTS_GROUP_POST", "FB_SHORTS_LINKED_PRODUCT", "FB_SHORTS_PMV_POST", "FB_SHORTS_POST", "FB_SHORTS_REMIX_POST", "FUNDRAISER_COVER_VIDEO", "GAME_CLIP", "GIF_TO_VIDEO", "GOODWILL_ANNIVERSARY_DEPRECATED", "GOODWILL_ANNIVERSARY_PROMOTION_DEPRECATED", "GOODWILL_VIDEO_CONTAINED_SHARE", "GOODWILL_VIDEO_PROMOTION", "GOODWILL_VIDEO_SHARE", "GOODWILL_VIDEO_TOKEN_REQUIRED", "GROUP_POST", "HEURISTIC_CLUSTER_VIDEO", "HIGHLIGHT_CLIP_VIDEO", "HORIZON_WORLDS_TV", "HUDDLE_BROADCAST", "IG_REELS_XPV", "IG_STORIES_READER", "INJECTABLE", "INSPIRATION_VIDEO", "INSTAGRAM_VIDEO_COPY", "INSTANT_APPLICATION_PREVIEW", "INSTANT_ARTICLE", "ISSUE_MODULE", "LEARN", "LEGACY", "LEGACY_CONTAINED_POST_BROADCAST", "LIVE_AUDIO_ROOM_BROADCAST", "LIVE_CLIP_PREVIEW", "LIVE_CLIP_WORKCHAT", "LIVE_CREATIVE_KIT_VIDEO", "LIVE_PHOTO", "LOOK_NOW_DEPRECATED", "MARKETPLACE_LISTING_VIDEO", "MARKETPLACE_PRE_RECORDED_VIDEO", "MOMENTS_VIDEO", "MUSIC_CLIP", "MUSIC_CLIP_IN_COMMENT", "MUSIC_CLIP_IN_LIGHTWEIGHT_STATUS", "MUSIC_CLIP_IN_MSGR_NOTE", "MUSIC_CLIP_IN_POLL_OPTION", "MUSIC_CLIP_ON_DATING_PROFILE", "NEO_ASYNC_GAME_VIDEO", "NEW_CONTAINED_POST_BROADCAST", "NO_STORY", "OCULUS_CREATOR_PORTAL", "OCULUS_VENUES_BROADCAST", "ORIGINALITY_SELF_ADVOCACY", "PAGES_COVER_VIDEO", "PAGE_REVIEW_SCREENCAST", "PAGE_SLIDESHOW_VIDEO", "PAID_CONTENT_PREVIEW", "PAID_CONTENT_VIDEO", "PAID_CONTENT_VIDEO__POST", "PIXELCLOUD", "PODCAST_HIGHLIGHT", "PODCAST_ML_PREVIEW", "PODCAST_ML_PREVIEW_NO_NEWSFEED_STORY", "PODCAST_RSS", "PODCAST_RSS_EPHEMERAL", "PODCAST_RSS_NO_NEWSFEED_STORY", "PODCAST_VOICES", "PODCAST_VOICES_NO_NEWSFEED_STORY", "PREMIERE_SOURCE", "PREMIUM_MUSIC_VIDEO_CLIP", "PREMIUM_MUSIC_VIDEO_CROPPED_CLIP", "PREMIUM_MUSIC_VIDEO_NO_NEWSFEED_STORY", "PREMIUM_MUSIC_VIDEO_WITH_NEWSFEED_STORY", "PRIVATE_GALLERY_VIDEO", "PRODUCT_VIDEO", "PROFILE_COVER_VIDEO", "PROFILE_INTRO_CARD", "PROFILE_VIDEO", "PROTON", "QUICK_CLIP_WORKPLACE_POST", "QUICK_PROMOTION", "REPLACE_VIDEO", "SALES_CLIENT_INTERACTION", "SHOWREEL_NATIVE_DUMMY_VIDEO", "SLIDESHOW_ANIMOTO", "SLIDESHOW_SHAKR", "SLIDESHOW_VARIATION_VIDEO", "SOUND_PLATFORM_STREAM", "SRT_ATTACHMENT", "STORIES_VIDEO", "STORYLINE", "STORYLINE_WITH_EXTERNAL_MUSIC", "STORY_ARCHIVE_VIDEO", "STORY_CARD_TEMPLATE", "STREAM_HIGHLIGHTS_VIDEO", "TAROT_DIGEST", "TEMPORARY_UNLISTED", "TEMP_VIDEO_COPYRIGHT_SCAN", "UNLISTED", "UNLISTED_OCULUS", "VIDEO_COMMENT", "VIDEO_COMPOSITION_VARIATION", "VIDEO_CREATIVE_EDITOR_AUTOGEN_AD_VIDEO", "VIDEO_SUPERRES", "VOICES_ARTICLE_VIDEO", "VU_GENERATED_VIDEO", "WOODHENGE", "WORK_KNOWLEDGE_VIDEO", "YOUR_DAY" },
				},
				"content_category": map[string]any{
					"type": "string",
					"description": "content_category parameter",
					"enum": []string{ "BEAUTY_FASHION", "BUSINESS", "CARS_TRUCKS", "COMEDY", "CUTE_ANIMALS", "ENTERTAINMENT", "FAMILY", "FOOD_HEALTH", "HOME", "LIFESTYLE", "MUSIC", "NEWS", "OTHER", "POLITICS", "SCIENCE", "SPORTS", "TECHNOLOGY", "VIDEO_GAMING" },
				},
				"content_tags": map[string]any{
					"type": "array",
					"description": "content_tags parameter",
					"items": map[string]any{"type": "string"},
				},
				"creative_tools": map[string]any{
					"type": "string",
					"description": "creative_tools parameter",
				},
				"crossposted_video_id": map[string]any{
					"type": "string",
					"description": "crossposted_video_id parameter",
				},
				"custom_labels": map[string]any{
					"type": "array",
					"description": "custom_labels parameter",
					"items": map[string]any{"type": "string"},
				},
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
				},
				"direct_share_status": map[string]any{
					"type": "integer",
					"description": "direct_share_status parameter",
				},
				"embeddable": map[string]any{
					"type": "boolean",
					"description": "embeddable parameter",
				},
				"end_offset": map[string]any{
					"type": "integer",
					"description": "end_offset parameter",
				},
				"expiration": map[string]any{
					"type": "object",
					"description": "expiration parameter",
				},
				"fbuploader_video_file_chunk": map[string]any{
					"type": "string",
					"description": "fbuploader_video_file_chunk parameter",
				},
				"feed_targeting": map[string]any{
					"type": "object",
					"description": "feed_targeting parameter",
				},
				"file_size": map[string]any{
					"type": "integer",
					"description": "file_size parameter",
				},
				"file_url": map[string]any{
					"type": "string",
					"description": "file_url parameter",
				},
				"fisheye_video_cropped": map[string]any{
					"type": "boolean",
					"description": "fisheye_video_cropped parameter",
				},
				"formatting": map[string]any{
					"type": "string",
					"description": "formatting parameter",
					"enum": []string{ "MARKDOWN", "PLAINTEXT" },
				},
				"fov": map[string]any{
					"type": "integer",
					"description": "fov parameter",
				},
				"front_z_rotation": map[string]any{
					"type": "number",
					"description": "front_z_rotation parameter",
				},
				"fun_fact_prompt_id": map[string]any{
					"type": "string",
					"description": "fun_fact_prompt_id parameter",
				},
				"fun_fact_toastee_id": map[string]any{
					"type": "integer",
					"description": "fun_fact_toastee_id parameter",
				},
				"guide": map[string]any{
					"type": "array",
					"description": "guide parameter",
					"items": map[string]any{"type": "array"},
				},
				"guide_enabled": map[string]any{
					"type": "boolean",
					"description": "guide_enabled parameter",
				},
				"initial_heading": map[string]any{
					"type": "integer",
					"description": "initial_heading parameter",
				},
				"initial_pitch": map[string]any{
					"type": "integer",
					"description": "initial_pitch parameter",
				},
				"instant_game_entry_point_data": map[string]any{
					"type": "string",
					"description": "instant_game_entry_point_data parameter",
				},
				"is_boost_intended": map[string]any{
					"type": "boolean",
					"description": "is_boost_intended parameter",
				},
				"is_explicit_share": map[string]any{
					"type": "boolean",
					"description": "is_explicit_share parameter",
				},
				"is_group_linking_post": map[string]any{
					"type": "boolean",
					"description": "is_group_linking_post parameter",
				},
				"is_partnership_ad": map[string]any{
					"type": "boolean",
					"description": "is_partnership_ad parameter",
				},
				"is_voice_clip": map[string]any{
					"type": "boolean",
					"description": "is_voice_clip parameter",
				},
				"location_source_id": map[string]any{
					"type": "string",
					"description": "location_source_id parameter",
				},
				"manual_privacy": map[string]any{
					"type": "boolean",
					"description": "manual_privacy parameter",
				},
				"multilingual_data": map[string]any{
					"type": "array",
					"description": "multilingual_data parameter",
					"items": map[string]any{"type": "object"},
				},
				"no_story": map[string]any{
					"type": "boolean",
					"description": "no_story parameter",
				},
				"og_action_type_id": map[string]any{
					"type": "string",
					"description": "og_action_type_id parameter",
				},
				"og_icon_id": map[string]any{
					"type": "string",
					"description": "og_icon_id parameter",
				},
				"og_object_id": map[string]any{
					"type": "string",
					"description": "og_object_id parameter",
				},
				"og_phrase": map[string]any{
					"type": "string",
					"description": "og_phrase parameter",
				},
				"og_suggestion_mechanism": map[string]any{
					"type": "string",
					"description": "og_suggestion_mechanism parameter",
				},
				"original_fov": map[string]any{
					"type": "integer",
					"description": "original_fov parameter",
				},
				"original_projection_type": map[string]any{
					"type": "string",
					"description": "original_projection_type parameter",
					"enum": []string{ "cubemap", "equirectangular", "half_equirectangular" },
				},
				"partnership_ad_ad_code": map[string]any{
					"type": "string",
					"description": "partnership_ad_ad_code parameter",
				},
				"publish_event_id": map[string]any{
					"type": "integer",
					"description": "publish_event_id parameter",
				},
				"published": map[string]any{
					"type": "boolean",
					"description": "published parameter",
				},
				"reference_only": map[string]any{
					"type": "boolean",
					"description": "reference_only parameter",
				},
				"referenced_sticker_id": map[string]any{
					"type": "string",
					"description": "referenced_sticker_id parameter",
				},
				"replace_video_id": map[string]any{
					"type": "string",
					"description": "replace_video_id parameter",
				},
				"scheduled_publish_time": map[string]any{
					"type": "integer",
					"description": "scheduled_publish_time parameter",
				},
				"secret": map[string]any{
					"type": "boolean",
					"description": "secret parameter",
				},
				"slideshow_spec": map[string]any{
					"type": "object",
					"description": "slideshow_spec parameter",
				},
				"social_actions": map[string]any{
					"type": "boolean",
					"description": "social_actions parameter",
				},
				"source": map[string]any{
					"type": "string",
					"description": "source parameter",
				},
				"source_instagram_media_id": map[string]any{
					"type": "string",
					"description": "source_instagram_media_id parameter",
				},
				"specified_dialect": map[string]any{
					"type": "string",
					"description": "specified_dialect parameter",
				},
				"spherical": map[string]any{
					"type": "boolean",
					"description": "spherical parameter",
				},
				"sponsor_id": map[string]any{
					"type": "string",
					"description": "sponsor_id parameter",
				},
				"sponsor_relationship": map[string]any{
					"type": "integer",
					"description": "sponsor_relationship parameter",
				},
				"start_offset": map[string]any{
					"type": "integer",
					"description": "start_offset parameter",
				},
				"swap_mode": map[string]any{
					"type": "string",
					"description": "swap_mode parameter",
					"enum": []string{ "replace" },
				},
				"targeting": map[string]any{
					"type": "object",
					"description": "targeting parameter",
				},
				"text_format_metadata": map[string]any{
					"type": "string",
					"description": "text_format_metadata parameter",
				},
				"thumb": map[string]any{
					"type": "string",
					"description": "thumb parameter",
				},
				"time_since_original_post": map[string]any{
					"type": "integer",
					"description": "time_since_original_post parameter",
				},
				"title": map[string]any{
					"type": "string",
					"description": "title parameter",
				},
				"transcode_setting_properties": map[string]any{
					"type": "string",
					"description": "transcode_setting_properties parameter",
				},
				"universal_video_id": map[string]any{
					"type": "string",
					"description": "universal_video_id parameter",
				},
				"unpublished_content_type": map[string]any{
					"type": "string",
					"description": "unpublished_content_type parameter",
					"enum": []string{ "ADS_POST", "DRAFT", "INLINE_CREATED", "PUBLISHED", "REVIEWABLE_BRANDED_CONTENT", "SCHEDULED", "SCHEDULED_RECURRING" },
				},
				"upload_phase": map[string]any{
					"type": "string",
					"description": "upload_phase parameter",
					"enum": []string{ "cancel", "finish", "start", "transfer" },
				},
				"upload_session_id": map[string]any{
					"type": "string",
					"description": "upload_session_id parameter",
				},
				"upload_setting_properties": map[string]any{
					"type": "string",
					"description": "upload_setting_properties parameter",
				},
				"video_asset_id": map[string]any{
					"type": "string",
					"description": "video_asset_id parameter",
				},
				"video_file_chunk": map[string]any{
					"type": "string",
					"description": "video_file_chunk parameter",
				},
				"video_id_original": map[string]any{
					"type": "string",
					"description": "video_id_original parameter",
				},
				"video_start_time_ms": map[string]any{
					"type": "integer",
					"description": "video_start_time_ms parameter",
				},
				"waterfall_id": map[string]any{
					"type": "string",
					"description": "waterfall_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: ad_breaks (list), application_id (string), asked_fun_fact_prompt_id (integer), audio_story_wave_animation_handle (string), backdated_post (list), call_to_action (object), composer_entry_picker (string), composer_entry_point (string), composer_entry_time (integer), composer_session_events_log (string), composer_session_id (string), composer_source_surface (string), composer_type (string), container_type (enum) [ACO_VIDEO_VARIATION, ADS_AI_GENERATED, AD_BREAK_PREVIEW, AD_DERIVATIVE, AD_LIBRARY_WATERMARK, ...], content_category (enum) [BEAUTY_FASHION, BUSINESS, CARS_TRUCKS, COMEDY, CUTE_ANIMALS, ...], content_tags (array<string>), creative_tools (string), crossposted_video_id (string), custom_labels (array<string>), description (string), direct_share_status (integer), embeddable (boolean), end_offset (integer), expiration (object), fbuploader_video_file_chunk (string), feed_targeting (object), file_size (integer), file_url (string), fisheye_video_cropped (boolean), formatting (enum) [MARKDOWN, PLAINTEXT], fov (integer), front_z_rotation (number), fun_fact_prompt_id (string), fun_fact_toastee_id (integer), guide (array<array<integer>>), guide_enabled (boolean), initial_heading (integer), initial_pitch (integer), instant_game_entry_point_data (string), is_boost_intended (boolean), is_explicit_share (boolean), is_group_linking_post (boolean), is_partnership_ad (boolean), is_voice_clip (boolean), location_source_id (string), manual_privacy (boolean), multilingual_data (array<object>), no_story (boolean), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_suggestion_mechanism (string), original_fov (integer), original_projection_type (enum) [cubemap, equirectangular, half_equirectangular], partnership_ad_ad_code (string), publish_event_id (integer), published (boolean), reference_only (boolean), referenced_sticker_id (string), replace_video_id (string), scheduled_publish_time (integer), secret (boolean), slideshow_spec (object), social_actions (boolean), source (string), source_instagram_media_id (string), specified_dialect (string), spherical (boolean), sponsor_id (string), sponsor_relationship (integer), start_offset (integer), swap_mode (enum) [replace], targeting (object), text_format_metadata (string), thumb (file), time_since_original_post (integer), title (string), transcode_setting_properties (string), universal_video_id (string), unpublished_content_type (enum) [ADS_POST, DRAFT, INLINE_CREATED, PUBLISHED, REVIEWABLE_BRANDED_CONTENT, ...], upload_phase (enum) [cancel, finish, start, transfer], upload_session_id (string), upload_setting_properties (string), video_asset_id (string), video_file_chunk (string), video_id_original (string), video_start_time_ms (integer), waterfall_id (string)"),
		),
	)
	tools = append(tools, page_post_videosTool)

	// page_get_visitor_posts tool
	// Available fields for PagePost: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting, from, full_picture, height, icon, id, instagram_eligibility, is_app_share, is_eligible_for_promotion, is_expired, is_hidden, is_inline_created, is_instagram_eligible, is_popular, is_published, is_spherical, message, message_tags, multi_share_end_card, multi_share_optimized, parent_id, permalink_url, picture, place, privacy, promotable_id, promotion_status, properties, scheduled_publish_time, shares, status_type, story, story_tags, subscribed, target, targeting, timeline_visibility, updated_time, via, video_buying_eligibility, width
	// Params object accepts: include_hidden (bool), limit (unsigned int), show_expired (bool), with (pagevisitor_posts_with_enum_param)
	page_get_visitor_postsTool := mcp.NewTool("page_get_visitor_posts",
		mcp.WithDescription("GET visitor_posts for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"include_hidden": map[string]any{
					"type": "boolean",
					"description": "include_hidden parameter",
				},
				"limit": map[string]any{
					"type": "integer",
					"description": "limit parameter",
				},
				"show_expired": map[string]any{
					"type": "boolean",
					"description": "show_expired parameter",
				},
				"with": map[string]any{
					"type": "string",
					"description": "with parameter",
					"enum": []string{ "LOCATION" },
				},
			}),
			mcp.Description("Parameters object containing: include_hidden (boolean), limit (integer), show_expired (boolean), with (enum) [LOCATION]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PagePost objects. Available fields: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, child_attachments, comments_mirroring_domain, coordinates, created_time, event, expanded_height, expanded_width, feed_targeting (and 40 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_visitor_postsTool)

	// page_delete_welcome_message_flows tool
	// Params object accepts: flow_id (string)
	page_delete_welcome_message_flowsTool := mcp.NewTool("page_delete_welcome_message_flows",
		mcp.WithDescription("DELETE welcome_message_flows for Page"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"flow_id": map[string]any{
					"type": "string",
					"description": "flow_id parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: flow_id (string) [required]"),
		),
	)
	tools = append(tools, page_delete_welcome_message_flowsTool)

	// page_get_welcome_message_flows tool
	// Available fields for CTXPartnerAppWelcomeMessageFlow: compatible_platforms, eligible_platforms, id, is_ig_only_flow, is_used_in_ad, last_update_time, name, welcome_message_flow, welcome_message_sequence
	// Params object accepts: app_id (string), flow_id (string)
	page_get_welcome_message_flowsTool := mcp.NewTool("page_get_welcome_message_flows",
		mcp.WithDescription("GET welcome_message_flows for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"app_id": map[string]any{
					"type": "string",
					"description": "app_id parameter",
				},
				"flow_id": map[string]any{
					"type": "string",
					"description": "flow_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: app_id (string), flow_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CTXPartnerAppWelcomeMessageFlow objects. Available fields: compatible_platforms, eligible_platforms, id, is_ig_only_flow, is_used_in_ad, last_update_time, name, welcome_message_flow, welcome_message_sequence"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_welcome_message_flowsTool)

	// page_post_welcome_message_flows tool
	// Params object accepts: eligible_platforms (list<pagewelcome_message_flows_eligible_platforms_enum_param>), flow_id (string), name (string), welcome_message_flow (list<Object>)
	page_post_welcome_message_flowsTool := mcp.NewTool("page_post_welcome_message_flows",
		mcp.WithDescription("POST welcome_message_flows for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"eligible_platforms": map[string]any{
					"type": "array",
					"description": "eligible_platforms parameter",
					"enum": []string{ "INSTAGRAM", "MESSENGER", "WHATSAPP" },
					"items": map[string]any{"type": "string"},
				},
				"flow_id": map[string]any{
					"type": "string",
					"description": "flow_id parameter",
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
				},
				"welcome_message_flow": map[string]any{
					"type": "array",
					"description": "welcome_message_flow parameter",
					"items": map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: eligible_platforms (array<enum>) [INSTAGRAM, MESSENGER, WHATSAPP], flow_id (string), name (string), welcome_message_flow (array<object>)"),
		),
	)
	tools = append(tools, page_post_welcome_message_flowsTool)

	// page_get_ tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	// Params object accepts: account_linking_token (string)
	page_get_Tool := mcp.NewTool("page_get_",
		mcp.WithDescription("GET  for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"account_linking_token": map[string]any{
					"type": "string",
					"description": "account_linking_token parameter",
				},
			}),
			mcp.Description("Parameters object containing: account_linking_token (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, page_get_Tool)

	// page_post_ tool
	// Params object accepts: about (string), accept_crossposting_handshake (list<map>), allow_spherical_photo (bool), attire (page_attire), begin_crossposting_handshake (list<map>), bio (string), category_list (list<string>), company_overview (string), contact_address (Object), cover (string), culinary_team (string), delivery_and_pickup_option_info (list<string>), description (string), differently_open_offerings (map), directed_by (string), displayed_message_response_time (string), emails (list<string>), focus_x (float), focus_y (float), food_styles (list<page_food_styles>), gen_ai_provenance_type (page_gen_ai_provenance_type), general_info (string), general_manager (string), genre (string), hours (map), ignore_coordinate_warnings (bool), impressum (string), is_always_open (bool), is_permanently_closed (bool), is_published (bool), is_webhooks_subscribed (bool), location (Object), menu (string), mission (string), no_feed_story (bool), no_notification (bool), offset_x (int), offset_y (int), parking (map), payment_options (map), phone (string), pickup_options (list<page_pickup_options>), plot_outline (string), price_range (string), public_transit (string), restaurant_services (map), restaurant_specialties (map), scrape (bool), service_details (string), spherical_metadata (map), start_info (Object), store_location_descriptor (string), temporary_status (page_temporary_status), website (string), zoom_scale_x (float), zoom_scale_y (float)
	page_post_Tool := mcp.NewTool("page_post_",
		mcp.WithDescription("POST  for Page"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"about": map[string]any{
					"type": "string",
					"description": "about parameter",
				},
				"accept_crossposting_handshake": map[string]any{
					"type": "array",
					"description": "accept_crossposting_handshake parameter",
					"items": map[string]any{"type": "object"},
				},
				"allow_spherical_photo": map[string]any{
					"type": "boolean",
					"description": "allow_spherical_photo parameter",
				},
				"attire": map[string]any{
					"type": "string",
					"description": "attire parameter",
					"enum": []string{ "Casual", "Dressy", "Unspecified" },
				},
				"begin_crossposting_handshake": map[string]any{
					"type": "array",
					"description": "begin_crossposting_handshake parameter",
					"items": map[string]any{"type": "object"},
				},
				"bio": map[string]any{
					"type": "string",
					"description": "bio parameter",
				},
				"category_list": map[string]any{
					"type": "array",
					"description": "category_list parameter",
					"items": map[string]any{"type": "string"},
				},
				"company_overview": map[string]any{
					"type": "string",
					"description": "company_overview parameter",
				},
				"contact_address": map[string]any{
					"type": "object",
					"description": "contact_address parameter",
				},
				"cover": map[string]any{
					"type": "string",
					"description": "cover parameter",
				},
				"culinary_team": map[string]any{
					"type": "string",
					"description": "culinary_team parameter",
				},
				"delivery_and_pickup_option_info": map[string]any{
					"type": "array",
					"description": "delivery_and_pickup_option_info parameter",
					"items": map[string]any{"type": "string"},
				},
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
				},
				"differently_open_offerings": map[string]any{
					"type": "object",
					"description": "differently_open_offerings parameter",
				},
				"directed_by": map[string]any{
					"type": "string",
					"description": "directed_by parameter",
				},
				"displayed_message_response_time": map[string]any{
					"type": "string",
					"description": "displayed_message_response_time parameter",
				},
				"emails": map[string]any{
					"type": "array",
					"description": "emails parameter",
					"items": map[string]any{"type": "string"},
				},
				"focus_x": map[string]any{
					"type": "number",
					"description": "focus_x parameter",
				},
				"focus_y": map[string]any{
					"type": "number",
					"description": "focus_y parameter",
				},
				"food_styles": map[string]any{
					"type": "array",
					"description": "food_styles parameter",
					"enum": []string{ "Afghani", "American (New)", "American (Traditional)", "Asian Fusion", "Barbeque", "Brazilian", "Breakfast", "British", "Brunch", "Buffets", "Burgers", "Burmese", "Cajun/Creole", "Caribbean", "Chinese", "Creperies", "Cuban", "Delis", "Diners", "Ethiopian", "Fast Food", "Filipino", "Fondue", "Food Stands", "French", "German", "Greek and Mediterranean", "Hawaiian", "Himalayan/Nepalese", "Hot Dogs", "Indian/Pakistani", "Irish", "Italian", "Japanese", "Korean", "Latin American", "Mexican", "Middle Eastern", "Moroccan", "Pizza", "Russian", "Sandwiches", "Seafood", "Singaporean", "Soul Food", "Southern", "Spanish/Basque", "Steakhouses", "Sushi Bars", "Taiwanese", "Tapas Bars", "Tex-Mex", "Thai", "Turkish", "Vegan", "Vegetarian", "Vietnamese" },
					"items": map[string]any{"type": "string"},
				},
				"gen_ai_provenance_type": map[string]any{
					"type": "string",
					"description": "gen_ai_provenance_type parameter",
					"enum": []string{ "C2PA", "C2PA_METADATA_EDITED", "EXPLICIT", "EXPLICIT_IMAGINE", "EXPLICIT_IMAGINE_ME", "EXPLICIT_RESTYLE", "INVISIBLE_WATERMARK", "IPTC", "IPTC_METADATA_EDITED" },
				},
				"general_info": map[string]any{
					"type": "string",
					"description": "general_info parameter",
				},
				"general_manager": map[string]any{
					"type": "string",
					"description": "general_manager parameter",
				},
				"genre": map[string]any{
					"type": "string",
					"description": "genre parameter",
				},
				"hours": map[string]any{
					"type": "object",
					"description": "hours parameter",
				},
				"ignore_coordinate_warnings": map[string]any{
					"type": "boolean",
					"description": "ignore_coordinate_warnings parameter",
				},
				"impressum": map[string]any{
					"type": "string",
					"description": "impressum parameter",
				},
				"is_always_open": map[string]any{
					"type": "boolean",
					"description": "is_always_open parameter",
				},
				"is_permanently_closed": map[string]any{
					"type": "boolean",
					"description": "is_permanently_closed parameter",
				},
				"is_published": map[string]any{
					"type": "boolean",
					"description": "is_published parameter",
				},
				"is_webhooks_subscribed": map[string]any{
					"type": "boolean",
					"description": "is_webhooks_subscribed parameter",
				},
				"location": map[string]any{
					"type": "object",
					"description": "location parameter",
				},
				"menu": map[string]any{
					"type": "string",
					"description": "menu parameter",
				},
				"mission": map[string]any{
					"type": "string",
					"description": "mission parameter",
				},
				"no_feed_story": map[string]any{
					"type": "boolean",
					"description": "no_feed_story parameter",
				},
				"no_notification": map[string]any{
					"type": "boolean",
					"description": "no_notification parameter",
				},
				"offset_x": map[string]any{
					"type": "integer",
					"description": "offset_x parameter",
				},
				"offset_y": map[string]any{
					"type": "integer",
					"description": "offset_y parameter",
				},
				"parking": map[string]any{
					"type": "object",
					"description": "parking parameter",
				},
				"payment_options": map[string]any{
					"type": "object",
					"description": "payment_options parameter",
				},
				"phone": map[string]any{
					"type": "string",
					"description": "phone parameter",
				},
				"pickup_options": map[string]any{
					"type": "array",
					"description": "pickup_options parameter",
					"enum": []string{ "CURBSIDE", "IN_STORE", "OTHER" },
					"items": map[string]any{"type": "string"},
				},
				"plot_outline": map[string]any{
					"type": "string",
					"description": "plot_outline parameter",
				},
				"price_range": map[string]any{
					"type": "string",
					"description": "price_range parameter",
				},
				"public_transit": map[string]any{
					"type": "string",
					"description": "public_transit parameter",
				},
				"restaurant_services": map[string]any{
					"type": "object",
					"description": "restaurant_services parameter",
				},
				"restaurant_specialties": map[string]any{
					"type": "object",
					"description": "restaurant_specialties parameter",
				},
				"scrape": map[string]any{
					"type": "boolean",
					"description": "scrape parameter",
				},
				"service_details": map[string]any{
					"type": "string",
					"description": "service_details parameter",
				},
				"spherical_metadata": map[string]any{
					"type": "object",
					"description": "spherical_metadata parameter",
				},
				"start_info": map[string]any{
					"type": "object",
					"description": "start_info parameter",
				},
				"store_location_descriptor": map[string]any{
					"type": "string",
					"description": "store_location_descriptor parameter",
				},
				"temporary_status": map[string]any{
					"type": "string",
					"description": "temporary_status parameter",
					"enum": []string{ "DIFFERENTLY_OPEN", "NO_DATA", "OPERATING_AS_USUAL", "TEMPORARILY_CLOSED" },
				},
				"website": map[string]any{
					"type": "string",
					"description": "website parameter",
				},
				"zoom_scale_x": map[string]any{
					"type": "number",
					"description": "zoom_scale_x parameter",
				},
				"zoom_scale_y": map[string]any{
					"type": "number",
					"description": "zoom_scale_y parameter",
				},
			}),
			mcp.Description("Parameters object containing: about (string), accept_crossposting_handshake (array<object>), allow_spherical_photo (boolean), attire (page_attire) [Casual, Dressy, Unspecified], begin_crossposting_handshake (array<object>), bio (string), category_list (array<string>), company_overview (string), contact_address (object), cover (string), culinary_team (string), delivery_and_pickup_option_info (array<string>), description (string), differently_open_offerings (object), directed_by (string), displayed_message_response_time (string), emails (array<string>), focus_x (number), focus_y (number), food_styles (array<page_food_styles>) [Afghani, American (New), American (Traditional), Asian Fusion, Barbeque, ...], gen_ai_provenance_type (page_gen_ai_provenance_type) [C2PA, C2PA_METADATA_EDITED, EXPLICIT, EXPLICIT_IMAGINE, EXPLICIT_IMAGINE_ME, ...], general_info (string), general_manager (string), genre (string), hours (object), ignore_coordinate_warnings (boolean), impressum (string), is_always_open (boolean), is_permanently_closed (boolean), is_published (boolean), is_webhooks_subscribed (boolean), location (object), menu (string), mission (string), no_feed_story (boolean), no_notification (boolean), offset_x (integer), offset_y (integer), parking (object), payment_options (object), phone (string), pickup_options (array<page_pickup_options>) [CURBSIDE, IN_STORE, OTHER], plot_outline (string), price_range (string), public_transit (string), restaurant_services (object), restaurant_specialties (object), scrape (boolean), service_details (string), spherical_metadata (object), start_info (object), store_location_descriptor (string), temporary_status (page_temporary_status) [DIFFERENTLY_OPEN, NO_DATA, OPERATING_AS_USUAL, TEMPORARILY_CLOSED], website (string), zoom_scale_x (number), zoom_scale_y (number)"),
		),
	)
	tools = append(tools, page_post_Tool)


	return tools
}

// Page handlers


// HandlePage_get_ab_tests handles the page_get_ab_tests tool with context-based auth
func HandlePage_get_ab_tests(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_ab_tests(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_ab_tests: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_ab_tests handles the page_post_ab_tests tool with context-based auth
func HandlePage_post_ab_tests(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_ab_tests(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_ab_tests: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_acknowledge_orders handles the page_post_acknowledge_orders tool with context-based auth
func HandlePage_post_acknowledge_orders(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_acknowledge_orders(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_acknowledge_orders: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_ads_posts handles the page_get_ads_posts tool with context-based auth
func HandlePage_get_ads_posts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_ads_posts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_ads_posts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_delete_agencies handles the page_delete_agencies tool with context-based auth
func HandlePage_delete_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_delete_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_delete_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_agencies handles the page_get_agencies tool with context-based auth
func HandlePage_get_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_agencies handles the page_post_agencies tool with context-based auth
func HandlePage_post_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_albums handles the page_get_albums tool with context-based auth
func HandlePage_get_albums(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_albums(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_albums: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_ar_experience handles the page_get_ar_experience tool with context-based auth
func HandlePage_get_ar_experience(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_ar_experience(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_ar_experience: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_delete_assigned_users handles the page_delete_assigned_users tool with context-based auth
func HandlePage_delete_assigned_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_delete_assigned_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_delete_assigned_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_assigned_users handles the page_get_assigned_users tool with context-based auth
func HandlePage_get_assigned_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_assigned_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_assigned_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_assigned_users handles the page_post_assigned_users tool with context-based auth
func HandlePage_post_assigned_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_assigned_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_assigned_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_delete_blocked handles the page_delete_blocked tool with context-based auth
func HandlePage_delete_blocked(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_delete_blocked(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_delete_blocked: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_blocked handles the page_get_blocked tool with context-based auth
func HandlePage_get_blocked(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_blocked(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_blocked: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_blocked handles the page_post_blocked tool with context-based auth
func HandlePage_post_blocked(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_blocked(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_blocked: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_business_data handles the page_post_business_data tool with context-based auth
func HandlePage_post_business_data(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_business_data(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_business_data: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_businessprojects handles the page_get_businessprojects tool with context-based auth
func HandlePage_get_businessprojects(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_businessprojects(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_businessprojects: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_call_to_actions handles the page_get_call_to_actions tool with context-based auth
func HandlePage_get_call_to_actions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_call_to_actions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_call_to_actions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_calls handles the page_post_calls tool with context-based auth
func HandlePage_post_calls(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_calls(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_calls: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_canvas_elements handles the page_get_canvas_elements tool with context-based auth
func HandlePage_get_canvas_elements(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_canvas_elements(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_canvas_elements: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_canvas_elements handles the page_post_canvas_elements tool with context-based auth
func HandlePage_post_canvas_elements(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_canvas_elements(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_canvas_elements: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_canvases handles the page_get_canvases tool with context-based auth
func HandlePage_get_canvases(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_canvases(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_canvases: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_canvases handles the page_post_canvases tool with context-based auth
func HandlePage_post_canvases(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_canvases(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_canvases: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_chat_plugin handles the page_get_chat_plugin tool with context-based auth
func HandlePage_get_chat_plugin(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_chat_plugin(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_chat_plugin: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_commerce_merchant_settings handles the page_get_commerce_merchant_settings tool with context-based auth
func HandlePage_get_commerce_merchant_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_commerce_merchant_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_commerce_merchant_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_commerce_orders handles the page_get_commerce_orders tool with context-based auth
func HandlePage_get_commerce_orders(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_commerce_orders(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_commerce_orders: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_commerce_payouts handles the page_get_commerce_payouts tool with context-based auth
func HandlePage_get_commerce_payouts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_commerce_payouts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_commerce_payouts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_commerce_transactions handles the page_get_commerce_transactions tool with context-based auth
func HandlePage_get_commerce_transactions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_commerce_transactions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_commerce_transactions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_conversations handles the page_get_conversations tool with context-based auth
func HandlePage_get_conversations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_conversations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_conversations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_copyright_manual_claims handles the page_post_copyright_manual_claims tool with context-based auth
func HandlePage_post_copyright_manual_claims(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_copyright_manual_claims(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_copyright_manual_claims: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_crosspost_whitelisted_pages handles the page_get_crosspost_whitelisted_pages tool with context-based auth
func HandlePage_get_crosspost_whitelisted_pages(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_crosspost_whitelisted_pages(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_crosspost_whitelisted_pages: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_ctx_optimization_eligibility handles the page_get_ctx_optimization_eligibility tool with context-based auth
func HandlePage_get_ctx_optimization_eligibility(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_ctx_optimization_eligibility(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_ctx_optimization_eligibility: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_custom_labels handles the page_get_custom_labels tool with context-based auth
func HandlePage_get_custom_labels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_custom_labels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_custom_labels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_custom_labels handles the page_post_custom_labels tool with context-based auth
func HandlePage_post_custom_labels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_custom_labels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_custom_labels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_delete_custom_user_settings handles the page_delete_custom_user_settings tool with context-based auth
func HandlePage_delete_custom_user_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_delete_custom_user_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_delete_custom_user_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_custom_user_settings handles the page_get_custom_user_settings tool with context-based auth
func HandlePage_get_custom_user_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_custom_user_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_custom_user_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_custom_user_settings handles the page_post_custom_user_settings tool with context-based auth
func HandlePage_post_custom_user_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_custom_user_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_custom_user_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_dataset handles the page_get_dataset tool with context-based auth
func HandlePage_get_dataset(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_dataset(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_dataset: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_dataset handles the page_post_dataset tool with context-based auth
func HandlePage_post_dataset(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_dataset(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_dataset: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_events handles the page_get_events tool with context-based auth
func HandlePage_get_events(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_events(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_events: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_extend_thread_control handles the page_post_extend_thread_control tool with context-based auth
func HandlePage_post_extend_thread_control(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_extend_thread_control(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_extend_thread_control: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_fantasy_games handles the page_get_fantasy_games tool with context-based auth
func HandlePage_get_fantasy_games(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_fantasy_games(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_fantasy_games: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_feed handles the page_get_feed tool with context-based auth
func HandlePage_get_feed(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_feed(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_feed: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_feed handles the page_post_feed tool with context-based auth
func HandlePage_post_feed(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_feed(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_feed: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_global_brand_children handles the page_get_global_brand_children tool with context-based auth
func HandlePage_get_global_brand_children(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_global_brand_children(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_global_brand_children: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_image_copyrights handles the page_get_image_copyrights tool with context-based auth
func HandlePage_get_image_copyrights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_image_copyrights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_image_copyrights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_image_copyrights handles the page_post_image_copyrights tool with context-based auth
func HandlePage_post_image_copyrights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_image_copyrights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_image_copyrights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_indexed_videos handles the page_get_indexed_videos tool with context-based auth
func HandlePage_get_indexed_videos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_indexed_videos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_indexed_videos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_insights handles the page_get_insights tool with context-based auth
func HandlePage_get_insights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_insights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_insights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_instagram_accounts handles the page_get_instagram_accounts tool with context-based auth
func HandlePage_get_instagram_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_instagram_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_instagram_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_leadgen_forms handles the page_get_leadgen_forms tool with context-based auth
func HandlePage_get_leadgen_forms(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_leadgen_forms(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_leadgen_forms: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_leadgen_forms handles the page_post_leadgen_forms tool with context-based auth
func HandlePage_post_leadgen_forms(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_leadgen_forms(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_leadgen_forms: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_likes handles the page_get_likes tool with context-based auth
func HandlePage_get_likes(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_likes(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_likes: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_live_videos handles the page_get_live_videos tool with context-based auth
func HandlePage_get_live_videos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_live_videos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_live_videos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_live_videos handles the page_post_live_videos tool with context-based auth
func HandlePage_post_live_videos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_live_videos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_live_videos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_delete_locations handles the page_delete_locations tool with context-based auth
func HandlePage_delete_locations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_delete_locations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_delete_locations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_locations handles the page_get_locations tool with context-based auth
func HandlePage_get_locations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_locations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_locations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_locations handles the page_post_locations tool with context-based auth
func HandlePage_post_locations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_locations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_locations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_media_fingerprints handles the page_get_media_fingerprints tool with context-based auth
func HandlePage_get_media_fingerprints(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_media_fingerprints(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_media_fingerprints: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_media_fingerprints handles the page_post_media_fingerprints tool with context-based auth
func HandlePage_post_media_fingerprints(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_media_fingerprints(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_media_fingerprints: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_message_attachments handles the page_post_message_attachments tool with context-based auth
func HandlePage_post_message_attachments(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_message_attachments(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_message_attachments: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_delete_message_templates handles the page_delete_message_templates tool with context-based auth
func HandlePage_delete_message_templates(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_delete_message_templates(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_delete_message_templates: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_message_templates handles the page_get_message_templates tool with context-based auth
func HandlePage_get_message_templates(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_message_templates(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_message_templates: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_message_templates handles the page_post_message_templates tool with context-based auth
func HandlePage_post_message_templates(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_message_templates(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_message_templates: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_messages handles the page_post_messages tool with context-based auth
func HandlePage_post_messages(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_messages(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_messages: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_messaging_feature_review handles the page_get_messaging_feature_review tool with context-based auth
func HandlePage_get_messaging_feature_review(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_messaging_feature_review(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_messaging_feature_review: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_messenger_call_settings handles the page_get_messenger_call_settings tool with context-based auth
func HandlePage_get_messenger_call_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_messenger_call_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_messenger_call_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_messenger_call_settings handles the page_post_messenger_call_settings tool with context-based auth
func HandlePage_post_messenger_call_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_messenger_call_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_messenger_call_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_messenger_lead_forms handles the page_get_messenger_lead_forms tool with context-based auth
func HandlePage_get_messenger_lead_forms(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_messenger_lead_forms(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_messenger_lead_forms: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_messenger_lead_forms handles the page_post_messenger_lead_forms tool with context-based auth
func HandlePage_post_messenger_lead_forms(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_messenger_lead_forms(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_messenger_lead_forms: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_delete_messenger_profile handles the page_delete_messenger_profile tool with context-based auth
func HandlePage_delete_messenger_profile(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_delete_messenger_profile(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_delete_messenger_profile: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_messenger_profile handles the page_get_messenger_profile tool with context-based auth
func HandlePage_get_messenger_profile(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_messenger_profile(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_messenger_profile: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_messenger_profile handles the page_post_messenger_profile tool with context-based auth
func HandlePage_post_messenger_profile(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_messenger_profile(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_messenger_profile: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_moderate_conversations handles the page_post_moderate_conversations tool with context-based auth
func HandlePage_post_moderate_conversations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_moderate_conversations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_moderate_conversations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_nlp_configs handles the page_post_nlp_configs tool with context-based auth
func HandlePage_post_nlp_configs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_nlp_configs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_nlp_configs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_notification_message_tokens handles the page_get_notification_message_tokens tool with context-based auth
func HandlePage_get_notification_message_tokens(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_notification_message_tokens(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_notification_message_tokens: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_notification_messages_dev_support handles the page_post_notification_messages_dev_support tool with context-based auth
func HandlePage_post_notification_messages_dev_support(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_notification_messages_dev_support(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_notification_messages_dev_support: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_page_backed_instagram_accounts handles the page_get_page_backed_instagram_accounts tool with context-based auth
func HandlePage_get_page_backed_instagram_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_page_backed_instagram_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_page_backed_instagram_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_page_backed_instagram_accounts handles the page_post_page_backed_instagram_accounts tool with context-based auth
func HandlePage_post_page_backed_instagram_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})



	// Call the client method
	result, err := client.Page_post_page_backed_instagram_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_page_backed_instagram_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_page_whatsapp_number_verification handles the page_post_page_whatsapp_number_verification tool with context-based auth
func HandlePage_post_page_whatsapp_number_verification(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_page_whatsapp_number_verification(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_page_whatsapp_number_verification: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_pass_thread_control handles the page_post_pass_thread_control tool with context-based auth
func HandlePage_post_pass_thread_control(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_pass_thread_control(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_pass_thread_control: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_personas handles the page_get_personas tool with context-based auth
func HandlePage_get_personas(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_personas(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_personas: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_personas handles the page_post_personas tool with context-based auth
func HandlePage_post_personas(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_personas(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_personas: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_photo_stories handles the page_post_photo_stories tool with context-based auth
func HandlePage_post_photo_stories(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_photo_stories(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_photo_stories: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_photos handles the page_get_photos tool with context-based auth
func HandlePage_get_photos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_photos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_photos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_photos handles the page_post_photos tool with context-based auth
func HandlePage_post_photos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_photos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_photos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_picture handles the page_get_picture tool with context-based auth
func HandlePage_get_picture(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_picture(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_picture: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_picture handles the page_post_picture tool with context-based auth
func HandlePage_post_picture(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_picture(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_picture: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_posts handles the page_get_posts tool with context-based auth
func HandlePage_get_posts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_posts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_posts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_product_catalogs handles the page_get_product_catalogs tool with context-based auth
func HandlePage_get_product_catalogs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_product_catalogs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_product_catalogs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_published_posts handles the page_get_published_posts tool with context-based auth
func HandlePage_get_published_posts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_published_posts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_published_posts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_release_thread_control handles the page_post_release_thread_control tool with context-based auth
func HandlePage_post_release_thread_control(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_release_thread_control(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_release_thread_control: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_request_thread_control handles the page_post_request_thread_control tool with context-based auth
func HandlePage_post_request_thread_control(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_request_thread_control(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_request_thread_control: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_roles handles the page_get_roles tool with context-based auth
func HandlePage_get_roles(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_roles(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_roles: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_rtb_dynamic_posts handles the page_get_rtb_dynamic_posts tool with context-based auth
func HandlePage_get_rtb_dynamic_posts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_rtb_dynamic_posts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_rtb_dynamic_posts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_scheduled_posts handles the page_get_scheduled_posts tool with context-based auth
func HandlePage_get_scheduled_posts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_scheduled_posts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_scheduled_posts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_secondary_receivers handles the page_get_secondary_receivers tool with context-based auth
func HandlePage_get_secondary_receivers(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_secondary_receivers(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_secondary_receivers: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_settings handles the page_get_settings tool with context-based auth
func HandlePage_get_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_settings handles the page_post_settings tool with context-based auth
func HandlePage_post_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_shop_setup_status handles the page_get_shop_setup_status tool with context-based auth
func HandlePage_get_shop_setup_status(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_shop_setup_status(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_shop_setup_status: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_store_locations handles the page_get_store_locations tool with context-based auth
func HandlePage_get_store_locations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_store_locations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_store_locations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_stories handles the page_get_stories tool with context-based auth
func HandlePage_get_stories(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_stories(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_stories: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_delete_subscribed_apps handles the page_delete_subscribed_apps tool with context-based auth
func HandlePage_delete_subscribed_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})



	// Call the client method
	result, err := client.Page_delete_subscribed_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_delete_subscribed_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_subscribed_apps handles the page_get_subscribed_apps tool with context-based auth
func HandlePage_get_subscribed_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_subscribed_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_subscribed_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_subscribed_apps handles the page_post_subscribed_apps tool with context-based auth
func HandlePage_post_subscribed_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_subscribed_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_subscribed_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_tabs handles the page_get_tabs tool with context-based auth
func HandlePage_get_tabs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_tabs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_tabs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_tagged handles the page_get_tagged tool with context-based auth
func HandlePage_get_tagged(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_tagged(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_tagged: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_take_thread_control handles the page_post_take_thread_control tool with context-based auth
func HandlePage_post_take_thread_control(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_take_thread_control(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_take_thread_control: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_thread_owner handles the page_get_thread_owner tool with context-based auth
func HandlePage_get_thread_owner(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_thread_owner(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_thread_owner: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_threads handles the page_get_threads tool with context-based auth
func HandlePage_get_threads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_threads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_threads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_unlink_accounts handles the page_post_unlink_accounts tool with context-based auth
func HandlePage_post_unlink_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_unlink_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_unlink_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_video_copyright_rules handles the page_get_video_copyright_rules tool with context-based auth
func HandlePage_get_video_copyright_rules(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_video_copyright_rules(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_video_copyright_rules: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_video_copyright_rules handles the page_post_video_copyright_rules tool with context-based auth
func HandlePage_post_video_copyright_rules(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_video_copyright_rules(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_video_copyright_rules: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_video_copyrights handles the page_post_video_copyrights tool with context-based auth
func HandlePage_post_video_copyrights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_video_copyrights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_video_copyrights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_video_lists handles the page_get_video_lists tool with context-based auth
func HandlePage_get_video_lists(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_video_lists(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_video_lists: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_video_reels handles the page_get_video_reels tool with context-based auth
func HandlePage_get_video_reels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_video_reels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_video_reels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_video_reels handles the page_post_video_reels tool with context-based auth
func HandlePage_post_video_reels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_video_reels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_video_reels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_video_stories handles the page_post_video_stories tool with context-based auth
func HandlePage_post_video_stories(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_post_video_stories(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_video_stories: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_videos handles the page_get_videos tool with context-based auth
func HandlePage_get_videos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_videos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_videos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_videos handles the page_post_videos tool with context-based auth
func HandlePage_post_videos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_videos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_videos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_visitor_posts handles the page_get_visitor_posts tool with context-based auth
func HandlePage_get_visitor_posts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_visitor_posts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_visitor_posts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_delete_welcome_message_flows handles the page_delete_welcome_message_flows tool with context-based auth
func HandlePage_delete_welcome_message_flows(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Page_delete_welcome_message_flows(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_delete_welcome_message_flows: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_welcome_message_flows handles the page_get_welcome_message_flows tool with context-based auth
func HandlePage_get_welcome_message_flows(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_welcome_message_flows(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_welcome_message_flows: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_welcome_message_flows handles the page_post_welcome_message_flows tool with context-based auth
func HandlePage_post_welcome_message_flows(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_welcome_message_flows(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_welcome_message_flows: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_get_ handles the page_get_ tool with context-based auth
func HandlePage_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Page_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandlePage_post_ handles the page_post_ tool with context-based auth
func HandlePage_post_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewPageClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Page_post_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute page_post_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

