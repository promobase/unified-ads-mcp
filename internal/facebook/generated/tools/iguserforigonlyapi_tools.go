// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetIGUserForIGOnlyAPITools returns MCP tools for IGUserForIGOnlyAPI
func GetIGUserForIGOnlyAPITools() []mcp.Tool {
	var tools []mcp.Tool


	// iguserforigonlyapi_get_business_messaging_feature_status tool
	// Params object accepts: feature (string)
	iguserforigonlyapi_get_business_messaging_feature_statusTool := mcp.NewTool("iguserforigonlyapi_get_business_messaging_feature_status",
		mcp.WithDescription("GET business_messaging_feature_status for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"feature": map[string]any{
					"type": "string",
					"description": "feature parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: feature (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_business_messaging_feature_statusTool)

	// iguserforigonlyapi_get_content_publishing_limit tool
	// Available fields for ContentPublishingLimitResponse: config, quota_usage
	// Params object accepts: since (datetime)
	iguserforigonlyapi_get_content_publishing_limitTool := mcp.NewTool("iguserforigonlyapi_get_content_publishing_limit",
		mcp.WithDescription("GET content_publishing_limit for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"since": map[string]any{
					"type": "string",
					"description": "since parameter",
				},
			}),
			mcp.Description("Parameters object containing: since (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ContentPublishingLimitResponse objects. Available fields: config, quota_usage"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_content_publishing_limitTool)

	// iguserforigonlyapi_get_conversations tool
	// Available fields for UnifiedThread: can_reply, folder, former_participants, id, is_subscribed, link, linked_group, message_count, name, participants, scoped_thread_key, senders, snippet, subject, unread_count, updated_time, wallpaper
	// Params object accepts: folder (string), platform (userconversations_platform_enum_param), tags (list<string>), user_id (string)
	iguserforigonlyapi_get_conversationsTool := mcp.NewTool("iguserforigonlyapi_get_conversations",
		mcp.WithDescription("GET conversations for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"folder": map[string]any{
					"type": "string",
					"description": "folder parameter",
				},
				"platform": map[string]any{
					"type": "string",
					"description": "platform parameter",
					"enum": []string{ "INSTAGRAM", "MESSENGER" },
				},
				"tags": map[string]any{
					"type": "array",
					"description": "tags parameter",
					"items": map[string]any{"type": "string"},
				},
				"user_id": map[string]any{
					"type": "string",
					"description": "user_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: folder (string), platform (enum) [INSTAGRAM, MESSENGER], tags (array<string>), user_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for UnifiedThread objects. Available fields: can_reply, folder, former_participants, id, is_subscribed, link, linked_group, message_count, name, participants, scoped_thread_key, senders, snippet, subject, unread_count (and 2 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_conversationsTool)

	// iguserforigonlyapi_get_insights tool
	// Available fields for InsightsResult: description, description_from_api_doc, id, name, period, title, values
	// Params object accepts: breakdown (list<userinsights_breakdown_enum_param>), metric (list<userinsights_metric_enum_param>), metric_type (userinsights_metric_type_enum_param), period (list<userinsights_period_enum_param>), since (datetime), timeframe (userinsights_timeframe_enum_param), until (datetime)
	iguserforigonlyapi_get_insightsTool := mcp.NewTool("iguserforigonlyapi_get_insights",
		mcp.WithDescription("GET insights for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"breakdown": map[string]any{
					"type": "array",
					"description": "breakdown parameter",
					"enum": []string{ "age", "city", "contact_button_type", "country", "follow_type", "gender", "media_product_type" },
					"items": map[string]any{"type": "string"},
				},
				"metric": map[string]any{
					"type": "array",
					"description": "metric parameter",
					"required": true,
					"enum": []string{ "accounts_engaged", "comments", "content_views", "engaged_audience_demographics", "follower_count", "follower_demographics", "follows_and_unfollows", "impressions", "likes", "online_followers", "profile_links_taps", "profile_views", "quotes", "reach", "reached_audience_demographics", "replies", "reposts", "saves", "shares", "threads_follower_demographics", "threads_followers", "threads_likes", "threads_replies", "threads_views", "total_interactions", "views", "website_clicks" },
					"items": map[string]any{"type": "string"},
				},
				"metric_type": map[string]any{
					"type": "string",
					"description": "metric_type parameter",
					"enum": []string{ "default", "time_series", "total_value" },
				},
				"period": map[string]any{
					"type": "array",
					"description": "period parameter",
					"required": true,
					"enum": []string{ "day", "days_28", "lifetime", "month", "total_over_range", "week" },
					"items": map[string]any{"type": "string"},
				},
				"since": map[string]any{
					"type": "string",
					"description": "since parameter",
				},
				"timeframe": map[string]any{
					"type": "string",
					"description": "timeframe parameter",
					"enum": []string{ "last_14_days", "last_30_days", "last_90_days", "prev_month", "this_month", "this_week" },
				},
				"until": map[string]any{
					"type": "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: breakdown (array<enum>) [age, city, contact_button_type, country, follow_type, ...], metric (array<enum>) [accounts_engaged, comments, content_views, engaged_audience_demographics, follower_count, ...] [required], metric_type (enum) [default, time_series, total_value], period (array<enum>) [day, days_28, lifetime, month, total_over_range, ...] [required], since (datetime), timeframe (enum) [last_14_days, last_30_days, last_90_days, prev_month, this_month, ...], until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for InsightsResult objects. Available fields: description, description_from_api_doc, id, name, period, title, values"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_insightsTool)

	// iguserforigonlyapi_get_live_media tool
	iguserforigonlyapi_get_live_mediaTool := mcp.NewTool("iguserforigonlyapi_get_live_media",
		mcp.WithDescription("GET live_media for IGUserForIGOnlyAPI"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_live_mediaTool)

	// iguserforigonlyapi_get_media tool
	// Params object accepts: since (datetime), until (datetime)
	iguserforigonlyapi_get_mediaTool := mcp.NewTool("iguserforigonlyapi_get_media",
		mcp.WithDescription("GET media for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"since": map[string]any{
					"type": "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type": "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: since (datetime), until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_mediaTool)

	// iguserforigonlyapi_post_media tool
	// Params object accepts: alt_text (string), audio_name (string), caption (string), children (list<string>), collaborators (list<string>), cover_url (string), image_url (string), is_carousel_item (bool), location_id (string), media_type (string), product_tags (list<map>), share_to_feed (bool), thumb_offset (string), upload_type (string), user_tags (list<map>), video_url (string)
	iguserforigonlyapi_post_mediaTool := mcp.NewTool("iguserforigonlyapi_post_media",
		mcp.WithDescription("POST media for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"alt_text": map[string]any{
					"type": "string",
					"description": "alt_text parameter",
				},
				"audio_name": map[string]any{
					"type": "string",
					"description": "audio_name parameter",
				},
				"caption": map[string]any{
					"type": "string",
					"description": "caption parameter",
				},
				"children": map[string]any{
					"type": "array",
					"description": "children parameter",
					"items": map[string]any{"type": "string"},
				},
				"collaborators": map[string]any{
					"type": "array",
					"description": "collaborators parameter",
					"items": map[string]any{"type": "string"},
				},
				"cover_url": map[string]any{
					"type": "string",
					"description": "cover_url parameter",
				},
				"image_url": map[string]any{
					"type": "string",
					"description": "image_url parameter",
				},
				"is_carousel_item": map[string]any{
					"type": "boolean",
					"description": "is_carousel_item parameter",
				},
				"location_id": map[string]any{
					"type": "string",
					"description": "location_id parameter",
				},
				"media_type": map[string]any{
					"type": "string",
					"description": "media_type parameter",
				},
				"product_tags": map[string]any{
					"type": "array",
					"description": "product_tags parameter",
					"items": map[string]any{"type": "object"},
				},
				"share_to_feed": map[string]any{
					"type": "boolean",
					"description": "share_to_feed parameter",
				},
				"thumb_offset": map[string]any{
					"type": "string",
					"description": "thumb_offset parameter",
				},
				"upload_type": map[string]any{
					"type": "string",
					"description": "upload_type parameter",
				},
				"user_tags": map[string]any{
					"type": "array",
					"description": "user_tags parameter",
					"items": map[string]any{"type": "object"},
				},
				"video_url": map[string]any{
					"type": "string",
					"description": "video_url parameter",
				},
			}),
			mcp.Description("Parameters object containing: alt_text (string), audio_name (string), caption (string), children (array<string>), collaborators (array<string>), cover_url (string), image_url (string), is_carousel_item (boolean), location_id (string), media_type (string), product_tags (array<object>), share_to_feed (boolean), thumb_offset (string), upload_type (string), user_tags (array<object>), video_url (string)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_post_mediaTool)

	// iguserforigonlyapi_post_mediapublish tool
	// Params object accepts: creation_id (unsigned int)
	iguserforigonlyapi_post_mediapublishTool := mcp.NewTool("iguserforigonlyapi_post_mediapublish",
		mcp.WithDescription("POST mediapublish for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"creation_id": map[string]any{
					"type": "integer",
					"description": "creation_id parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: creation_id (integer) [required]"),
		),
	)
	tools = append(tools, iguserforigonlyapi_post_mediapublishTool)

	// iguserforigonlyapi_post_mentions tool
	// Params object accepts: comment_id (string), media_id (string), message (string)
	iguserforigonlyapi_post_mentionsTool := mcp.NewTool("iguserforigonlyapi_post_mentions",
		mcp.WithDescription("POST mentions for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"comment_id": map[string]any{
					"type": "string",
					"description": "comment_id parameter",
				},
				"media_id": map[string]any{
					"type": "string",
					"description": "media_id parameter",
					"required": true,
				},
				"message": map[string]any{
					"type": "string",
					"description": "message parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: comment_id (string), media_id (string) [required], message (string) [required]"),
		),
	)
	tools = append(tools, iguserforigonlyapi_post_mentionsTool)

	// iguserforigonlyapi_post_messageattachments tool
	// Params object accepts: message (Object)
	iguserforigonlyapi_post_messageattachmentsTool := mcp.NewTool("iguserforigonlyapi_post_messageattachments",
		mcp.WithDescription("POST messageattachments for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"message": map[string]any{
					"type": "object",
					"description": "message parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: message (object) [required]"),
		),
	)
	tools = append(tools, iguserforigonlyapi_post_messageattachmentsTool)

	// iguserforigonlyapi_post_messages tool
	// Params object accepts: message (Object), messaging_type (iggraphusermessages_messaging_type_enum_param), payload (string), recipient (Object), sender_action (iggraphusermessages_sender_action_enum_param), tag (Object), thread_control (Object)
	iguserforigonlyapi_post_messagesTool := mcp.NewTool("iguserforigonlyapi_post_messages",
		mcp.WithDescription("POST messages for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"message": map[string]any{
					"type": "object",
					"description": "message parameter",
				},
				"messaging_type": map[string]any{
					"type": "string",
					"description": "messaging_type parameter",
					"enum": []string{ "MESSAGE_TAG", "RESPONSE", "UPDATE", "UTILITY" },
				},
				"payload": map[string]any{
					"type": "string",
					"description": "payload parameter",
				},
				"recipient": map[string]any{
					"type": "object",
					"description": "recipient parameter",
				},
				"sender_action": map[string]any{
					"type": "string",
					"description": "sender_action parameter",
					"enum": []string{ "MARK_SEEN", "REACT", "TYPING_OFF", "TYPING_ON", "UNREACT" },
				},
				"tag": map[string]any{
					"type": "object",
					"description": "tag parameter",
				},
				"thread_control": map[string]any{
					"type": "object",
					"description": "thread_control parameter",
				},
			}),
			mcp.Description("Parameters object containing: message (object), messaging_type (enum) [MESSAGE_TAG, RESPONSE, UPDATE, UTILITY], payload (string), recipient (object), sender_action (enum) [MARK_SEEN, REACT, TYPING_OFF, TYPING_ON, UNREACT], tag (object), thread_control (object)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_post_messagesTool)

	// iguserforigonlyapi_delete_messenger_profile tool
	// Params object accepts: fields (list<iggraphusermessenger_profile_fields_enum_param>)
	iguserforigonlyapi_delete_messenger_profileTool := mcp.NewTool("iguserforigonlyapi_delete_messenger_profile",
		mcp.WithDescription("DELETE messenger_profile for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"fields": map[string]any{
					"type": "array",
					"description": "fields parameter",
					"required": true,
					"enum": []string{ "ACCOUNT_LINKING_URL", "COMMANDS", "DESCRIPTION", "GET_STARTED", "GREETING", "HOME_URL", "ICE_BREAKERS", "PERSISTENT_MENU", "PLATFORM", "SUBJECT_TO_NEW_EU_PRIVACY_RULES", "TITLE", "WHITELISTED_DOMAINS" },
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: fields (array<enum>) [ACCOUNT_LINKING_URL, COMMANDS, DESCRIPTION, GET_STARTED, GREETING, ...] [required]"),
		),
	)
	tools = append(tools, iguserforigonlyapi_delete_messenger_profileTool)

	// iguserforigonlyapi_get_messenger_profile tool
	iguserforigonlyapi_get_messenger_profileTool := mcp.NewTool("iguserforigonlyapi_get_messenger_profile",
		mcp.WithDescription("GET messenger_profile for IGUserForIGOnlyAPI"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_messenger_profileTool)

	// iguserforigonlyapi_post_messenger_profile tool
	// Params object accepts: ice_breakers (list<map>), persistent_menu (list<Object>)
	iguserforigonlyapi_post_messenger_profileTool := mcp.NewTool("iguserforigonlyapi_post_messenger_profile",
		mcp.WithDescription("POST messenger_profile for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"ice_breakers": map[string]any{
					"type": "array",
					"description": "ice_breakers parameter",
					"items": map[string]any{"type": "object"},
				},
				"persistent_menu": map[string]any{
					"type": "array",
					"description": "persistent_menu parameter",
					"items": map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: ice_breakers (array<object>), persistent_menu (array<object>)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_post_messenger_profileTool)

	// iguserforigonlyapi_get_stories tool
	iguserforigonlyapi_get_storiesTool := mcp.NewTool("iguserforigonlyapi_get_stories",
		mcp.WithDescription("GET stories for IGUserForIGOnlyAPI"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_storiesTool)

	// iguserforigonlyapi_delete_subscribed_apps tool
	iguserforigonlyapi_delete_subscribed_appsTool := mcp.NewTool("iguserforigonlyapi_delete_subscribed_apps",
		mcp.WithDescription("DELETE subscribed_apps for IGUserForIGOnlyAPI"),
	)
	tools = append(tools, iguserforigonlyapi_delete_subscribed_appsTool)

	// iguserforigonlyapi_get_subscribed_apps tool
	iguserforigonlyapi_get_subscribed_appsTool := mcp.NewTool("iguserforigonlyapi_get_subscribed_apps",
		mcp.WithDescription("GET subscribed_apps for IGUserForIGOnlyAPI"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_subscribed_appsTool)

	// iguserforigonlyapi_post_subscribed_apps tool
	// Params object accepts: subscribed_fields (list<iggraphusersubscribed_apps_subscribed_fields_enum_param>)
	iguserforigonlyapi_post_subscribed_appsTool := mcp.NewTool("iguserforigonlyapi_post_subscribed_apps",
		mcp.WithDescription("POST subscribed_apps for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"subscribed_fields": map[string]any{
					"type": "array",
					"description": "subscribed_fields parameter",
					"required": true,
					"enum": []string{ "comment_poll_response", "comments", "creator_marketplace_invited_creator_onboarding", "creator_marketplace_projects", "delta", "follow", "live_comments", "mentions", "message_reactions", "messages", "messaging_handover", "messaging_optins", "messaging_postbacks", "messaging_referral", "messaging_seen", "onboarding_welcome_message_series", "standby", "story_insights", "story_poll_response", "story_reactions", "story_share" },
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: subscribed_fields (array<enum>) [comment_poll_response, comments, creator_marketplace_invited_creator_onboarding, creator_marketplace_projects, delta, ...] [required]"),
		),
	)
	tools = append(tools, iguserforigonlyapi_post_subscribed_appsTool)

	// iguserforigonlyapi_get_tags tool
	iguserforigonlyapi_get_tagsTool := mcp.NewTool("iguserforigonlyapi_get_tags",
		mcp.WithDescription("GET tags for IGUserForIGOnlyAPI"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_tagsTool)

	// iguserforigonlyapi_delete_welcome_message_flows tool
	// Params object accepts: flow_id (string)
	iguserforigonlyapi_delete_welcome_message_flowsTool := mcp.NewTool("iguserforigonlyapi_delete_welcome_message_flows",
		mcp.WithDescription("DELETE welcome_message_flows for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"flow_id": map[string]any{
					"type": "string",
					"description": "flow_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: flow_id (string)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_delete_welcome_message_flowsTool)

	// iguserforigonlyapi_get_welcome_message_flows tool
	// Available fields for CTXPartnerAppWelcomeMessageFlow: compatible_platforms, eligible_platforms, id, is_ig_only_flow, is_used_in_ad, last_update_time, name, welcome_message_flow, welcome_message_sequence
	// Params object accepts: app_id (string), flow_id (string)
	iguserforigonlyapi_get_welcome_message_flowsTool := mcp.NewTool("iguserforigonlyapi_get_welcome_message_flows",
		mcp.WithDescription("GET welcome_message_flows for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"app_id": map[string]any{
					"type": "string",
					"description": "app_id parameter",
				},
				"flow_id": map[string]any{
					"type": "string",
					"description": "flow_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: app_id (string), flow_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CTXPartnerAppWelcomeMessageFlow objects. Available fields: compatible_platforms, eligible_platforms, id, is_ig_only_flow, is_used_in_ad, last_update_time, name, welcome_message_flow, welcome_message_sequence"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_welcome_message_flowsTool)

	// iguserforigonlyapi_post_welcome_message_flows tool
	// Params object accepts: eligible_platforms (list<iggraphuserwelcome_message_flows_eligible_platforms_enum_param>), flow_id (string), name (string), welcome_message_flow (list<Object>)
	iguserforigonlyapi_post_welcome_message_flowsTool := mcp.NewTool("iguserforigonlyapi_post_welcome_message_flows",
		mcp.WithDescription("POST welcome_message_flows for IGUserForIGOnlyAPI"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"eligible_platforms": map[string]any{
					"type": "array",
					"description": "eligible_platforms parameter",
					"enum": []string{ "INSTAGRAM", "MESSENGER", "WHATSAPP" },
					"items": map[string]any{"type": "string"},
				},
				"flow_id": map[string]any{
					"type": "string",
					"description": "flow_id parameter",
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
				},
				"welcome_message_flow": map[string]any{
					"type": "array",
					"description": "welcome_message_flow parameter",
					"items": map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: eligible_platforms (array<enum>) [INSTAGRAM, MESSENGER, WHATSAPP], flow_id (string), name (string), welcome_message_flow (array<object>)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_post_welcome_message_flowsTool)

	// iguserforigonlyapi_get_ tool
	// Available fields for User: about, age_range, avatar_2d_profile_picture, birthday, client_business_id, community, cover, currency, education, email, favorite_athletes, favorite_teams, first_name, gender, hometown, id, id_for_avatars, inspirational_people, install_type, installed, is_guest_user, is_work_account, languages, last_name, link, local_news_megaphone_dismiss_status, local_news_subscription_status, locale, location, meeting_for, middle_name, name, name_format, payment_pricepoints, political, profile_pic, quotes, relationship_status, religion, shared_login_upgrade_required_by, short_name, significant_other, sports, supports_donate_button_in_live_video, third_party_id, timezone, token_for_business, updated_time, verified, video_upload_limits, website
	iguserforigonlyapi_get_Tool := mcp.NewTool("iguserforigonlyapi_get_",
		mcp.WithDescription("GET  for IGUserForIGOnlyAPI"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for User objects. Available fields: about, age_range, avatar_2d_profile_picture, birthday, client_business_id, community, cover, currency, education, email, favorite_athletes, favorite_teams, first_name, gender, hometown (and 36 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguserforigonlyapi_get_Tool)


	return tools
}

// IGUserForIGOnlyAPI handlers


// HandleIguserforigonlyapi_get_business_messaging_feature_status handles the iguserforigonlyapi_get_business_messaging_feature_status tool with context-based auth
func HandleIguserforigonlyapi_get_business_messaging_feature_status(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_business_messaging_feature_status(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_business_messaging_feature_status: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_get_content_publishing_limit handles the iguserforigonlyapi_get_content_publishing_limit tool with context-based auth
func HandleIguserforigonlyapi_get_content_publishing_limit(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_content_publishing_limit(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_content_publishing_limit: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_get_conversations handles the iguserforigonlyapi_get_conversations tool with context-based auth
func HandleIguserforigonlyapi_get_conversations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_conversations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_conversations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_get_insights handles the iguserforigonlyapi_get_insights tool with context-based auth
func HandleIguserforigonlyapi_get_insights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_insights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_insights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_get_live_media handles the iguserforigonlyapi_get_live_media tool with context-based auth
func HandleIguserforigonlyapi_get_live_media(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_live_media(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_live_media: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_get_media handles the iguserforigonlyapi_get_media tool with context-based auth
func HandleIguserforigonlyapi_get_media(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_media(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_media: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_post_media handles the iguserforigonlyapi_post_media tool with context-based auth
func HandleIguserforigonlyapi_post_media(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_post_media(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_post_media: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_post_mediapublish handles the iguserforigonlyapi_post_mediapublish tool with context-based auth
func HandleIguserforigonlyapi_post_mediapublish(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_post_mediapublish(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_post_mediapublish: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_post_mentions handles the iguserforigonlyapi_post_mentions tool with context-based auth
func HandleIguserforigonlyapi_post_mentions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_post_mentions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_post_mentions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_post_messageattachments handles the iguserforigonlyapi_post_messageattachments tool with context-based auth
func HandleIguserforigonlyapi_post_messageattachments(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_post_messageattachments(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_post_messageattachments: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_post_messages handles the iguserforigonlyapi_post_messages tool with context-based auth
func HandleIguserforigonlyapi_post_messages(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_post_messages(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_post_messages: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_delete_messenger_profile handles the iguserforigonlyapi_delete_messenger_profile tool with context-based auth
func HandleIguserforigonlyapi_delete_messenger_profile(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_delete_messenger_profile(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_delete_messenger_profile: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_get_messenger_profile handles the iguserforigonlyapi_get_messenger_profile tool with context-based auth
func HandleIguserforigonlyapi_get_messenger_profile(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_messenger_profile(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_messenger_profile: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_post_messenger_profile handles the iguserforigonlyapi_post_messenger_profile tool with context-based auth
func HandleIguserforigonlyapi_post_messenger_profile(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_post_messenger_profile(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_post_messenger_profile: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_get_stories handles the iguserforigonlyapi_get_stories tool with context-based auth
func HandleIguserforigonlyapi_get_stories(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_stories(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_stories: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_delete_subscribed_apps handles the iguserforigonlyapi_delete_subscribed_apps tool with context-based auth
func HandleIguserforigonlyapi_delete_subscribed_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})



	// Call the client method
	result, err := client.Iguserforigonlyapi_delete_subscribed_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_delete_subscribed_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_get_subscribed_apps handles the iguserforigonlyapi_get_subscribed_apps tool with context-based auth
func HandleIguserforigonlyapi_get_subscribed_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_subscribed_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_subscribed_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_post_subscribed_apps handles the iguserforigonlyapi_post_subscribed_apps tool with context-based auth
func HandleIguserforigonlyapi_post_subscribed_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_post_subscribed_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_post_subscribed_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_get_tags handles the iguserforigonlyapi_get_tags tool with context-based auth
func HandleIguserforigonlyapi_get_tags(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_tags(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_tags: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_delete_welcome_message_flows handles the iguserforigonlyapi_delete_welcome_message_flows tool with context-based auth
func HandleIguserforigonlyapi_delete_welcome_message_flows(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_delete_welcome_message_flows(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_delete_welcome_message_flows: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_get_welcome_message_flows handles the iguserforigonlyapi_get_welcome_message_flows tool with context-based auth
func HandleIguserforigonlyapi_get_welcome_message_flows(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_welcome_message_flows(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_welcome_message_flows: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_post_welcome_message_flows handles the iguserforigonlyapi_post_welcome_message_flows tool with context-based auth
func HandleIguserforigonlyapi_post_welcome_message_flows(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_post_welcome_message_flows(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_post_welcome_message_flows: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguserforigonlyapi_get_ handles the iguserforigonlyapi_get_ tool with context-based auth
func HandleIguserforigonlyapi_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserForIGOnlyAPIClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguserforigonlyapi_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguserforigonlyapi_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

