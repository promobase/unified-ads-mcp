// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetCommerceMerchantSettingsTools returns MCP tools for CommerceMerchantSettings
func GetCommerceMerchantSettingsTools() []mcp.Tool {
	var tools []mcp.Tool

	// commercemerchantsettings_post_acknowledge_orders tool
	// Params object accepts: idempotency_key (string), orders (list<map>)
	commercemerchantsettings_post_acknowledge_ordersTool := mcp.NewTool("commercemerchantsettings_post_acknowledge_orders",
		mcp.WithDescription("POST acknowledge_orders for CommerceMerchantSettings"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"idempotency_key": map[string]any{
					"type":        "string",
					"description": "idempotency_key parameter",
					"required":    true,
				},
				"orders": map[string]any{
					"type":        "array",
					"description": "orders parameter",
					"required":    true,
					"items":       map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: idempotency_key (string) [required], orders (array<object>) [required]"),
		),
	)
	tools = append(tools, commercemerchantsettings_post_acknowledge_ordersTool)

	// commercemerchantsettings_get_commerce_orders tool
	// Available fields for CommerceOrder: buyer_details, channel, contains_bopis_items, created, estimated_payment_details, id, is_group_buy, is_test_order, last_updated, merchant_order_id, order_status, pre_order_details, selected_shipping_option, ship_by_date, shipping_address
	// Params object accepts: filters (list<commercemerchantsettingscommerce_orders_filters_enum_param>), state (list<commercemerchantsettingscommerce_orders_state_enum_param>), updated_after (datetime), updated_before (datetime)
	commercemerchantsettings_get_commerce_ordersTool := mcp.NewTool("commercemerchantsettings_get_commerce_orders",
		mcp.WithDescription("GET commerce_orders for CommerceMerchantSettings"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"filters": map[string]any{
					"type":        "array",
					"description": "filters parameter",
					"enum":        []string{"HAS_CANCELLATIONS", "HAS_FULFILLMENTS", "HAS_REFUNDS", "NO_CANCELLATIONS", "NO_REFUNDS", "NO_SHIPMENTS"},
					"items":       map[string]any{"type": "string"},
				},
				"state": map[string]any{
					"type":        "array",
					"description": "state parameter",
					"enum":        []string{"COMPLETED", "CREATED", "FB_PROCESSING", "IN_PROGRESS"},
					"items":       map[string]any{"type": "string"},
				},
				"updated_after": map[string]any{
					"type":        "string",
					"description": "updated_after parameter",
				},
				"updated_before": map[string]any{
					"type":        "string",
					"description": "updated_before parameter",
				},
			}),
			mcp.Description("Parameters object containing: filters (array<enum>) [HAS_CANCELLATIONS, HAS_FULFILLMENTS, HAS_REFUNDS, NO_CANCELLATIONS, NO_REFUNDS, ...], state (array<enum>) [COMPLETED, CREATED, FB_PROCESSING, IN_PROGRESS], updated_after (datetime), updated_before (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CommerceOrder objects. Available fields: buyer_details, channel, contains_bopis_items, created, estimated_payment_details, id, is_group_buy, is_test_order, last_updated, merchant_order_id, order_status, pre_order_details, selected_shipping_option, ship_by_date, shipping_address"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commercemerchantsettings_get_commerce_ordersTool)

	// commercemerchantsettings_get_commerce_payouts tool
	// Available fields for CommercePayout: amount, payout_date, payout_reference_id, status, transfer_id
	// Params object accepts: end_time (datetime), start_time (datetime)
	commercemerchantsettings_get_commerce_payoutsTool := mcp.NewTool("commercemerchantsettings_get_commerce_payouts",
		mcp.WithDescription("GET commerce_payouts for CommerceMerchantSettings"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"end_time": map[string]any{
					"type":        "string",
					"description": "end_time parameter",
				},
				"start_time": map[string]any{
					"type":        "string",
					"description": "start_time parameter",
				},
			}),
			mcp.Description("Parameters object containing: end_time (datetime), start_time (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CommercePayout objects. Available fields: amount, payout_date, payout_reference_id, status, transfer_id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commercemerchantsettings_get_commerce_payoutsTool)

	// commercemerchantsettings_get_commerce_transactions tool
	// Available fields for CommerceOrderTransactionDetail: merchant_order_id, net_payment_amount, order_created, order_details, order_id, payout_reference_id, postal_code, processing_fee, state, tax_rate, transaction_date, transaction_type, transfer_id
	// Params object accepts: end_time (datetime), payout_reference_id (string), start_time (datetime)
	commercemerchantsettings_get_commerce_transactionsTool := mcp.NewTool("commercemerchantsettings_get_commerce_transactions",
		mcp.WithDescription("GET commerce_transactions for CommerceMerchantSettings"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"end_time": map[string]any{
					"type":        "string",
					"description": "end_time parameter",
				},
				"payout_reference_id": map[string]any{
					"type":        "string",
					"description": "payout_reference_id parameter",
				},
				"start_time": map[string]any{
					"type":        "string",
					"description": "start_time parameter",
				},
			}),
			mcp.Description("Parameters object containing: end_time (datetime), payout_reference_id (string), start_time (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CommerceOrderTransactionDetail objects. Available fields: merchant_order_id, net_payment_amount, order_created, order_details, order_id, payout_reference_id, postal_code, processing_fee, state, tax_rate, transaction_date, transaction_type, transfer_id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commercemerchantsettings_get_commerce_transactionsTool)

	// commercemerchantsettings_get_order_management_apps tool
	// Available fields for Application: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline, auth_dialog_perms_explanation, auth_referral_default_activity_privacy, auth_referral_enabled, auth_referral_extended_perms, auth_referral_friend_perms, auth_referral_response_type, auth_referral_user_perms, auto_event_mapping_android, auto_event_mapping_ios, auto_event_setup_enabled, auto_log_app_events_default, auto_log_app_events_enabled, business, canvas_fluid_height, canvas_fluid_width, canvas_url, category, client_config, company, configured_ios_sso, contact_email, created_time, creator_uid, daily_active_users, daily_active_users_rank, deauth_callback_url, default_share_mode, description, enigma_config, financial_id, gdpv4_chrome_custom_tabs_enabled, gdpv4_enabled, gdpv4_nux_content, gdpv4_nux_enabled, has_messenger_product, hosting_url, icon_url, id, ios_bundle_id, ios_sdk_dialog_flows, ios_sdk_error_categories, ios_sfvc_attr, ios_supports_native_proxy_auth_flow, ios_supports_system_auth, ipad_app_store_id, iphone_app_store_id, latest_sdk_version, link, logging_token, logo_url, migrations, mobile_profile_section_url, mobile_web_url, monthly_active_users, monthly_active_users_rank, name, namespace, object_store_urls, owner_business, page_tab_default_name, page_tab_url, photo_url, privacy_policy_url, profile_section_url, property_id, protected_mode_rules, real_time_mode_devices, restrictions, restrictive_data_filter_params, restrictive_data_filter_rules, sdk_update_message, seamless_login, secure_canvas_url, secure_page_tab_url, server_ip_whitelist, smart_login_bookmark_icon_url, smart_login_menu_icon_url, social_discovery, subcategory, suggested_events_setting, supported_platforms, supports_apprequests_fast_app_switch, supports_attribution, supports_implicit_sdk_logging, suppress_native_ios_gdp, terms_of_service_url, url_scheme_suffix, user_support_email, user_support_url, website_url, weekly_active_users
	commercemerchantsettings_get_order_management_appsTool := mcp.NewTool("commercemerchantsettings_get_order_management_apps",
		mcp.WithDescription("GET order_management_apps for CommerceMerchantSettings"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Application objects. Available fields: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline (and 91 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commercemerchantsettings_get_order_management_appsTool)

	// commercemerchantsettings_post_order_management_apps tool
	commercemerchantsettings_post_order_management_appsTool := mcp.NewTool("commercemerchantsettings_post_order_management_apps",
		mcp.WithDescription("POST order_management_apps for CommerceMerchantSettings"),
	)
	tools = append(tools, commercemerchantsettings_post_order_management_appsTool)

	// commercemerchantsettings_get_product_catalogs tool
	// Available fields for ProductCatalog: ad_account_to_collaborative_ads_share_settings, agency_collaborative_ads_share_settings, business, catalog_store, commerce_merchant_settings, creator_user, da_display_settings, default_image_url, fallback_image_url, feed_count, id, is_catalog_segment, is_local_catalog, name, owner_business, product_count, store_catalog_settings, user_access_expire_time, vertical
	commercemerchantsettings_get_product_catalogsTool := mcp.NewTool("commercemerchantsettings_get_product_catalogs",
		mcp.WithDescription("GET product_catalogs for CommerceMerchantSettings"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductCatalog objects. Available fields: ad_account_to_collaborative_ads_share_settings, agency_collaborative_ads_share_settings, business, catalog_store, commerce_merchant_settings, creator_user, da_display_settings, default_image_url, fallback_image_url, feed_count, id, is_catalog_segment, is_local_catalog, name, owner_business (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commercemerchantsettings_get_product_catalogsTool)

	// commercemerchantsettings_get_returns tool
	// Params object accepts: end_time_created (datetime), merchant_return_id (string), start_time_created (datetime), statuses (list<commercemerchantsettingsreturns_statuses_enum_param>)
	commercemerchantsettings_get_returnsTool := mcp.NewTool("commercemerchantsettings_get_returns",
		mcp.WithDescription("GET returns for CommerceMerchantSettings"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"end_time_created": map[string]any{
					"type":        "string",
					"description": "end_time_created parameter",
				},
				"merchant_return_id": map[string]any{
					"type":        "string",
					"description": "merchant_return_id parameter",
				},
				"start_time_created": map[string]any{
					"type":        "string",
					"description": "start_time_created parameter",
				},
				"statuses": map[string]any{
					"type":        "array",
					"description": "statuses parameter",
					"enum":        []string{"APPROVED", "DISAPPROVED", "MERCHANT_MARKED_COMPLETED", "REFUNDED", "REQUESTED"},
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: end_time_created (datetime), merchant_return_id (string), start_time_created (datetime), statuses (array<enum>) [APPROVED, DISAPPROVED, MERCHANT_MARKED_COMPLETED, REFUNDED, REQUESTED]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commercemerchantsettings_get_returnsTool)

	// commercemerchantsettings_get_setup_status tool
	// Available fields for CommerceMerchantSettingsSetupStatus: deals_setup, marketplace_approval_status, marketplace_approval_status_details, payment_setup, review_status, shop_setup
	commercemerchantsettings_get_setup_statusTool := mcp.NewTool("commercemerchantsettings_get_setup_status",
		mcp.WithDescription("GET setup_status for CommerceMerchantSettings"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CommerceMerchantSettingsSetupStatus objects. Available fields: deals_setup, marketplace_approval_status, marketplace_approval_status_details, payment_setup, review_status, shop_setup"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commercemerchantsettings_get_setup_statusTool)

	// commercemerchantsettings_get_shipping_profiles tool
	// Params object accepts: reference_id (string)
	commercemerchantsettings_get_shipping_profilesTool := mcp.NewTool("commercemerchantsettings_get_shipping_profiles",
		mcp.WithDescription("GET shipping_profiles for CommerceMerchantSettings"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"reference_id": map[string]any{
					"type":        "string",
					"description": "reference_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: reference_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commercemerchantsettings_get_shipping_profilesTool)

	// commercemerchantsettings_post_shipping_profiles tool
	// Params object accepts: handling_time (map), is_default (bool), is_default_shipping_profile (bool), name (string), reference_id (string), shipping_destinations (list<map>)
	commercemerchantsettings_post_shipping_profilesTool := mcp.NewTool("commercemerchantsettings_post_shipping_profiles",
		mcp.WithDescription("POST shipping_profiles for CommerceMerchantSettings"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"handling_time": map[string]any{
					"type":        "object",
					"description": "handling_time parameter",
				},
				"is_default": map[string]any{
					"type":        "boolean",
					"description": "is_default parameter",
				},
				"is_default_shipping_profile": map[string]any{
					"type":        "boolean",
					"description": "is_default_shipping_profile parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"reference_id": map[string]any{
					"type":        "string",
					"description": "reference_id parameter",
				},
				"shipping_destinations": map[string]any{
					"type":        "array",
					"description": "shipping_destinations parameter",
					"required":    true,
					"items":       map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: handling_time (object), is_default (boolean), is_default_shipping_profile (boolean), name (string) [required], reference_id (string), shipping_destinations (array<object>) [required]"),
		),
	)
	tools = append(tools, commercemerchantsettings_post_shipping_profilesTool)

	// commercemerchantsettings_get_shops tool
	// Available fields for Shop: commerce_merchant_settings, fb_sales_channel, id, ig_sales_channel, is_onsite_enabled, shop_status, workspace
	commercemerchantsettings_get_shopsTool := mcp.NewTool("commercemerchantsettings_get_shops",
		mcp.WithDescription("GET shops for CommerceMerchantSettings"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Shop objects. Available fields: commerce_merchant_settings, fb_sales_channel, id, ig_sales_channel, is_onsite_enabled, shop_status, workspace"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commercemerchantsettings_get_shopsTool)

	// commercemerchantsettings_get_tax_settings tool
	commercemerchantsettings_get_tax_settingsTool := mcp.NewTool("commercemerchantsettings_get_tax_settings",
		mcp.WithDescription("GET tax_settings for CommerceMerchantSettings"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commercemerchantsettings_get_tax_settingsTool)

	// commercemerchantsettings_get_ tool
	// Available fields for CommerceMerchantSettings: checkout_config, checkout_message, contact_email, cta, display_name, facebook_channel, id, instagram_channel, korea_ftc_listing, merchant_page, merchant_status, onsite_commerce_merchant, payment_provider, privacy_policy_localized, return_policy_localized, review_rejection_messages, review_rejection_reasons, terms
	commercemerchantsettings_get_Tool := mcp.NewTool("commercemerchantsettings_get_",
		mcp.WithDescription("GET  for CommerceMerchantSettings"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CommerceMerchantSettings objects. Available fields: checkout_config, checkout_message, contact_email, cta, display_name, facebook_channel, id, instagram_channel, korea_ftc_listing, merchant_page, merchant_status, onsite_commerce_merchant, payment_provider, privacy_policy_localized, return_policy_localized (and 3 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, commercemerchantsettings_get_Tool)

	return tools
}

// CommerceMerchantSettings handlers

// HandleCommercemerchantsettings_post_acknowledge_orders handles the commercemerchantsettings_post_acknowledge_orders tool with context-based auth
func HandleCommercemerchantsettings_post_acknowledge_orders(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_post_acknowledge_orders(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_post_acknowledge_orders: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_get_commerce_orders handles the commercemerchantsettings_get_commerce_orders tool with context-based auth
func HandleCommercemerchantsettings_get_commerce_orders(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_get_commerce_orders(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_get_commerce_orders: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_get_commerce_payouts handles the commercemerchantsettings_get_commerce_payouts tool with context-based auth
func HandleCommercemerchantsettings_get_commerce_payouts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_get_commerce_payouts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_get_commerce_payouts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_get_commerce_transactions handles the commercemerchantsettings_get_commerce_transactions tool with context-based auth
func HandleCommercemerchantsettings_get_commerce_transactions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_get_commerce_transactions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_get_commerce_transactions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_get_order_management_apps handles the commercemerchantsettings_get_order_management_apps tool with context-based auth
func HandleCommercemerchantsettings_get_order_management_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_get_order_management_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_get_order_management_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_post_order_management_apps handles the commercemerchantsettings_post_order_management_apps tool with context-based auth
func HandleCommercemerchantsettings_post_order_management_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Commercemerchantsettings_post_order_management_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_post_order_management_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_get_product_catalogs handles the commercemerchantsettings_get_product_catalogs tool with context-based auth
func HandleCommercemerchantsettings_get_product_catalogs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_get_product_catalogs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_get_product_catalogs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_get_returns handles the commercemerchantsettings_get_returns tool with context-based auth
func HandleCommercemerchantsettings_get_returns(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_get_returns(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_get_returns: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_get_setup_status handles the commercemerchantsettings_get_setup_status tool with context-based auth
func HandleCommercemerchantsettings_get_setup_status(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_get_setup_status(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_get_setup_status: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_get_shipping_profiles handles the commercemerchantsettings_get_shipping_profiles tool with context-based auth
func HandleCommercemerchantsettings_get_shipping_profiles(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_get_shipping_profiles(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_get_shipping_profiles: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_post_shipping_profiles handles the commercemerchantsettings_post_shipping_profiles tool with context-based auth
func HandleCommercemerchantsettings_post_shipping_profiles(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_post_shipping_profiles(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_post_shipping_profiles: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_get_shops handles the commercemerchantsettings_get_shops tool with context-based auth
func HandleCommercemerchantsettings_get_shops(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_get_shops(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_get_shops: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_get_tax_settings handles the commercemerchantsettings_get_tax_settings tool with context-based auth
func HandleCommercemerchantsettings_get_tax_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_get_tax_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_get_tax_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCommercemerchantsettings_get_ handles the commercemerchantsettings_get_ tool with context-based auth
func HandleCommercemerchantsettings_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCommerceMerchantSettingsClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Commercemerchantsettings_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute commercemerchantsettings_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}
