// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetProductCatalogTools returns MCP tools for ProductCatalog
func GetProductCatalogTools() []mcp.Tool {
	var tools []mcp.Tool


	// productcatalog_delete_agencies tool
	// Params object accepts: business (string)
	productcatalog_delete_agenciesTool := mcp.NewTool("productcatalog_delete_agencies",
		mcp.WithDescription("DELETE agencies for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type": "string",
					"description": "business parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required]"),
		),
	)
	tools = append(tools, productcatalog_delete_agenciesTool)

	// productcatalog_get_agencies tool
	// Available fields for Business: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id, two_factor_type, updated_by, updated_time, user_access_expire_time, verification_status, vertical, vertical_id
	productcatalog_get_agenciesTool := mcp.NewTool("productcatalog_get_agencies",
		mcp.WithDescription("GET agencies for ProductCatalog"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Business objects. Available fields: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id (and 7 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_agenciesTool)

	// productcatalog_post_agencies tool
	// Params object accepts: business (string), permitted_roles (list<productcatalogagencies_permitted_roles_enum_param>), permitted_tasks (list<productcatalogagencies_permitted_tasks_enum_param>), skip_defaults (bool), utm_settings (map)
	productcatalog_post_agenciesTool := mcp.NewTool("productcatalog_post_agencies",
		mcp.WithDescription("POST agencies for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type": "string",
					"description": "business parameter",
					"required": true,
				},
				"permitted_roles": map[string]any{
					"type": "array",
					"description": "permitted_roles parameter",
					"enum": []string{ "ADMIN", "ADVERTISER" },
					"items": map[string]any{"type": "string"},
				},
				"permitted_tasks": map[string]any{
					"type": "array",
					"description": "permitted_tasks parameter",
					"enum": []string{ "AA_ANALYZE", "ADVERTISE", "MANAGE", "MANAGE_AR" },
					"items": map[string]any{"type": "string"},
				},
				"skip_defaults": map[string]any{
					"type": "boolean",
					"description": "skip_defaults parameter",
				},
				"utm_settings": map[string]any{
					"type": "object",
					"description": "utm_settings parameter",
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required], permitted_roles (array<enum>) [ADMIN, ADVERTISER], permitted_tasks (array<enum>) [AA_ANALYZE, ADVERTISE, MANAGE, MANAGE_AR], skip_defaults (boolean), utm_settings (object)"),
		),
	)
	tools = append(tools, productcatalog_post_agenciesTool)

	// productcatalog_delete_assigned_users tool
	// Params object accepts: user (int)
	productcatalog_delete_assigned_usersTool := mcp.NewTool("productcatalog_delete_assigned_users",
		mcp.WithDescription("DELETE assigned_users for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"user": map[string]any{
					"type": "integer",
					"description": "user parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: user (integer) [required]"),
		),
	)
	tools = append(tools, productcatalog_delete_assigned_usersTool)

	// productcatalog_get_assigned_users tool
	// Available fields for AssignedUser: business, id, name, user_type
	// Params object accepts: business (string)
	productcatalog_get_assigned_usersTool := mcp.NewTool("productcatalog_get_assigned_users",
		mcp.WithDescription("GET assigned_users for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type": "string",
					"description": "business parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AssignedUser objects. Available fields: business, id, name, user_type"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_assigned_usersTool)

	// productcatalog_post_assigned_users tool
	// Params object accepts: tasks (list<productcatalogassigned_users_tasks_enum_param>), user (int)
	productcatalog_post_assigned_usersTool := mcp.NewTool("productcatalog_post_assigned_users",
		mcp.WithDescription("POST assigned_users for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"tasks": map[string]any{
					"type": "array",
					"description": "tasks parameter",
					"required": true,
					"enum": []string{ "AA_ANALYZE", "ADVERTISE", "MANAGE", "MANAGE_AR" },
					"items": map[string]any{"type": "string"},
				},
				"user": map[string]any{
					"type": "integer",
					"description": "user parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: tasks (array<enum>) [AA_ANALYZE, ADVERTISE, MANAGE, MANAGE_AR] [required], user (integer) [required]"),
		),
	)
	tools = append(tools, productcatalog_post_assigned_usersTool)

	// productcatalog_get_automotive_models tool
	// Available fields for AutomotiveModel: applinks, automotive_model_id, availability, body_style, category_specific_fields, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3, custom_number_4, description, drivetrain, exterior_color, finance_description, finance_type, fuel_type, generation, id, image_fetch_status, images, interior_color, interior_upholstery, make, model, price, sanitized_images, title, transmission, trim, unit_price, url, visibility, year
	// Params object accepts: bulk_pagination (bool), filter (Object)
	productcatalog_get_automotive_modelsTool := mcp.NewTool("productcatalog_get_automotive_models",
		mcp.WithDescription("GET automotive_models for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"bulk_pagination": map[string]any{
					"type": "boolean",
					"description": "bulk_pagination parameter",
				},
				"filter": map[string]any{
					"type": "object",
					"description": "filter parameter",
				},
			}),
			mcp.Description("Parameters object containing: bulk_pagination (boolean), filter (object)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AutomotiveModel objects. Available fields: applinks, automotive_model_id, availability, body_style, category_specific_fields, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3 (and 24 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_automotive_modelsTool)

	// productcatalog_post_batch tool
	// Params object accepts: allow_upsert (bool), fbe_external_business_id (string), requests (list<map>), version (unsigned int)
	productcatalog_post_batchTool := mcp.NewTool("productcatalog_post_batch",
		mcp.WithDescription("POST batch for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"allow_upsert": map[string]any{
					"type": "boolean",
					"description": "allow_upsert parameter",
				},
				"fbe_external_business_id": map[string]any{
					"type": "string",
					"description": "fbe_external_business_id parameter",
				},
				"requests": map[string]any{
					"type": "array",
					"description": "requests parameter",
					"required": true,
					"items": map[string]any{"type": "object"},
				},
				"version": map[string]any{
					"type": "integer",
					"description": "version parameter",
				},
			}),
			mcp.Description("Parameters object containing: allow_upsert (boolean), fbe_external_business_id (string), requests (array<object>) [required], version (integer)"),
		),
	)
	tools = append(tools, productcatalog_post_batchTool)

	// productcatalog_post_catalog_store tool
	// Params object accepts: page (string)
	productcatalog_post_catalog_storeTool := mcp.NewTool("productcatalog_post_catalog_store",
		mcp.WithDescription("POST catalog_store for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"page": map[string]any{
					"type": "string",
					"description": "page parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: page (string) [required]"),
		),
	)
	tools = append(tools, productcatalog_post_catalog_storeTool)

	// productcatalog_get_categories tool
	// Available fields for ProductCatalogCategory: criteria_value, description, destination_uri, image_url, name, num_items, tokens
	// Params object accepts: categorization_criteria (productcatalogcategories_categorization_criteria_enum_param), filter (Object)
	productcatalog_get_categoriesTool := mcp.NewTool("productcatalog_get_categories",
		mcp.WithDescription("GET categories for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"categorization_criteria": map[string]any{
					"type": "string",
					"description": "categorization_criteria parameter",
					"required": true,
					"enum": []string{ "BRAND", "CATEGORY", "PRODUCT_TYPE" },
				},
				"filter": map[string]any{
					"type": "object",
					"description": "filter parameter",
				},
			}),
			mcp.Description("Parameters object containing: categorization_criteria (enum) [BRAND, CATEGORY, PRODUCT_TYPE] [required], filter (object)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductCatalogCategory objects. Available fields: criteria_value, description, destination_uri, image_url, name, num_items, tokens"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_categoriesTool)

	// productcatalog_post_categories tool
	// Params object accepts: data (list<map>)
	productcatalog_post_categoriesTool := mcp.NewTool("productcatalog_post_categories",
		mcp.WithDescription("POST categories for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"data": map[string]any{
					"type": "array",
					"description": "data parameter",
					"required": true,
					"items": map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: data (array<object>) [required]"),
		),
	)
	tools = append(tools, productcatalog_post_categoriesTool)

	// productcatalog_get_check_batch_request_status tool
	// Available fields for CheckBatchRequestStatus: errors, errors_total_count, handle, ids_of_invalid_requests, status, warnings, warnings_total_count
	// Params object accepts: error_priority (productcatalogcheck_batch_request_status_error_priority_enum_param), handle (string), load_ids_of_invalid_requests (bool)
	productcatalog_get_check_batch_request_statusTool := mcp.NewTool("productcatalog_get_check_batch_request_status",
		mcp.WithDescription("GET check_batch_request_status for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"error_priority": map[string]any{
					"type": "string",
					"description": "error_priority parameter",
					"enum": []string{ "HIGH", "LOW", "MEDIUM" },
				},
				"handle": map[string]any{
					"type": "string",
					"description": "handle parameter",
					"required": true,
				},
				"load_ids_of_invalid_requests": map[string]any{
					"type": "boolean",
					"description": "load_ids_of_invalid_requests parameter",
				},
			}),
			mcp.Description("Parameters object containing: error_priority (enum) [HIGH, LOW, MEDIUM], handle (string) [required], load_ids_of_invalid_requests (boolean)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CheckBatchRequestStatus objects. Available fields: errors, errors_total_count, handle, ids_of_invalid_requests, status, warnings, warnings_total_count"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_check_batch_request_statusTool)

	// productcatalog_get_check_marketplace_partner_sellers_status tool
	// Available fields for ProductCatalogCheckMarketplacePartnerSellersStatus: sample_errors, session_id, status
	// Params object accepts: session_id (string)
	productcatalog_get_check_marketplace_partner_sellers_statusTool := mcp.NewTool("productcatalog_get_check_marketplace_partner_sellers_status",
		mcp.WithDescription("GET check_marketplace_partner_sellers_status for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"session_id": map[string]any{
					"type": "string",
					"description": "session_id parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: session_id (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductCatalogCheckMarketplacePartnerSellersStatus objects. Available fields: sample_errors, session_id, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_check_marketplace_partner_sellers_statusTool)

	// productcatalog_get_collaborative_ads_lsb_image_bank tool
	// Available fields for CPASLsbImageBank: ad_group_id, catalog_segment_proxy_id, id
	productcatalog_get_collaborative_ads_lsb_image_bankTool := mcp.NewTool("productcatalog_get_collaborative_ads_lsb_image_bank",
		mcp.WithDescription("GET collaborative_ads_lsb_image_bank for ProductCatalog"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CPASLsbImageBank objects. Available fields: ad_group_id, catalog_segment_proxy_id, id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_collaborative_ads_lsb_image_bankTool)

	// productcatalog_get_collaborative_ads_share_settings tool
	// Available fields for CollaborativeAdsShareSettings: agency_business, id, product_catalog_proxy_id, utm_campaign, utm_medium, utm_source
	productcatalog_get_collaborative_ads_share_settingsTool := mcp.NewTool("productcatalog_get_collaborative_ads_share_settings",
		mcp.WithDescription("GET collaborative_ads_share_settings for ProductCatalog"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CollaborativeAdsShareSettings objects. Available fields: agency_business, id, product_catalog_proxy_id, utm_campaign, utm_medium, utm_source"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_collaborative_ads_share_settingsTool)

	// productcatalog_post_cpas_lsb_image_bank tool
	// Params object accepts: ad_group_id (unsigned int), agency_business_id (unsigned int), backup_image_urls (list<string>)
	productcatalog_post_cpas_lsb_image_bankTool := mcp.NewTool("productcatalog_post_cpas_lsb_image_bank",
		mcp.WithDescription("POST cpas_lsb_image_bank for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"ad_group_id": map[string]any{
					"type": "integer",
					"description": "ad_group_id parameter",
				},
				"agency_business_id": map[string]any{
					"type": "integer",
					"description": "agency_business_id parameter",
				},
				"backup_image_urls": map[string]any{
					"type": "array",
					"description": "backup_image_urls parameter",
					"required": true,
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: ad_group_id (integer), agency_business_id (integer), backup_image_urls (array<string>) [required]"),
		),
	)
	tools = append(tools, productcatalog_post_cpas_lsb_image_bankTool)

	// productcatalog_get_creator_asset_creatives tool
	// Available fields for CreatorAssetCreative: id, image_url, moderation_status, product_item_retailer_id, product_url, retailer_id, video_url
	// Params object accepts: moderation_status (productcatalogcreator_asset_creatives_moderation_status_enum_param)
	productcatalog_get_creator_asset_creativesTool := mcp.NewTool("productcatalog_get_creator_asset_creatives",
		mcp.WithDescription("GET creator_asset_creatives for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"moderation_status": map[string]any{
					"type": "string",
					"description": "moderation_status parameter",
					"enum": []string{ "ARCHIVED", "ELIGIBLE", "EXPIRED", "INELIGIBLE", "IN_REVIEW", "PAUSED", "UNKNOWN" },
				},
			}),
			mcp.Description("Parameters object containing: moderation_status (enum) [ARCHIVED, ELIGIBLE, EXPIRED, INELIGIBLE, IN_REVIEW, ...]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CreatorAssetCreative objects. Available fields: id, image_url, moderation_status, product_item_retailer_id, product_url, retailer_id, video_url"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_creator_asset_creativesTool)

	// productcatalog_get_data_sources tool
	// Available fields for ProductCatalogDataSource: app_id, id, ingestion_source_type, name, upload_type
	// Params object accepts: ingestion_source_type (productcatalogdata_sources_ingestion_source_type_enum_param)
	productcatalog_get_data_sourcesTool := mcp.NewTool("productcatalog_get_data_sources",
		mcp.WithDescription("GET data_sources for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"ingestion_source_type": map[string]any{
					"type": "string",
					"description": "ingestion_source_type parameter",
					"enum": []string{ "ALL", "PRIMARY", "SUPPLEMENTARY" },
				},
			}),
			mcp.Description("Parameters object containing: ingestion_source_type (enum) [ALL, PRIMARY, SUPPLEMENTARY]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductCatalogDataSource objects. Available fields: app_id, id, ingestion_source_type, name, upload_type"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_data_sourcesTool)

	// productcatalog_get_destinations tool
	// Available fields for Destination: address, applinks, category_specific_fields, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3, custom_number_4, description, destination_id, id, image_fetch_status, images, name, price, price_change, sanitized_images, tags, types, unit_price, url, visibility
	// Params object accepts: bulk_pagination (bool), filter (Object)
	productcatalog_get_destinationsTool := mcp.NewTool("productcatalog_get_destinations",
		mcp.WithDescription("GET destinations for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"bulk_pagination": map[string]any{
					"type": "boolean",
					"description": "bulk_pagination parameter",
				},
				"filter": map[string]any{
					"type": "object",
					"description": "filter parameter",
				},
			}),
			mcp.Description("Parameters object containing: bulk_pagination (boolean), filter (object)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Destination objects. Available fields: address, applinks, category_specific_fields, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3, custom_number_4, description (and 13 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_destinationsTool)

	// productcatalog_get_diagnostics tool
	// Available fields for ProductCatalogDiagnosticGroup: affected_channels, affected_entity, affected_features, diagnostics, error_code, number_of_affected_entities, number_of_affected_items, severity, subtitle, title, type
	// Params object accepts: affected_channels (list<productcatalogdiagnostics_affected_channels_enum_param>), affected_entities (list<productcatalogdiagnostics_affected_entities_enum_param>), affected_features (list<productcatalogdiagnostics_affected_features_enum_param>), severities (list<productcatalogdiagnostics_severities_enum_param>), types (list<productcatalogdiagnostics_types_enum_param>)
	productcatalog_get_diagnosticsTool := mcp.NewTool("productcatalog_get_diagnostics",
		mcp.WithDescription("GET diagnostics for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"affected_channels": map[string]any{
					"type": "array",
					"description": "affected_channels parameter",
					"enum": []string{ "b2c_marketplace", "c2c_marketplace", "da", "daily_deals", "daily_deals_legacy", "ig_product_tagging", "marketplace", "marketplace_ads_deprecated", "marketplace_shops", "mini_shops", "offline_conversions", "shops", "universal_checkout", "whatsapp" },
					"items": map[string]any{"type": "string"},
				},
				"affected_entities": map[string]any{
					"type": "array",
					"description": "affected_entities parameter",
					"enum": []string{ "product_catalog", "product_event", "product_item", "product_set" },
					"items": map[string]any{"type": "string"},
				},
				"affected_features": map[string]any{
					"type": "array",
					"description": "affected_features parameter",
					"enum": []string{ "augmented_reality", "checkout" },
					"items": map[string]any{"type": "string"},
				},
				"severities": map[string]any{
					"type": "array",
					"description": "severities parameter",
					"enum": []string{ "MUST_FIX", "OPPORTUNITY" },
					"items": map[string]any{"type": "string"},
				},
				"types": map[string]any{
					"type": "array",
					"description": "types parameter",
					"enum": []string{ "AR_VISIBILITY_ISSUES", "ATTRIBUTES_INVALID", "ATTRIBUTES_MISSING", "CATEGORY", "CHECKOUT", "DA_VISIBILITY_ISSUES", "EVENT_SOURCE_ISSUES", "IMAGE_QUALITY", "LOW_QUALITY_TITLE_AND_DESCRIPTION", "POLICY_VIOLATION", "SHOPS_VISIBILITY_ISSUES" },
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: affected_channels (array<enum>) [b2c_marketplace, c2c_marketplace, da, daily_deals, daily_deals_legacy, ...], affected_entities (array<enum>) [product_catalog, product_event, product_item, product_set], affected_features (array<enum>) [augmented_reality, checkout], severities (array<enum>) [MUST_FIX, OPPORTUNITY], types (array<enum>) [AR_VISIBILITY_ISSUES, ATTRIBUTES_INVALID, ATTRIBUTES_MISSING, CATEGORY, CHECKOUT, ...]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductCatalogDiagnosticGroup objects. Available fields: affected_channels, affected_entity, affected_features, diagnostics, error_code, number_of_affected_entities, number_of_affected_items, severity, subtitle, title, type"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_diagnosticsTool)

	// productcatalog_get_event_stats tool
	// Available fields for ProductEventStat: date_start, date_stop, device_type, event, event_source, total_content_ids_matched_other_catalogs, total_matched_content_ids, total_unmatched_content_ids, unique_content_ids_matched_other_catalogs, unique_matched_content_ids, unique_unmatched_content_ids
	// Params object accepts: breakdowns (list<productcatalogevent_stats_breakdowns_enum_param>)
	productcatalog_get_event_statsTool := mcp.NewTool("productcatalog_get_event_stats",
		mcp.WithDescription("GET event_stats for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"breakdowns": map[string]any{
					"type": "array",
					"description": "breakdowns parameter",
					"enum": []string{ "DEVICE_TYPE" },
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: breakdowns (array<enum>) [DEVICE_TYPE]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductEventStat objects. Available fields: date_start, date_stop, device_type, event, event_source, total_content_ids_matched_other_catalogs, total_matched_content_ids, total_unmatched_content_ids, unique_content_ids_matched_other_catalogs, unique_matched_content_ids, unique_unmatched_content_ids"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_event_statsTool)

	// productcatalog_delete_external_event_sources tool
	// Params object accepts: external_event_sources (Object)
	productcatalog_delete_external_event_sourcesTool := mcp.NewTool("productcatalog_delete_external_event_sources",
		mcp.WithDescription("DELETE external_event_sources for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"external_event_sources": map[string]any{
					"type": "object",
					"description": "external_event_sources parameter",
				},
			}),
			mcp.Description("Parameters object containing: external_event_sources (object)"),
		),
	)
	tools = append(tools, productcatalog_delete_external_event_sourcesTool)

	// productcatalog_get_external_event_sources tool
	// Available fields for ExternalEventSource: id, name, source_type
	productcatalog_get_external_event_sourcesTool := mcp.NewTool("productcatalog_get_external_event_sources",
		mcp.WithDescription("GET external_event_sources for ProductCatalog"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ExternalEventSource objects. Available fields: id, name, source_type"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_external_event_sourcesTool)

	// productcatalog_post_external_event_sources tool
	// Params object accepts: external_event_sources (Object)
	productcatalog_post_external_event_sourcesTool := mcp.NewTool("productcatalog_post_external_event_sources",
		mcp.WithDescription("POST external_event_sources for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"external_event_sources": map[string]any{
					"type": "object",
					"description": "external_event_sources parameter",
				},
			}),
			mcp.Description("Parameters object containing: external_event_sources (object)"),
		),
	)
	tools = append(tools, productcatalog_post_external_event_sourcesTool)

	// productcatalog_get_flights tool
	// Available fields for Flight: applinks, category_specific_fields, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3, custom_number_4, description, destination_airport, destination_city, flight_id, id, image_fetch_status, images, oneway_currency, oneway_price, origin_airport, origin_city, price, product_priority_0, product_priority_1, product_priority_2, product_priority_3, product_priority_4, sanitized_images, tags, unit_price, url, visibility
	// Params object accepts: bulk_pagination (bool), filter (Object)
	productcatalog_get_flightsTool := mcp.NewTool("productcatalog_get_flights",
		mcp.WithDescription("GET flights for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"bulk_pagination": map[string]any{
					"type": "boolean",
					"description": "bulk_pagination parameter",
				},
				"filter": map[string]any{
					"type": "object",
					"description": "filter parameter",
				},
			}),
			mcp.Description("Parameters object containing: bulk_pagination (boolean), filter (object)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Flight objects. Available fields: applinks, category_specific_fields, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3, custom_number_4, description, destination_airport (and 20 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_flightsTool)

	// productcatalog_post_geolocated_items_batch tool
	// Params object accepts: allow_upsert (bool), item_type (string), requests (map)
	productcatalog_post_geolocated_items_batchTool := mcp.NewTool("productcatalog_post_geolocated_items_batch",
		mcp.WithDescription("POST geolocated_items_batch for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"allow_upsert": map[string]any{
					"type": "boolean",
					"description": "allow_upsert parameter",
				},
				"item_type": map[string]any{
					"type": "string",
					"description": "item_type parameter",
					"required": true,
				},
				"requests": map[string]any{
					"type": "object",
					"description": "requests parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: allow_upsert (boolean), item_type (string) [required], requests (object) [required]"),
		),
	)
	tools = append(tools, productcatalog_post_geolocated_items_batchTool)

	// productcatalog_get_home_listings tool
	// Available fields for HomeListing: ac_type, additional_fees_description, address, agent_company, agent_email, agent_fb_page_id, agent_name, agent_phone, applinks, area_size, area_unit, availability, category_specific_fields, co_2_emission_rating_eu, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3, custom_number_4, days_on_market, description, energy_rating_eu, furnish_type, group_id, heating_type, home_listing_id, id, image_fetch_status, images, laundry_type, listing_type, max_currency, max_price, min_currency, min_price, name, num_baths, num_beds, num_rooms, num_units, parking_type, partner_verification, pet_policy, price, property_type, sanitized_images, securitydeposit_currency, securitydeposit_price, tags, unit_price, url, visibility, year_built
	// Params object accepts: bulk_pagination (bool), filter (Object)
	productcatalog_get_home_listingsTool := mcp.NewTool("productcatalog_get_home_listings",
		mcp.WithDescription("GET home_listings for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"bulk_pagination": map[string]any{
					"type": "boolean",
					"description": "bulk_pagination parameter",
				},
				"filter": map[string]any{
					"type": "object",
					"description": "filter parameter",
				},
			}),
			mcp.Description("Parameters object containing: bulk_pagination (boolean), filter (object)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for HomeListing objects. Available fields: ac_type, additional_fees_description, address, agent_company, agent_email, agent_fb_page_id, agent_name, agent_phone, applinks, area_size, area_unit, availability, category_specific_fields, co_2_emission_rating_eu, currency (and 44 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_home_listingsTool)

	// productcatalog_post_home_listings tool
	// Params object accepts: address (Object), availability (string), currency (string), description (string), home_listing_id (string), images (list<Object>), listing_type (string), name (string), num_baths (float), num_beds (float), num_units (float), price (float), property_type (string), url (string), year_built (unsigned int)
	productcatalog_post_home_listingsTool := mcp.NewTool("productcatalog_post_home_listings",
		mcp.WithDescription("POST home_listings for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"address": map[string]any{
					"type": "object",
					"description": "address parameter",
					"required": true,
				},
				"availability": map[string]any{
					"type": "string",
					"description": "availability parameter",
					"required": true,
				},
				"currency": map[string]any{
					"type": "string",
					"description": "currency parameter",
					"required": true,
				},
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
				},
				"home_listing_id": map[string]any{
					"type": "string",
					"description": "home_listing_id parameter",
					"required": true,
				},
				"images": map[string]any{
					"type": "array",
					"description": "images parameter",
					"required": true,
					"items": map[string]any{"type": "object"},
				},
				"listing_type": map[string]any{
					"type": "string",
					"description": "listing_type parameter",
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
					"required": true,
				},
				"num_baths": map[string]any{
					"type": "number",
					"description": "num_baths parameter",
				},
				"num_beds": map[string]any{
					"type": "number",
					"description": "num_beds parameter",
				},
				"num_units": map[string]any{
					"type": "number",
					"description": "num_units parameter",
				},
				"price": map[string]any{
					"type": "number",
					"description": "price parameter",
					"required": true,
				},
				"property_type": map[string]any{
					"type": "string",
					"description": "property_type parameter",
				},
				"url": map[string]any{
					"type": "string",
					"description": "url parameter",
					"required": true,
				},
				"year_built": map[string]any{
					"type": "integer",
					"description": "year_built parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: address (object) [required], availability (string) [required], currency (string) [required], description (string), home_listing_id (string) [required], images (array<object>) [required], listing_type (string), name (string) [required], num_baths (number), num_beds (number), num_units (number), price (number) [required], property_type (string), url (string) [required], year_built (integer) [required]"),
		),
	)
	tools = append(tools, productcatalog_post_home_listingsTool)

	// productcatalog_get_hotel_rooms_batch tool
	// Available fields for ProductCatalogHotelRoomsBatch: errors, errors_total_count, handle, status
	// Params object accepts: handle (string)
	productcatalog_get_hotel_rooms_batchTool := mcp.NewTool("productcatalog_get_hotel_rooms_batch",
		mcp.WithDescription("GET hotel_rooms_batch for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"handle": map[string]any{
					"type": "string",
					"description": "handle parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: handle (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductCatalogHotelRoomsBatch objects. Available fields: errors, errors_total_count, handle, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_hotel_rooms_batchTool)

	// productcatalog_post_hotel_rooms_batch tool
	// Params object accepts: file (file), password (string), standard (productcataloghotel_rooms_batch_standard_enum_param), update_only (bool), url (string), username (string)
	productcatalog_post_hotel_rooms_batchTool := mcp.NewTool("productcatalog_post_hotel_rooms_batch",
		mcp.WithDescription("POST hotel_rooms_batch for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"file": map[string]any{
					"type": "string",
					"description": "file parameter",
				},
				"password": map[string]any{
					"type": "string",
					"description": "password parameter",
				},
				"standard": map[string]any{
					"type": "string",
					"description": "standard parameter",
					"required": true,
					"enum": []string{ "google" },
				},
				"update_only": map[string]any{
					"type": "boolean",
					"description": "update_only parameter",
				},
				"url": map[string]any{
					"type": "string",
					"description": "url parameter",
				},
				"username": map[string]any{
					"type": "string",
					"description": "username parameter",
				},
			}),
			mcp.Description("Parameters object containing: file (file), password (string), standard (enum) [google] [required], update_only (boolean), url (string), username (string)"),
		),
	)
	tools = append(tools, productcatalog_post_hotel_rooms_batchTool)

	// productcatalog_get_hotels tool
	// Available fields for Hotel: address, applinks, brand, category, category_specific_fields, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3, custom_number_4, description, guest_ratings, hotel_id, id, image_fetch_status, images, lowest_base_price, loyalty_program, margin_level, name, phone, product_priority_0, product_priority_1, product_priority_2, product_priority_3, product_priority_4, sale_price, sanitized_images, star_rating, tags, unit_price, url, visibility
	// Params object accepts: bulk_pagination (bool), filter (Object)
	productcatalog_get_hotelsTool := mcp.NewTool("productcatalog_get_hotels",
		mcp.WithDescription("GET hotels for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"bulk_pagination": map[string]any{
					"type": "boolean",
					"description": "bulk_pagination parameter",
				},
				"filter": map[string]any{
					"type": "object",
					"description": "filter parameter",
				},
			}),
			mcp.Description("Parameters object containing: bulk_pagination (boolean), filter (object)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Hotel objects. Available fields: address, applinks, brand, category, category_specific_fields, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3 (and 24 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_hotelsTool)

	// productcatalog_post_hotels tool
	// Params object accepts: address (Object), applinks (Object), base_price (unsigned int), brand (string), currency (string), description (string), guest_ratings (list<Object>), hotel_id (string), images (list<Object>), name (string), phone (string), star_rating (float), url (string)
	productcatalog_post_hotelsTool := mcp.NewTool("productcatalog_post_hotels",
		mcp.WithDescription("POST hotels for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"address": map[string]any{
					"type": "object",
					"description": "address parameter",
					"required": true,
				},
				"applinks": map[string]any{
					"type": "object",
					"description": "applinks parameter",
				},
				"base_price": map[string]any{
					"type": "integer",
					"description": "base_price parameter",
				},
				"brand": map[string]any{
					"type": "string",
					"description": "brand parameter",
				},
				"currency": map[string]any{
					"type": "string",
					"description": "currency parameter",
				},
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
					"required": true,
				},
				"guest_ratings": map[string]any{
					"type": "array",
					"description": "guest_ratings parameter",
					"items": map[string]any{"type": "object"},
				},
				"hotel_id": map[string]any{
					"type": "string",
					"description": "hotel_id parameter",
				},
				"images": map[string]any{
					"type": "array",
					"description": "images parameter",
					"required": true,
					"items": map[string]any{"type": "object"},
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
					"required": true,
				},
				"phone": map[string]any{
					"type": "string",
					"description": "phone parameter",
				},
				"star_rating": map[string]any{
					"type": "number",
					"description": "star_rating parameter",
				},
				"url": map[string]any{
					"type": "string",
					"description": "url parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: address (object) [required], applinks (object), base_price (integer), brand (string), currency (string), description (string) [required], guest_ratings (array<object>), hotel_id (string), images (array<object>) [required], name (string) [required], phone (string), star_rating (number), url (string) [required]"),
		),
	)
	tools = append(tools, productcatalog_post_hotelsTool)

	// productcatalog_post_items_batch tool
	// Params object accepts: allow_upsert (bool), item_sub_type (productcatalogitems_batch_item_sub_type_enum_param), item_type (string), requests (map), version (unsigned int)
	productcatalog_post_items_batchTool := mcp.NewTool("productcatalog_post_items_batch",
		mcp.WithDescription("POST items_batch for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"allow_upsert": map[string]any{
					"type": "boolean",
					"description": "allow_upsert parameter",
				},
				"item_sub_type": map[string]any{
					"type": "string",
					"description": "item_sub_type parameter",
					"enum": []string{ "APPLIANCES", "BABY_FEEDING", "BABY_TRANSPORT", "BEAUTY", "BEDDING", "CAMERAS", "CELL_PHONES_AND_SMART_WATCHES", "CLEANING_SUPPLIES", "CLOTHING", "CLOTHING_ACCESSORIES", "COMPUTERS_AND_TABLETS", "DIAPERING_AND_POTTY_TRAINING", "ELECTRONICS_ACCESSORIES", "FURNITURE", "HEALTH", "HOME_GOODS", "JEWELRY", "NURSERY", "PRINTERS_AND_SCANNERS", "PROJECTORS", "SHOES_AND_FOOTWEAR", "SOFTWARE", "TOYS", "TVS_AND_MONITORS", "VIDEO_GAME_CONSOLES_AND_VIDEO_GAMES", "WATCHES" },
				},
				"item_type": map[string]any{
					"type": "string",
					"description": "item_type parameter",
					"required": true,
				},
				"requests": map[string]any{
					"type": "object",
					"description": "requests parameter",
					"required": true,
				},
				"version": map[string]any{
					"type": "integer",
					"description": "version parameter",
				},
			}),
			mcp.Description("Parameters object containing: allow_upsert (boolean), item_sub_type (enum) [APPLIANCES, BABY_FEEDING, BABY_TRANSPORT, BEAUTY, BEDDING, ...], item_type (string) [required], requests (object) [required], version (integer)"),
		),
	)
	tools = append(tools, productcatalog_post_items_batchTool)

	// productcatalog_post_localized_items_batch tool
	// Params object accepts: allow_upsert (bool), item_type (string), requests (map), version (unsigned int)
	productcatalog_post_localized_items_batchTool := mcp.NewTool("productcatalog_post_localized_items_batch",
		mcp.WithDescription("POST localized_items_batch for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"allow_upsert": map[string]any{
					"type": "boolean",
					"description": "allow_upsert parameter",
				},
				"item_type": map[string]any{
					"type": "string",
					"description": "item_type parameter",
					"required": true,
				},
				"requests": map[string]any{
					"type": "object",
					"description": "requests parameter",
					"required": true,
				},
				"version": map[string]any{
					"type": "integer",
					"description": "version parameter",
				},
			}),
			mcp.Description("Parameters object containing: allow_upsert (boolean), item_type (string) [required], requests (object) [required], version (integer)"),
		),
	)
	tools = append(tools, productcatalog_post_localized_items_batchTool)

	// productcatalog_post_marketplace_partner_sellers_details tool
	// Params object accepts: requests (map)
	productcatalog_post_marketplace_partner_sellers_detailsTool := mcp.NewTool("productcatalog_post_marketplace_partner_sellers_details",
		mcp.WithDescription("POST marketplace_partner_sellers_details for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"requests": map[string]any{
					"type": "object",
					"description": "requests parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: requests (object) [required]"),
		),
	)
	tools = append(tools, productcatalog_post_marketplace_partner_sellers_detailsTool)

	// productcatalog_post_marketplace_partner_signals tool
	// Params object accepts: event_name (productcatalogmarketplace_partner_signals_event_name_enum_param), event_source_url (string), event_time (datetime), order_data (map), user_data (map)
	productcatalog_post_marketplace_partner_signalsTool := mcp.NewTool("productcatalog_post_marketplace_partner_signals",
		mcp.WithDescription("POST marketplace_partner_signals for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"event_name": map[string]any{
					"type": "string",
					"description": "event_name parameter",
					"required": true,
					"enum": []string{ "ADD_TO_CART", "PURCHASE", "TEST", "VIEW_ITEM" },
				},
				"event_source_url": map[string]any{
					"type": "string",
					"description": "event_source_url parameter",
				},
				"event_time": map[string]any{
					"type": "string",
					"description": "event_time parameter",
					"required": true,
				},
				"order_data": map[string]any{
					"type": "object",
					"description": "order_data parameter",
				},
				"user_data": map[string]any{
					"type": "object",
					"description": "user_data parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: event_name (enum) [ADD_TO_CART, PURCHASE, TEST, VIEW_ITEM] [required], event_source_url (string), event_time (datetime) [required], order_data (object), user_data (object) [required]"),
		),
	)
	tools = append(tools, productcatalog_post_marketplace_partner_signalsTool)

	// productcatalog_get_pricing_variables_batch tool
	// Available fields for ProductCatalogPricingVariablesBatch: errors, errors_total_count, handle, status
	// Params object accepts: handle (string)
	productcatalog_get_pricing_variables_batchTool := mcp.NewTool("productcatalog_get_pricing_variables_batch",
		mcp.WithDescription("GET pricing_variables_batch for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"handle": map[string]any{
					"type": "string",
					"description": "handle parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: handle (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductCatalogPricingVariablesBatch objects. Available fields: errors, errors_total_count, handle, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_pricing_variables_batchTool)

	// productcatalog_post_pricing_variables_batch tool
	// Params object accepts: file (file), password (string), standard (productcatalogpricing_variables_batch_standard_enum_param), update_only (bool), url (string), username (string)
	productcatalog_post_pricing_variables_batchTool := mcp.NewTool("productcatalog_post_pricing_variables_batch",
		mcp.WithDescription("POST pricing_variables_batch for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"file": map[string]any{
					"type": "string",
					"description": "file parameter",
				},
				"password": map[string]any{
					"type": "string",
					"description": "password parameter",
				},
				"standard": map[string]any{
					"type": "string",
					"description": "standard parameter",
					"required": true,
					"enum": []string{ "google" },
				},
				"update_only": map[string]any{
					"type": "boolean",
					"description": "update_only parameter",
				},
				"url": map[string]any{
					"type": "string",
					"description": "url parameter",
				},
				"username": map[string]any{
					"type": "string",
					"description": "username parameter",
				},
			}),
			mcp.Description("Parameters object containing: file (file), password (string), standard (enum) [google] [required], update_only (boolean), url (string), username (string)"),
		),
	)
	tools = append(tools, productcatalog_post_pricing_variables_batchTool)

	// productcatalog_get_product_feeds tool
	// Available fields for ProductFeed: country, created_time, default_currency, deletion_enabled, delimiter, encoding, file_name, id, ingestion_source_type, item_sub_type, latest_upload, migrated_from_feed_id, name, override_type, primary_feeds, product_count, quoted_fields_mode, schedule, supplementary_feeds, update_schedule
	productcatalog_get_product_feedsTool := mcp.NewTool("productcatalog_get_product_feeds",
		mcp.WithDescription("GET product_feeds for ProductCatalog"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductFeed objects. Available fields: country, created_time, default_currency, deletion_enabled, delimiter, encoding, file_name, id, ingestion_source_type, item_sub_type, latest_upload, migrated_from_feed_id, name, override_type, primary_feeds (and 5 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_product_feedsTool)

	// productcatalog_post_product_feeds tool
	// Params object accepts: country (string), default_currency (string), deletion_enabled (bool), delimiter (productcatalogproduct_feeds_delimiter_enum_param), encoding (productcatalogproduct_feeds_encoding_enum_param), feed_type (productcatalogproduct_feeds_feed_type_enum_param), file_name (string), ingestion_source_type (productcatalogproduct_feeds_ingestion_source_type_enum_param), item_sub_type (productcatalogproduct_feeds_item_sub_type_enum_param), migrated_from_feed_id (string), name (string), override_type (productcatalogproduct_feeds_override_type_enum_param), override_value (string), primary_feed_ids (list<string>), quoted_fields_mode (productcatalogproduct_feeds_quoted_fields_mode_enum_param), rules (list<string>), schedule (string), selected_override_fields (list<string>), update_schedule (string)
	productcatalog_post_product_feedsTool := mcp.NewTool("productcatalog_post_product_feeds",
		mcp.WithDescription("POST product_feeds for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"country": map[string]any{
					"type": "string",
					"description": "country parameter",
				},
				"default_currency": map[string]any{
					"type": "string",
					"description": "default_currency parameter",
				},
				"deletion_enabled": map[string]any{
					"type": "boolean",
					"description": "deletion_enabled parameter",
				},
				"delimiter": map[string]any{
					"type": "string",
					"description": "delimiter parameter",
					"enum": []string{ "AUTODETECT", "BAR", "COMMA", "SEMICOLON", "TAB", "TILDE" },
				},
				"encoding": map[string]any{
					"type": "string",
					"description": "encoding parameter",
					"enum": []string{ "AUTODETECT", "LATIN1", "UTF16BE", "UTF16LE", "UTF32BE", "UTF32LE", "UTF8" },
				},
				"feed_type": map[string]any{
					"type": "string",
					"description": "feed_type parameter",
					"enum": []string{ "AUTOMOTIVE_MODEL", "COLLECTION", "DESTINATION", "FLIGHT", "HOME_LISTING", "HOTEL", "HOTEL_ROOM", "LOCAL_INVENTORY", "MEDIA_TITLE", "OFFER", "PRODUCTS", "PRODUCT_RATINGS_AND_REVIEWS", "TRANSACTABLE_ITEMS", "VEHICLES", "VEHICLE_OFFER" },
				},
				"file_name": map[string]any{
					"type": "string",
					"description": "file_name parameter",
				},
				"ingestion_source_type": map[string]any{
					"type": "string",
					"description": "ingestion_source_type parameter",
					"enum": []string{ "PRIMARY_FEED", "SUPPLEMENTARY_FEED" },
				},
				"item_sub_type": map[string]any{
					"type": "string",
					"description": "item_sub_type parameter",
					"enum": []string{ "APPLIANCES", "BABY_FEEDING", "BABY_TRANSPORT", "BEAUTY", "BEDDING", "CAMERAS", "CELL_PHONES_AND_SMART_WATCHES", "CLEANING_SUPPLIES", "CLOTHING", "CLOTHING_ACCESSORIES", "COMPUTERS_AND_TABLETS", "DIAPERING_AND_POTTY_TRAINING", "ELECTRONICS_ACCESSORIES", "FURNITURE", "HEALTH", "HOME_GOODS", "JEWELRY", "NURSERY", "PRINTERS_AND_SCANNERS", "PROJECTORS", "SHOES_AND_FOOTWEAR", "SOFTWARE", "TOYS", "TVS_AND_MONITORS", "VIDEO_GAME_CONSOLES_AND_VIDEO_GAMES", "WATCHES" },
				},
				"migrated_from_feed_id": map[string]any{
					"type": "string",
					"description": "migrated_from_feed_id parameter",
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
				},
				"override_type": map[string]any{
					"type": "string",
					"description": "override_type parameter",
					"enum": []string{ "BATCH_API_LANGUAGE_OR_COUNTRY", "CATALOG_SEGMENT_CUSTOMIZE_DEFAULT", "COUNTRY", "LANGUAGE", "LANGUAGE_AND_COUNTRY", "LOCAL", "SMART_PIXEL_LANGUAGE_OR_COUNTRY", "VERSION" },
				},
				"override_value": map[string]any{
					"type": "string",
					"description": "override_value parameter",
				},
				"primary_feed_ids": map[string]any{
					"type": "array",
					"description": "primary_feed_ids parameter",
					"items": map[string]any{"type": "string"},
				},
				"quoted_fields_mode": map[string]any{
					"type": "string",
					"description": "quoted_fields_mode parameter",
					"enum": []string{ "autodetect", "off", "on" },
				},
				"rules": map[string]any{
					"type": "array",
					"description": "rules parameter",
					"items": map[string]any{"type": "string"},
				},
				"schedule": map[string]any{
					"type": "string",
					"description": "schedule parameter",
				},
				"selected_override_fields": map[string]any{
					"type": "array",
					"description": "selected_override_fields parameter",
					"items": map[string]any{"type": "string"},
				},
				"update_schedule": map[string]any{
					"type": "string",
					"description": "update_schedule parameter",
				},
			}),
			mcp.Description("Parameters object containing: country (string), default_currency (string), deletion_enabled (boolean), delimiter (enum) [AUTODETECT, BAR, COMMA, SEMICOLON, TAB, ...], encoding (enum) [AUTODETECT, LATIN1, UTF16BE, UTF16LE, UTF32BE, ...], feed_type (enum) [AUTOMOTIVE_MODEL, COLLECTION, DESTINATION, FLIGHT, HOME_LISTING, ...], file_name (string), ingestion_source_type (enum) [PRIMARY_FEED, SUPPLEMENTARY_FEED], item_sub_type (enum) [APPLIANCES, BABY_FEEDING, BABY_TRANSPORT, BEAUTY, BEDDING, ...], migrated_from_feed_id (string), name (string), override_type (enum) [BATCH_API_LANGUAGE_OR_COUNTRY, CATALOG_SEGMENT_CUSTOMIZE_DEFAULT, COUNTRY, LANGUAGE, LANGUAGE_AND_COUNTRY, ...], override_value (string), primary_feed_ids (array<string>), quoted_fields_mode (enum) [autodetect, off, on], rules (array<string>), schedule (string), selected_override_fields (array<string>), update_schedule (string)"),
		),
	)
	tools = append(tools, productcatalog_post_product_feedsTool)

	// productcatalog_get_product_groups tool
	// Available fields for ProductGroup: id, product_catalog, retailer_id, variants
	productcatalog_get_product_groupsTool := mcp.NewTool("productcatalog_get_product_groups",
		mcp.WithDescription("GET product_groups for ProductCatalog"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductGroup objects. Available fields: id, product_catalog, retailer_id, variants"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_product_groupsTool)

	// productcatalog_post_product_groups tool
	// Params object accepts: retailer_id (string), variants (list<Object>)
	productcatalog_post_product_groupsTool := mcp.NewTool("productcatalog_post_product_groups",
		mcp.WithDescription("POST product_groups for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"retailer_id": map[string]any{
					"type": "string",
					"description": "retailer_id parameter",
				},
				"variants": map[string]any{
					"type": "array",
					"description": "variants parameter",
					"items": map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: retailer_id (string), variants (array<object>)"),
		),
	)
	tools = append(tools, productcatalog_post_product_groupsTool)

	// productcatalog_get_product_sets tool
	// Available fields for ProductSet: auto_creation_url, filter, id, latest_metadata, live_metadata, name, ordering_info, product_catalog, product_count, retailer_id
	// Params object accepts: ancestor_id (string), has_children (bool), parent_id (string), retailer_id (string)
	productcatalog_get_product_setsTool := mcp.NewTool("productcatalog_get_product_sets",
		mcp.WithDescription("GET product_sets for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"ancestor_id": map[string]any{
					"type": "string",
					"description": "ancestor_id parameter",
				},
				"has_children": map[string]any{
					"type": "boolean",
					"description": "has_children parameter",
				},
				"parent_id": map[string]any{
					"type": "string",
					"description": "parent_id parameter",
				},
				"retailer_id": map[string]any{
					"type": "string",
					"description": "retailer_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: ancestor_id (string), has_children (boolean), parent_id (string), retailer_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductSet objects. Available fields: auto_creation_url, filter, id, latest_metadata, live_metadata, name, ordering_info, product_catalog, product_count, retailer_id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_product_setsTool)

	// productcatalog_post_product_sets tool
	// Params object accepts: filter (Object), metadata (map), name (string), ordering_info (list<unsigned int>), publish_to_shops (list<map>), retailer_id (string)
	productcatalog_post_product_setsTool := mcp.NewTool("productcatalog_post_product_sets",
		mcp.WithDescription("POST product_sets for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"filter": map[string]any{
					"type": "object",
					"description": "filter parameter",
				},
				"metadata": map[string]any{
					"type": "object",
					"description": "metadata parameter",
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
					"required": true,
				},
				"ordering_info": map[string]any{
					"type": "array",
					"description": "ordering_info parameter",
					"items": map[string]any{"type": "integer"},
				},
				"publish_to_shops": map[string]any{
					"type": "array",
					"description": "publish_to_shops parameter",
					"items": map[string]any{"type": "object"},
				},
				"retailer_id": map[string]any{
					"type": "string",
					"description": "retailer_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: filter (object), metadata (object), name (string) [required], ordering_info (array<integer>), publish_to_shops (array<object>), retailer_id (string)"),
		),
	)
	tools = append(tools, productcatalog_post_product_setsTool)

	// productcatalog_get_product_sets_batch tool
	// Available fields for ProductCatalogProductSetsBatch: errors, errors_total_count, handle, status
	// Params object accepts: handle (string)
	productcatalog_get_product_sets_batchTool := mcp.NewTool("productcatalog_get_product_sets_batch",
		mcp.WithDescription("GET product_sets_batch for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"handle": map[string]any{
					"type": "string",
					"description": "handle parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: handle (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductCatalogProductSetsBatch objects. Available fields: errors, errors_total_count, handle, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_product_sets_batchTool)

	// productcatalog_get_products tool
	// Available fields for ProductItem: additional_image_cdn_urls, additional_image_urls, additional_variant_attributes, age_group, applinks, availability, brand, bundle_items, bundle_retailer_ids, capability_to_review_status, category, category_specific_fields, color, commerce_insights, condition, currency, custom_data, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3, custom_number_4, description, errors, expiration_date, fb_product_category, gender, generated_background_images, generated_background_images_ad_usage, gtin, id, image_cdn_urls, image_fetch_status, image_url, images, importer_address, importer_name, invalidation_errors, inventory, is_bundle_hero, manufacturer_info, manufacturer_part_number, marked_for_product_launch, material, mobile_link, name, ordering_index, origin_country, parent_product_id, pattern, post_conversion_signal_based_enforcement_appeal_eligibility, price, product_catalog, product_feed, product_group, product_local_info, product_relationship, product_type, quantity_to_sell_on_facebook, retailer_id, retailer_product_group_id, review_rejection_reasons, review_status, sale_price, sale_price_end_date, sale_price_start_date, shipping_weight_unit, shipping_weight_value, short_description, size, start_date, tags, url, vendor_id, video_fetch_status, videos, visibility, wa_compliance_category
	// Params object accepts: bulk_pagination (bool), error_priority (productcatalogproducts_error_priority_enum_param), error_type (productcatalogproducts_error_type_enum_param), filter (Object), return_only_approved_products (bool)
	productcatalog_get_productsTool := mcp.NewTool("productcatalog_get_products",
		mcp.WithDescription("GET products for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"bulk_pagination": map[string]any{
					"type": "boolean",
					"description": "bulk_pagination parameter",
				},
				"error_priority": map[string]any{
					"type": "string",
					"description": "error_priority parameter",
					"enum": []string{ "HIGH", "LOW", "MEDIUM" },
				},
				"error_type": map[string]any{
					"type": "string",
					"description": "error_type parameter",
					"enum": []string{ "ADDRESS_BLOCKLISTED_IN_MARKET", "AGGREGATED_LOCALIZATION_ISSUES", "APP_HAS_NO_AEM_SETUP", "AR_DELETED_DUE_TO_UPDATE", "AR_POLICY_VIOLATED", "AVAILABLE", "BAD_QUALITY_IMAGE", "BIG_CATALOG_WITH_ALL_ITEMS_IN_STOCK", "BIZ_MSG_AI_AGENT_DISABLED_BY_USER", "BIZ_MSG_GEN_AI_POLICY_VIOLATED", "CANNOT_EDIT_SUBSCRIPTION_PRODUCTS", "CATALOG_NOT_CONNECTED_TO_EVENT_SOURCE", "CHECKOUT_DISABLED_BY_USER", "COMMERCE_ACCOUNT_LEGAL_ADDRESS_INVALID", "COMMERCE_ACCOUNT_NOT_LEGALLY_COMPLIANT", "CRAWLED_AVAILABILITY_MISMATCH", "DA_DISABLED_BY_USER", "DA_POLICY_UNFIT_FOR_AUDIENCE", "DA_POLICY_VIOLATION", "DELETED_ITEM", "DIGITAL_GOODS_NOT_AVAILABLE_FOR_CHECKOUT", "DUPLICATE_IMAGES", "DUPLICATE_TITLE_AND_DESCRIPTION", "EMPTY_AVAILABILITY", "EMPTY_CONDITION", "EMPTY_DESCRIPTION", "EMPTY_IMAGE_URL", "EMPTY_PRICE", "EMPTY_PRODUCT_URL", "EMPTY_SELLER_DESCRIPTION", "EMPTY_TITLE", "EXTERNAL_MERCHANT_ID_MISMATCH", "GENERIC_INVALID_FIELD", "GROUPS_DISABLED_BY_USER", "HIDDEN_UNTIL_PRODUCT_LAUNCH", "ILLEGAL_PRODUCT_CATEGORY", "IMAGE_FETCH_FAILED", "IMAGE_FETCH_FAILED_BAD_GATEWAY", "IMAGE_FETCH_FAILED_FILE_SIZE_EXCEEDED", "IMAGE_FETCH_FAILED_FORBIDDEN", "IMAGE_FETCH_FAILED_LINK_BROKEN", "IMAGE_FETCH_FAILED_TIMED_OUT", "IMAGE_RESOLUTION_LOW", "INACTIVE_SHOPIFY_PRODUCT", "INVALID_COMMERCE_TAX_CATEGORY", "INVALID_CONSOLIDATED_LOCALITY_INFORMATION", "INVALID_CONTENT_ID", "INVALID_DEALER_COMMUNICATION_PARAMETERS", "INVALID_DMA_CODES", "INVALID_FB_PAGE_ID", "INVALID_IMAGES", "INVALID_MONETIZER_RETURN_POLICY", "INVALID_OFFER_DISCLAIMER_URL", "INVALID_OFFER_END_DATE", "INVALID_PRE_ORDER_PARAMS", "INVALID_RANGE_FOR_AREA_SIZE", "INVALID_RANGE_FOR_BUILT_UP_AREA_SIZE", "INVALID_RANGE_FOR_NUM_OF_BATHS", "INVALID_RANGE_FOR_NUM_OF_BEDS", "INVALID_RANGE_FOR_NUM_OF_ROOMS", "INVALID_RANGE_FOR_PARKING_SPACES", "INVALID_SHELTER_PAGE_ID", "INVALID_SHIPPING_PROFILE_PARAMS", "INVALID_SUBSCRIPTION_DISABLE_PARAMS", "INVALID_SUBSCRIPTION_ENABLE_PARAMS", "INVALID_SUBSCRIPTION_PARAMS", "INVALID_TAX_EXTENSION_STATE", "INVALID_VEHICLE_STATE", "INVALID_VIRTUAL_TOUR_URL_DOMAIN", "INVENTORY_ZERO_AVAILABILITY_IN_STOCK", "IN_ANOTHER_PRODUCT_LAUNCH", "ITEM_GROUP_NOT_SPECIFIED", "ITEM_NOT_SHIPPABLE_FOR_SCA_SHOP", "ITEM_OVERRIDE_EMPTY_AVAILABILITY", "ITEM_OVERRIDE_EMPTY_PRICE", "ITEM_OVERRIDE_NOT_VISIBLE", "ITEM_PRICE_NOT_POSITIVE", "ITEM_STALE_OUT_OF_STOCK", "MARKETPLACE_DISABLED_BY_USER", "MARKETPLACE_PARTNER_AUCTION_NO_BID_CLOSE_TIME", "MARKETPLACE_PARTNER_CURRENCY_NOT_VALID", "MARKETPLACE_PARTNER_LISTING_COUNTRY_NOT_MATCH_CATALOG", "MARKETPLACE_PARTNER_LISTING_LIMIT_EXCEEDED", "MARKETPLACE_PARTNER_MISSING_LATLONG", "MARKETPLACE_PARTNER_MISSING_SHIPPING_COST", "MARKETPLACE_PARTNER_NOT_LOCAL_ITEM", "MARKETPLACE_PARTNER_NOT_SHIPPED_ITEM", "MARKETPLACE_PARTNER_POLICY_VIOLATION", "MARKETPLACE_PARTNER_RULE_LISTING_LIMIT_EXCEEDED", "MARKETPLACE_PARTNER_SELLER_BANNED", "MARKETPLACE_PARTNER_SELLER_NOT_VALID", "MINI_SHOPS_DISABLED_BY_USER", "MISSING_CHECKOUT", "MISSING_CHECKOUT_CURRENCY", "MISSING_COLOR", "MISSING_COUNTRY_OVERRIDE_IN_SHIPPING_PROFILE", "MISSING_EVENT", "MISSING_INDIA_COMPLIANCE_FIELDS", "MISSING_SHIPPING_PROFILE", "MISSING_SIZE", "MISSING_TAX_CATEGORY", "NEGATIVE_COMMUNITY_FEEDBACK", "NEGATIVE_PRICE", "NOT_ENOUGH_IMAGES", "NOT_ENOUGH_UNIQUE_PRODUCTS", "NO_CONTENT_ID", "OVERLAY_DISCLAIMER_EXCEEDED_MAX_LENGTH", "PART_OF_PRODUCT_LAUNCH", "PASSING_MULTIPLE_CONTENT_IDS", "PRODUCT_DOMINANT_CURRENCY_MISMATCH", "PRODUCT_EXPIRED", "PRODUCT_ITEM_HIDDEN_FROM_ALL_SHOPS", "PRODUCT_ITEM_INVALID_PARTNER_TOKENS", "PRODUCT_ITEM_NOT_INCLUDED_IN_ANY_SHOP", "PRODUCT_ITEM_NOT_VISIBLE", "PRODUCT_NOT_APPROVED", "PRODUCT_NOT_DOMINANT_CURRENCY", "PRODUCT_OUT_OF_STOCK", "PRODUCT_URL_EQUALS_DOMAIN", "PROPERTY_PRICE_CURRENCY_NOT_SUPPORTED", "PROPERTY_PRICE_TOO_HIGH", "PROPERTY_PRICE_TOO_LOW", "PROPERTY_UNIT_PRICE_CURRENCY_MISMATCH_ITEM_PRICE_CURRENCY", "PROPERTY_VALUE_CONTAINS_HTML_TAGS", "PROPERTY_VALUE_DESCRIPTION_CONTAINS_OFF_PLATFORM_LINK", "PROPERTY_VALUE_FORMAT", "PROPERTY_VALUE_MISSING", "PROPERTY_VALUE_MISSING_WARNING", "PROPERTY_VALUE_NON_POSITIVE", "PROPERTY_VALUE_STRING_EXCEEDS_LENGTH", "PROPERTY_VALUE_STRING_TOO_SHORT", "PROPERTY_VALUE_UPPERCASE", "PROPERTY_VALUE_UPPERCASE_WARNING", "PURCHASE_RATE_BELOW_ADDTOCART", "PURCHASE_RATE_BELOW_VIEWCONTENT", "QUALITY_DUPLICATED_DESCRIPTION", "QUALITY_ITEM_LINK_BROKEN", "QUALITY_ITEM_LINK_REDIRECTING", "RETAILER_ID_NOT_PROVIDED", "SHOPIFY_INVALID_RETAILER_ID", "SHOPIFY_ITEM_MISSING_SHIPPING_PROFILE", "SHOPS_POLICY_VIOLATION", "SUBSCRIPTION_INFO_NOT_ENABLED_FOR_FEED", "TAX_CATEGORY_NOT_SUPPORTED_IN_UK", "UNIQUE_PRODUCT_IDENTIFIER_MISSING", "UNMATCHED_EVENTS", "UNSUPPORTED_PRODUCT_CATEGORY", "VARIANT_ATTRIBUTE_ISSUE", "VIDEO_FETCH_FAILED", "VIDEO_FETCH_FAILED_BAD_GATEWAY", "VIDEO_FETCH_FAILED_FILE_SIZE_EXCEEDED", "VIDEO_FETCH_FAILED_FORBIDDEN", "VIDEO_FETCH_FAILED_LINK_BROKEN", "VIDEO_FETCH_FAILED_TIMED_OUT", "VIDEO_NOT_DOWNLOADABLE", "WHATSAPP_DISABLED_BY_USER", "WHATSAPP_MARKETING_MESSAGE_DISABLED_BY_USER", "WHATSAPP_MARKETING_MESSAGE_POLICY_VIOLATION", "WHATSAPP_POLICY_VIOLATION" },
				},
				"filter": map[string]any{
					"type": "object",
					"description": "filter parameter",
				},
				"return_only_approved_products": map[string]any{
					"type": "boolean",
					"description": "return_only_approved_products parameter",
				},
			}),
			mcp.Description("Parameters object containing: bulk_pagination (boolean), error_priority (enum) [HIGH, LOW, MEDIUM], error_type (enum) [ADDRESS_BLOCKLISTED_IN_MARKET, AGGREGATED_LOCALIZATION_ISSUES, APP_HAS_NO_AEM_SETUP, AR_DELETED_DUE_TO_UPDATE, AR_POLICY_VIOLATED, ...], filter (object), return_only_approved_products (boolean)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductItem objects. Available fields: additional_image_cdn_urls, additional_image_urls, additional_variant_attributes, age_group, applinks, availability, brand, bundle_items, bundle_retailer_ids, capability_to_review_status, category, category_specific_fields, color, commerce_insights, condition (and 68 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_productsTool)

	// productcatalog_post_products tool
	// Params object accepts: additional_image_urls (list<string>), additional_variant_attributes (map), age_group (productcatalogproducts_age_group_enum_param), android_app_name (string), android_class (string), android_package (string), android_url (string), availability (productcatalogproducts_availability_enum_param), brand (string), category (string), category_specific_fields (map), checkout_url (string), color (string), commerce_tax_category (productcatalogproducts_commerce_tax_category_enum_param), condition (productcatalogproducts_condition_enum_param), currency (string), custom_data (map), custom_label_0 (string), custom_label_1 (string), custom_label_2 (string), custom_label_3 (string), custom_label_4 (string), custom_number_0 (unsigned int), custom_number_1 (unsigned int), custom_number_2 (unsigned int), custom_number_3 (unsigned int), custom_number_4 (unsigned int), description (string), expiration_date (string), fb_product_category (string), gender (productcatalogproducts_gender_enum_param), gtin (string), image_url (string), importer_address (map), importer_name (string), inventory (unsigned int), ios_app_name (string), ios_app_store_id (unsigned int), ios_url (string), ipad_app_name (string), ipad_app_store_id (unsigned int), ipad_url (string), iphone_app_name (string), iphone_app_store_id (unsigned int), iphone_url (string), launch_date (string), manufacturer_info (string), manufacturer_part_number (string), marked_for_product_launch (productcatalogproducts_marked_for_product_launch_enum_param), material (string), mobile_link (string), name (string), ordering_index (unsigned int), origin_country (productcatalogproducts_origin_country_enum_param), pattern (string), price (unsigned int), product_priority_0 (float), product_priority_1 (float), product_priority_2 (float), product_priority_3 (float), product_priority_4 (float), product_type (string), quantity_to_sell_on_facebook (unsigned int), retailer_id (string), retailer_product_group_id (string), return_policy_days (unsigned int), sale_price (unsigned int), sale_price_end_date (datetime), sale_price_start_date (datetime), short_description (string), size (string), start_date (string), url (string), visibility (productcatalogproducts_visibility_enum_param), wa_compliance_category (productcatalogproducts_wa_compliance_category_enum_param), windows_phone_app_id (string), windows_phone_app_name (string), windows_phone_url (string)
	productcatalog_post_productsTool := mcp.NewTool("productcatalog_post_products",
		mcp.WithDescription("POST products for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"additional_image_urls": map[string]any{
					"type": "array",
					"description": "additional_image_urls parameter",
					"items": map[string]any{"type": "string"},
				},
				"additional_variant_attributes": map[string]any{
					"type": "object",
					"description": "additional_variant_attributes parameter",
				},
				"age_group": map[string]any{
					"type": "string",
					"description": "age_group parameter",
					"enum": []string{ "adult", "all ages", "infant", "kids", "newborn", "teen", "toddler" },
				},
				"android_app_name": map[string]any{
					"type": "string",
					"description": "android_app_name parameter",
				},
				"android_class": map[string]any{
					"type": "string",
					"description": "android_class parameter",
				},
				"android_package": map[string]any{
					"type": "string",
					"description": "android_package parameter",
				},
				"android_url": map[string]any{
					"type": "string",
					"description": "android_url parameter",
				},
				"availability": map[string]any{
					"type": "string",
					"description": "availability parameter",
					"enum": []string{ "available for order", "discontinued", "in stock", "mark_as_sold", "out of stock", "pending", "preorder" },
				},
				"brand": map[string]any{
					"type": "string",
					"description": "brand parameter",
				},
				"category": map[string]any{
					"type": "string",
					"description": "category parameter",
				},
				"category_specific_fields": map[string]any{
					"type": "object",
					"description": "category_specific_fields parameter",
				},
				"checkout_url": map[string]any{
					"type": "string",
					"description": "checkout_url parameter",
				},
				"color": map[string]any{
					"type": "string",
					"description": "color parameter",
				},
				"commerce_tax_category": map[string]any{
					"type": "string",
					"description": "commerce_tax_category parameter",
					"enum": []string{ "FB_ANIMAL", "FB_ANIMAL_SUPP", "FB_APRL", "FB_APRL_ACCESSORIES", "FB_APRL_ATHL_UNIF", "FB_APRL_CASES", "FB_APRL_CLOTHING", "FB_APRL_COSTUME", "FB_APRL_CSTM", "FB_APRL_FORMAL", "FB_APRL_HANDBAG", "FB_APRL_JEWELRY", "FB_APRL_SHOE", "FB_APRL_SHOE_ACC", "FB_APRL_SWIM", "FB_APRL_SWIM_CHIL", "FB_APRL_SWIM_CVR", "FB_ARTS", "FB_ARTS_HOBBY", "FB_ARTS_PARTY", "FB_ARTS_PARTY_GIFT_CARD", "FB_ARTS_TICKET", "FB_BABY", "FB_BABY_BATH", "FB_BABY_BLANKET", "FB_BABY_DIAPER", "FB_BABY_GIFT_SET", "FB_BABY_HEALTH", "FB_BABY_NURSING", "FB_BABY_POTTY_TRN", "FB_BABY_SAFE", "FB_BABY_TOYS", "FB_BABY_TRANSPORT", "FB_BABY_TRANSPORT_ACC", "FB_BAGS", "FB_BAGS_BKPK", "FB_BAGS_BOXES", "FB_BAGS_BRFCS", "FB_BAGS_CSMT_BAG", "FB_BAGS_DFFL", "FB_BAGS_DIPR", "FB_BAGS_FNNY", "FB_BAGS_GRMT", "FB_BAGS_LUGG", "FB_BAGS_LUG_ACC", "FB_BAGS_MSGR", "FB_BAGS_TOTE", "FB_BAGS_TRN_CAS", "FB_BLDG", "FB_BLDG_ACC", "FB_BLDG_CNSMB", "FB_BLDG_FENCE", "FB_BLDG_FUEL_TNK", "FB_BLDG_HT_VNT", "FB_BLDG_LOCK", "FB_BLDG_MATRL", "FB_BLDG_PLMB", "FB_BLDG_PUMP", "FB_BLDG_PWRS", "FB_BLDG_STR_TANK", "FB_BLDG_S_ENG", "FB_BLDG_TL_ACC", "FB_BLDG_TOOL", "FB_BUSIND", "FB_BUSIND_ADVERTISING", "FB_BUSIND_AGRICULTURE", "FB_BUSIND_AUTOMATION", "FB_BUSIND_HEAVY_MACH", "FB_BUSIND_LAB", "FB_BUSIND_MEDICAL", "FB_BUSIND_RETAIL", "FB_BUSIND_SANITARY_CT", "FB_BUSIND_SIGN", "FB_BUSIND_STORAGE", "FB_BUSIND_STORAGE_ACC", "FB_BUSIND_WORK_GEAR", "FB_CAMERA_ACC", "FB_CAMERA_CAMERA", "FB_CAMERA_OPTIC", "FB_CAMERA_OPTICS", "FB_CAMERA_PHOTO", "FB_ELEC", "FB_ELEC_ACC", "FB_ELEC_ARCDADE", "FB_ELEC_AUDIO", "FB_ELEC_CIRCUIT", "FB_ELEC_COMM", "FB_ELEC_COMPUTER", "FB_ELEC_GPS_ACC", "FB_ELEC_GPS_NAV", "FB_ELEC_GPS_TRK", "FB_ELEC_MARINE", "FB_ELEC_NETWORK", "FB_ELEC_PART", "FB_ELEC_PRINT", "FB_ELEC_RADAR", "FB_ELEC_SFTWR", "FB_ELEC_SPEED_RDR", "FB_ELEC_TELEVISION", "FB_ELEC_TOLL", "FB_ELEC_VIDEO", "FB_ELEC_VID_GM_ACC", "FB_ELEC_VID_GM_CNSL", "FB_FOOD", "FB_FURN", "FB_FURN_BABY", "FB_FURN_BENCH", "FB_FURN_CART", "FB_FURN_CHAIR", "FB_FURN_CHAIR_ACC", "FB_FURN_DIVIDE", "FB_FURN_DIVIDE_ACC", "FB_FURN_ENT_CTR", "FB_FURN_FUTN", "FB_FURN_FUTN_PAD", "FB_FURN_OFFICE", "FB_FURN_OFFICE_ACC", "FB_FURN_OTTO", "FB_FURN_OUTDOOR", "FB_FURN_OUTDOOR_ACC", "FB_FURN_SETS", "FB_FURN_SHELVE_ACC", "FB_FURN_SHLF", "FB_FURN_SOFA", "FB_FURN_SOFA_ACC", "FB_FURN_STORAGE", "FB_FURN_TABL", "FB_FURN_TABL_ACC", "FB_GENERIC_TAXABLE", "FB_HLTH", "FB_HLTH_HLTH", "FB_HLTH_JWL_CR", "FB_HLTH_LILP_BLM", "FB_HLTH_LTN_SPF", "FB_HLTH_PRSL_CR", "FB_HLTH_SKN_CR", "FB_HMGN", "FB_HMGN_BATH", "FB_HMGN_DCOR", "FB_HMGN_EMGY", "FB_HMGN_FPLC", "FB_HMGN_FPLC_ACC", "FB_HMGN_GS_SFT", "FB_HMGN_HS_ACC", "FB_HMGN_HS_APP", "FB_HMGN_HS_SPL", "FB_HMGN_KTCN", "FB_HMGN_LAWN", "FB_HMGN_LGHT", "FB_HMGN_LINN", "FB_HMGN_LT_ACC", "FB_HMGN_OTDR", "FB_HMGN_POOL", "FB_HMGN_SCTY", "FB_HMGN_SMK_ACC", "FB_HMGN_UMBR", "FB_HMGN_UMBR_ACC", "FB_MDIA", "FB_MDIA_BOOK", "FB_MDIA_DVDS", "FB_MDIA_MAG", "FB_MDIA_MANL", "FB_MDIA_MUSC", "FB_MDIA_PRJ_PLN", "FB_MDIA_SHT_MUS", "FB_OFFC", "FB_OFFC_BKAC", "FB_OFFC_CRTS", "FB_OFFC_DSKP", "FB_OFFC_EQIP", "FB_OFFC_FLNG", "FB_OFFC_GNRL", "FB_OFFC_INSTM", "FB_OFFC_LP_DSK", "FB_OFFC_MATS", "FB_OFFC_NM_PLT", "FB_OFFC_PPR_HNDL", "FB_OFFC_PRSNT_SPL", "FB_OFFC_SEALR", "FB_OFFC_SHIP_SPL", "FB_RLGN", "FB_RLGN_CMNY", "FB_RLGN_ITEM", "FB_RLGN_WEDD", "FB_SFTWR", "FB_SFWR_CMPTR", "FB_SFWR_DGTL_GD", "FB_SFWR_GAME", "FB_SHIPPING", "FB_SPOR", "FB_SPORT_ATHL", "FB_SPORT_ATHL_CLTH", "FB_SPORT_ATHL_SHOE", "FB_SPORT_ATHL_SPRT", "FB_SPORT_EXRCS", "FB_SPORT_INDR_GM", "FB_SPORT_OTDR_GM", "FB_TOYS", "FB_TOYS_EQIP", "FB_TOYS_GAME", "FB_TOYS_PZZL", "FB_TOYS_TMRS", "FB_TOYS_TOYS", "FB_VEHI", "FB_VEHI_PART" },
				},
				"condition": map[string]any{
					"type": "string",
					"description": "condition parameter",
					"enum": []string{ "cpo", "new", "open_box_new", "refurbished", "used", "used_fair", "used_good", "used_like_new" },
				},
				"currency": map[string]any{
					"type": "string",
					"description": "currency parameter",
					"required": true,
				},
				"custom_data": map[string]any{
					"type": "object",
					"description": "custom_data parameter",
				},
				"custom_label_0": map[string]any{
					"type": "string",
					"description": "custom_label_0 parameter",
				},
				"custom_label_1": map[string]any{
					"type": "string",
					"description": "custom_label_1 parameter",
				},
				"custom_label_2": map[string]any{
					"type": "string",
					"description": "custom_label_2 parameter",
				},
				"custom_label_3": map[string]any{
					"type": "string",
					"description": "custom_label_3 parameter",
				},
				"custom_label_4": map[string]any{
					"type": "string",
					"description": "custom_label_4 parameter",
				},
				"custom_number_0": map[string]any{
					"type": "integer",
					"description": "custom_number_0 parameter",
				},
				"custom_number_1": map[string]any{
					"type": "integer",
					"description": "custom_number_1 parameter",
				},
				"custom_number_2": map[string]any{
					"type": "integer",
					"description": "custom_number_2 parameter",
				},
				"custom_number_3": map[string]any{
					"type": "integer",
					"description": "custom_number_3 parameter",
				},
				"custom_number_4": map[string]any{
					"type": "integer",
					"description": "custom_number_4 parameter",
				},
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
				},
				"expiration_date": map[string]any{
					"type": "string",
					"description": "expiration_date parameter",
				},
				"fb_product_category": map[string]any{
					"type": "string",
					"description": "fb_product_category parameter",
				},
				"gender": map[string]any{
					"type": "string",
					"description": "gender parameter",
					"enum": []string{ "female", "male", "unisex" },
				},
				"gtin": map[string]any{
					"type": "string",
					"description": "gtin parameter",
				},
				"image_url": map[string]any{
					"type": "string",
					"description": "image_url parameter",
				},
				"importer_address": map[string]any{
					"type": "object",
					"description": "importer_address parameter",
				},
				"importer_name": map[string]any{
					"type": "string",
					"description": "importer_name parameter",
				},
				"inventory": map[string]any{
					"type": "integer",
					"description": "inventory parameter",
				},
				"ios_app_name": map[string]any{
					"type": "string",
					"description": "ios_app_name parameter",
				},
				"ios_app_store_id": map[string]any{
					"type": "integer",
					"description": "ios_app_store_id parameter",
				},
				"ios_url": map[string]any{
					"type": "string",
					"description": "ios_url parameter",
				},
				"ipad_app_name": map[string]any{
					"type": "string",
					"description": "ipad_app_name parameter",
				},
				"ipad_app_store_id": map[string]any{
					"type": "integer",
					"description": "ipad_app_store_id parameter",
				},
				"ipad_url": map[string]any{
					"type": "string",
					"description": "ipad_url parameter",
				},
				"iphone_app_name": map[string]any{
					"type": "string",
					"description": "iphone_app_name parameter",
				},
				"iphone_app_store_id": map[string]any{
					"type": "integer",
					"description": "iphone_app_store_id parameter",
				},
				"iphone_url": map[string]any{
					"type": "string",
					"description": "iphone_url parameter",
				},
				"launch_date": map[string]any{
					"type": "string",
					"description": "launch_date parameter",
				},
				"manufacturer_info": map[string]any{
					"type": "string",
					"description": "manufacturer_info parameter",
				},
				"manufacturer_part_number": map[string]any{
					"type": "string",
					"description": "manufacturer_part_number parameter",
				},
				"marked_for_product_launch": map[string]any{
					"type": "string",
					"description": "marked_for_product_launch parameter",
					"enum": []string{ "default", "marked", "not_marked" },
				},
				"material": map[string]any{
					"type": "string",
					"description": "material parameter",
				},
				"mobile_link": map[string]any{
					"type": "string",
					"description": "mobile_link parameter",
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
					"required": true,
				},
				"ordering_index": map[string]any{
					"type": "integer",
					"description": "ordering_index parameter",
				},
				"origin_country": map[string]any{
					"type": "string",
					"description": "origin_country parameter",
					"enum": []string{ "AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "XK", "YE", "YT", "ZA", "ZM", "ZW" },
				},
				"pattern": map[string]any{
					"type": "string",
					"description": "pattern parameter",
				},
				"price": map[string]any{
					"type": "integer",
					"description": "price parameter",
					"required": true,
				},
				"product_priority_0": map[string]any{
					"type": "number",
					"description": "product_priority_0 parameter",
				},
				"product_priority_1": map[string]any{
					"type": "number",
					"description": "product_priority_1 parameter",
				},
				"product_priority_2": map[string]any{
					"type": "number",
					"description": "product_priority_2 parameter",
				},
				"product_priority_3": map[string]any{
					"type": "number",
					"description": "product_priority_3 parameter",
				},
				"product_priority_4": map[string]any{
					"type": "number",
					"description": "product_priority_4 parameter",
				},
				"product_type": map[string]any{
					"type": "string",
					"description": "product_type parameter",
				},
				"quantity_to_sell_on_facebook": map[string]any{
					"type": "integer",
					"description": "quantity_to_sell_on_facebook parameter",
				},
				"retailer_id": map[string]any{
					"type": "string",
					"description": "retailer_id parameter",
				},
				"retailer_product_group_id": map[string]any{
					"type": "string",
					"description": "retailer_product_group_id parameter",
				},
				"return_policy_days": map[string]any{
					"type": "integer",
					"description": "return_policy_days parameter",
				},
				"sale_price": map[string]any{
					"type": "integer",
					"description": "sale_price parameter",
				},
				"sale_price_end_date": map[string]any{
					"type": "string",
					"description": "sale_price_end_date parameter",
				},
				"sale_price_start_date": map[string]any{
					"type": "string",
					"description": "sale_price_start_date parameter",
				},
				"short_description": map[string]any{
					"type": "string",
					"description": "short_description parameter",
				},
				"size": map[string]any{
					"type": "string",
					"description": "size parameter",
				},
				"start_date": map[string]any{
					"type": "string",
					"description": "start_date parameter",
				},
				"url": map[string]any{
					"type": "string",
					"description": "url parameter",
				},
				"visibility": map[string]any{
					"type": "string",
					"description": "visibility parameter",
					"enum": []string{ "published", "staging" },
				},
				"wa_compliance_category": map[string]any{
					"type": "string",
					"description": "wa_compliance_category parameter",
					"enum": []string{ "COUNTRY_ORIGIN_EXEMPT", "DEFAULT" },
				},
				"windows_phone_app_id": map[string]any{
					"type": "string",
					"description": "windows_phone_app_id parameter",
				},
				"windows_phone_app_name": map[string]any{
					"type": "string",
					"description": "windows_phone_app_name parameter",
				},
				"windows_phone_url": map[string]any{
					"type": "string",
					"description": "windows_phone_url parameter",
				},
			}),
			mcp.Description("Parameters object containing: additional_image_urls (array<string>), additional_variant_attributes (object), age_group (enum) [adult, all ages, infant, kids, newborn, ...], android_app_name (string), android_class (string), android_package (string), android_url (string), availability (enum) [available for order, discontinued, in stock, mark_as_sold, out of stock, ...], brand (string), category (string), category_specific_fields (object), checkout_url (string), color (string), commerce_tax_category (enum) [FB_ANIMAL, FB_ANIMAL_SUPP, FB_APRL, FB_APRL_ACCESSORIES, FB_APRL_ATHL_UNIF, ...], condition (enum) [cpo, new, open_box_new, refurbished, used, ...], currency (string) [required], custom_data (object), custom_label_0 (string), custom_label_1 (string), custom_label_2 (string), custom_label_3 (string), custom_label_4 (string), custom_number_0 (integer), custom_number_1 (integer), custom_number_2 (integer), custom_number_3 (integer), custom_number_4 (integer), description (string), expiration_date (string), fb_product_category (string), gender (enum) [female, male, unisex], gtin (string), image_url (string), importer_address (object), importer_name (string), inventory (integer), ios_app_name (string), ios_app_store_id (integer), ios_url (string), ipad_app_name (string), ipad_app_store_id (integer), ipad_url (string), iphone_app_name (string), iphone_app_store_id (integer), iphone_url (string), launch_date (string), manufacturer_info (string), manufacturer_part_number (string), marked_for_product_launch (enum) [default, marked, not_marked], material (string), mobile_link (string), name (string) [required], ordering_index (integer), origin_country (enum) [AD, AE, AF, AG, AI, ...], pattern (string), price (integer) [required], product_priority_0 (number), product_priority_1 (number), product_priority_2 (number), product_priority_3 (number), product_priority_4 (number), product_type (string), quantity_to_sell_on_facebook (integer), retailer_id (string), retailer_product_group_id (string), return_policy_days (integer), sale_price (integer), sale_price_end_date (datetime), sale_price_start_date (datetime), short_description (string), size (string), start_date (string), url (string), visibility (enum) [published, staging], wa_compliance_category (enum) [COUNTRY_ORIGIN_EXEMPT, DEFAULT], windows_phone_app_id (string), windows_phone_app_name (string), windows_phone_url (string)"),
		),
	)
	tools = append(tools, productcatalog_post_productsTool)

	// productcatalog_post_update_generated_image_config tool
	// Params object accepts: data (list<Object>)
	productcatalog_post_update_generated_image_configTool := mcp.NewTool("productcatalog_post_update_generated_image_config",
		mcp.WithDescription("POST update_generated_image_config for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"data": map[string]any{
					"type": "array",
					"description": "data parameter",
					"required": true,
					"items": map[string]any{"type": "object"},
				},
			}),
			mcp.Description("Parameters object containing: data (array<object>) [required]"),
		),
	)
	tools = append(tools, productcatalog_post_update_generated_image_configTool)

	// productcatalog_get_vehicle_offers tool
	// Available fields for VehicleOffer: amount_currency, amount_percentage, amount_price, amount_qualifier, applinks, availability, body_style, cashback_currency, cashback_price, category_specific_fields, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3, custom_number_4, dma_codes, downpayment_currency, downpayment_price, downpayment_qualifier, drivetrain, end_date, end_time, exterior_color, fuel_type, generation, id, image_fetch_status, images, interior_color, interior_upholstery, make, model, offer_description, offer_disclaimer, offer_type, price, product_priority_0, product_priority_1, product_priority_2, product_priority_3, product_priority_4, sanitized_images, start_date, start_time, tags, term_length, term_qualifier, title, transmission, trim, unit_price, url, vehicle_offer_id, visibility, year
	// Params object accepts: bulk_pagination (bool), filter (Object)
	productcatalog_get_vehicle_offersTool := mcp.NewTool("productcatalog_get_vehicle_offers",
		mcp.WithDescription("GET vehicle_offers for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"bulk_pagination": map[string]any{
					"type": "boolean",
					"description": "bulk_pagination parameter",
				},
				"filter": map[string]any{
					"type": "object",
					"description": "filter parameter",
				},
			}),
			mcp.Description("Parameters object containing: bulk_pagination (boolean), filter (object)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for VehicleOffer objects. Available fields: amount_currency, amount_percentage, amount_price, amount_qualifier, applinks, availability, body_style, cashback_currency, cashback_price, category_specific_fields, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3 (and 46 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_vehicle_offersTool)

	// productcatalog_get_vehicles tool
	// Available fields for Vehicle: address, applinks, availability, availability_circle_radius, availability_circle_radius_unit, body_style, category_specific_fields, condition, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0, custom_number_1, custom_number_2, custom_number_3, custom_number_4, date_first_on_lot, dealer_communication_channel, dealer_email, dealer_id, dealer_name, dealer_phone, dealer_privacy_policy_url, description, drivetrain, exterior_color, fb_page_id, features, fuel_type, id, image_fetch_status, images, interior_color, legal_disclosure_impressum_url, make, mileage, model, previous_currency, previous_price, price, product_priority_0, product_priority_1, product_priority_2, product_priority_3, product_priority_4, sale_currency, sale_price, sanitized_images, state_of_vehicle, tags, title, transmission, trim, unit_price, url, vehicle_id, vehicle_registration_plate, vehicle_specifications, vehicle_type, vin, visibility, year
	// Params object accepts: bulk_pagination (bool), filter (Object)
	productcatalog_get_vehiclesTool := mcp.NewTool("productcatalog_get_vehicles",
		mcp.WithDescription("GET vehicles for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"bulk_pagination": map[string]any{
					"type": "boolean",
					"description": "bulk_pagination parameter",
				},
				"filter": map[string]any{
					"type": "object",
					"description": "filter parameter",
				},
			}),
			mcp.Description("Parameters object containing: bulk_pagination (boolean), filter (object)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Vehicle objects. Available fields: address, applinks, availability, availability_circle_radius, availability_circle_radius_unit, body_style, category_specific_fields, condition, currency, custom_label_0, custom_label_1, custom_label_2, custom_label_3, custom_label_4, custom_number_0 (and 50 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_vehiclesTool)

	// productcatalog_post_vehicles tool
	// Params object accepts: address (map), applinks (Object), availability (productcatalogvehicles_availability_enum_param), body_style (productcatalogvehicles_body_style_enum_param), condition (productcatalogvehicles_condition_enum_param), currency (string), date_first_on_lot (string), dealer_id (string), dealer_name (string), dealer_phone (string), description (string), drivetrain (productcatalogvehicles_drivetrain_enum_param), exterior_color (string), fb_page_id (string), fuel_type (productcatalogvehicles_fuel_type_enum_param), images (list<Object>), interior_color (string), make (string), mileage (map), model (string), price (unsigned int), state_of_vehicle (productcatalogvehicles_state_of_vehicle_enum_param), title (string), transmission (productcatalogvehicles_transmission_enum_param), trim (string), url (string), vehicle_id (string), vehicle_type (productcatalogvehicles_vehicle_type_enum_param), vin (string), year (unsigned int)
	productcatalog_post_vehiclesTool := mcp.NewTool("productcatalog_post_vehicles",
		mcp.WithDescription("POST vehicles for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"address": map[string]any{
					"type": "object",
					"description": "address parameter",
					"required": true,
				},
				"applinks": map[string]any{
					"type": "object",
					"description": "applinks parameter",
				},
				"availability": map[string]any{
					"type": "string",
					"description": "availability parameter",
					"enum": []string{ "AVAILABLE", "NOT_AVAILABLE", "PENDING", "UNKNOWN" },
				},
				"body_style": map[string]any{
					"type": "string",
					"description": "body_style parameter",
					"required": true,
					"enum": []string{ "CONVERTIBLE", "COUPE", "CROSSOVER", "ESTATE", "GRANDTOURER", "HATCHBACK", "MINIBUS", "MINIVAN", "MPV", "NONE", "OTHER", "PICKUP", "ROADSTER", "SALOON", "SEDAN", "SMALL_CAR", "SPORTSCAR", "SUPERCAR", "SUPERMINI", "SUV", "TRUCK", "VAN", "WAGON" },
				},
				"condition": map[string]any{
					"type": "string",
					"description": "condition parameter",
					"enum": []string{ "EXCELLENT", "FAIR", "GOOD", "NONE", "OTHER", "POOR", "VERY_GOOD" },
				},
				"currency": map[string]any{
					"type": "string",
					"description": "currency parameter",
					"required": true,
				},
				"date_first_on_lot": map[string]any{
					"type": "string",
					"description": "date_first_on_lot parameter",
				},
				"dealer_id": map[string]any{
					"type": "string",
					"description": "dealer_id parameter",
				},
				"dealer_name": map[string]any{
					"type": "string",
					"description": "dealer_name parameter",
				},
				"dealer_phone": map[string]any{
					"type": "string",
					"description": "dealer_phone parameter",
				},
				"description": map[string]any{
					"type": "string",
					"description": "description parameter",
					"required": true,
				},
				"drivetrain": map[string]any{
					"type": "string",
					"description": "drivetrain parameter",
					"enum": []string{ "AWD", "FOUR_WD", "FWD", "NONE", "OTHER", "RWD", "TWO_WD" },
				},
				"exterior_color": map[string]any{
					"type": "string",
					"description": "exterior_color parameter",
					"required": true,
				},
				"fb_page_id": map[string]any{
					"type": "string",
					"description": "fb_page_id parameter",
				},
				"fuel_type": map[string]any{
					"type": "string",
					"description": "fuel_type parameter",
					"enum": []string{ "DIESEL", "ELECTRIC", "FLEX", "GASOLINE", "HYBRID", "NONE", "OTHER", "PETROL", "PLUGIN_HYBRID" },
				},
				"images": map[string]any{
					"type": "array",
					"description": "images parameter",
					"required": true,
					"items": map[string]any{"type": "object"},
				},
				"interior_color": map[string]any{
					"type": "string",
					"description": "interior_color parameter",
				},
				"make": map[string]any{
					"type": "string",
					"description": "make parameter",
					"required": true,
				},
				"mileage": map[string]any{
					"type": "object",
					"description": "mileage parameter",
					"required": true,
				},
				"model": map[string]any{
					"type": "string",
					"description": "model parameter",
					"required": true,
				},
				"price": map[string]any{
					"type": "integer",
					"description": "price parameter",
					"required": true,
				},
				"state_of_vehicle": map[string]any{
					"type": "string",
					"description": "state_of_vehicle parameter",
					"required": true,
					"enum": []string{ "CPO", "NEW", "USED" },
				},
				"title": map[string]any{
					"type": "string",
					"description": "title parameter",
					"required": true,
				},
				"transmission": map[string]any{
					"type": "string",
					"description": "transmission parameter",
					"enum": []string{ "AUTOMATIC", "MANUAL", "NONE", "OTHER" },
				},
				"trim": map[string]any{
					"type": "string",
					"description": "trim parameter",
				},
				"url": map[string]any{
					"type": "string",
					"description": "url parameter",
					"required": true,
				},
				"vehicle_id": map[string]any{
					"type": "string",
					"description": "vehicle_id parameter",
					"required": true,
				},
				"vehicle_type": map[string]any{
					"type": "string",
					"description": "vehicle_type parameter",
					"enum": []string{ "BOAT", "CAR_TRUCK", "COMMERCIAL", "MOTORCYCLE", "OTHER", "POWERSPORT", "RV_CAMPER", "TRAILER" },
				},
				"vin": map[string]any{
					"type": "string",
					"description": "vin parameter",
					"required": true,
				},
				"year": map[string]any{
					"type": "integer",
					"description": "year parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: address (object) [required], applinks (object), availability (enum) [AVAILABLE, NOT_AVAILABLE, PENDING, UNKNOWN], body_style (enum) [CONVERTIBLE, COUPE, CROSSOVER, ESTATE, GRANDTOURER, ...] [required], condition (enum) [EXCELLENT, FAIR, GOOD, NONE, OTHER, ...], currency (string) [required], date_first_on_lot (string), dealer_id (string), dealer_name (string), dealer_phone (string), description (string) [required], drivetrain (enum) [AWD, FOUR_WD, FWD, NONE, OTHER, ...], exterior_color (string) [required], fb_page_id (string), fuel_type (enum) [DIESEL, ELECTRIC, FLEX, GASOLINE, HYBRID, ...], images (array<object>) [required], interior_color (string), make (string) [required], mileage (object) [required], model (string) [required], price (integer) [required], state_of_vehicle (enum) [CPO, NEW, USED] [required], title (string) [required], transmission (enum) [AUTOMATIC, MANUAL, NONE, OTHER], trim (string), url (string) [required], vehicle_id (string) [required], vehicle_type (enum) [BOAT, CAR_TRUCK, COMMERCIAL, MOTORCYCLE, OTHER, ...], vin (string) [required], year (integer) [required]"),
		),
	)
	tools = append(tools, productcatalog_post_vehiclesTool)

	// productcatalog_get_version_configs tool
	// Available fields for CatalogContentVersionConfig: id, name, version
	productcatalog_get_version_configsTool := mcp.NewTool("productcatalog_get_version_configs",
		mcp.WithDescription("GET version_configs for ProductCatalog"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CatalogContentVersionConfig objects. Available fields: id, name, version"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_version_configsTool)

	// productcatalog_post_version_items_batch tool
	// Params object accepts: allow_upsert (bool), item_type (string), item_version (string), requests (map), version (unsigned int)
	productcatalog_post_version_items_batchTool := mcp.NewTool("productcatalog_post_version_items_batch",
		mcp.WithDescription("POST version_items_batch for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"allow_upsert": map[string]any{
					"type": "boolean",
					"description": "allow_upsert parameter",
				},
				"item_type": map[string]any{
					"type": "string",
					"description": "item_type parameter",
					"required": true,
				},
				"item_version": map[string]any{
					"type": "string",
					"description": "item_version parameter",
					"required": true,
				},
				"requests": map[string]any{
					"type": "object",
					"description": "requests parameter",
					"required": true,
				},
				"version": map[string]any{
					"type": "integer",
					"description": "version parameter",
				},
			}),
			mcp.Description("Parameters object containing: allow_upsert (boolean), item_type (string) [required], item_version (string) [required], requests (object) [required], version (integer)"),
		),
	)
	tools = append(tools, productcatalog_post_version_items_batchTool)

	// productcatalog_delete_ tool
	// Params object accepts: allow_delete_catalog_with_live_product_set (bool)
	productcatalog_delete_Tool := mcp.NewTool("productcatalog_delete_",
		mcp.WithDescription("DELETE  for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"allow_delete_catalog_with_live_product_set": map[string]any{
					"type": "boolean",
					"description": "allow_delete_catalog_with_live_product_set parameter",
				},
			}),
			mcp.Description("Parameters object containing: allow_delete_catalog_with_live_product_set (boolean)"),
		),
	)
	tools = append(tools, productcatalog_delete_Tool)

	// productcatalog_get_ tool
	// Available fields for ProductCatalog: ad_account_to_collaborative_ads_share_settings, agency_collaborative_ads_share_settings, business, catalog_store, commerce_merchant_settings, creator_user, da_display_settings, default_image_url, fallback_image_url, feed_count, id, is_catalog_segment, is_local_catalog, name, owner_business, product_count, store_catalog_settings, user_access_expire_time, vertical
	// Params object accepts: segment_use_cases (list<productcatalog_segment_use_cases>)
	productcatalog_get_Tool := mcp.NewTool("productcatalog_get_",
		mcp.WithDescription("GET  for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"segment_use_cases": map[string]any{
					"type": "array",
					"description": "segment_use_cases parameter",
					"enum": []string{ "AFFILIATE_SELLER_STOREFRONT", "AFFILIATE_TAGGED_ONLY_DEPRECATED", "COLLAB_ADS", "COLLAB_ADS_FOR_MARKETPLACE_PARTNER", "COLLAB_ADS_SEGMENT_WITHOUT_SEGMENT_SYNCING", "DIGITAL_CIRCULARS", "FB_LIVE_SHOPPING", "IG_SHOPPING", "IG_SHOPPING_SUGGESTED_PRODUCTS", "MARKETPLACE_SHOPS", "TEST" },
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: segment_use_cases (array<productcatalog_segment_use_cases>) [AFFILIATE_SELLER_STOREFRONT, AFFILIATE_TAGGED_ONLY_DEPRECATED, COLLAB_ADS, COLLAB_ADS_FOR_MARKETPLACE_PARTNER, COLLAB_ADS_SEGMENT_WITHOUT_SEGMENT_SYNCING, ...]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductCatalog objects. Available fields: ad_account_to_collaborative_ads_share_settings, agency_collaborative_ads_share_settings, business, catalog_store, commerce_merchant_settings, creator_user, da_display_settings, default_image_url, fallback_image_url, feed_count, id, is_catalog_segment, is_local_catalog, name, owner_business (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, productcatalog_get_Tool)

	// productcatalog_post_ tool
	// Params object accepts: additional_vertical_option (productcatalog_additional_vertical_option), da_display_settings (Object), default_image_url (string), destination_catalog_settings (map), fallback_image_url (string), flight_catalog_settings (map), name (string), partner_integration (map), store_catalog_settings (map)
	productcatalog_post_Tool := mcp.NewTool("productcatalog_post_",
		mcp.WithDescription("POST  for ProductCatalog"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"additional_vertical_option": map[string]any{
					"type": "string",
					"description": "additional_vertical_option parameter",
					"enum": []string{ "LOCAL_DA_CATALOG", "LOCAL_PRODUCTS" },
				},
				"da_display_settings": map[string]any{
					"type": "object",
					"description": "da_display_settings parameter",
				},
				"default_image_url": map[string]any{
					"type": "string",
					"description": "default_image_url parameter",
				},
				"destination_catalog_settings": map[string]any{
					"type": "object",
					"description": "destination_catalog_settings parameter",
				},
				"fallback_image_url": map[string]any{
					"type": "string",
					"description": "fallback_image_url parameter",
				},
				"flight_catalog_settings": map[string]any{
					"type": "object",
					"description": "flight_catalog_settings parameter",
				},
				"name": map[string]any{
					"type": "string",
					"description": "name parameter",
				},
				"partner_integration": map[string]any{
					"type": "object",
					"description": "partner_integration parameter",
				},
				"store_catalog_settings": map[string]any{
					"type": "object",
					"description": "store_catalog_settings parameter",
				},
			}),
			mcp.Description("Parameters object containing: additional_vertical_option (productcatalog_additional_vertical_option) [LOCAL_DA_CATALOG, LOCAL_PRODUCTS], da_display_settings (object), default_image_url (string), destination_catalog_settings (object), fallback_image_url (string), flight_catalog_settings (object), name (string), partner_integration (object), store_catalog_settings (object)"),
		),
	)
	tools = append(tools, productcatalog_post_Tool)


	return tools
}

// ProductCatalog handlers


// HandleProductcatalog_delete_agencies handles the productcatalog_delete_agencies tool with context-based auth
func HandleProductcatalog_delete_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_delete_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_delete_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_agencies handles the productcatalog_get_agencies tool with context-based auth
func HandleProductcatalog_get_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_agencies handles the productcatalog_post_agencies tool with context-based auth
func HandleProductcatalog_post_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_delete_assigned_users handles the productcatalog_delete_assigned_users tool with context-based auth
func HandleProductcatalog_delete_assigned_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_delete_assigned_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_delete_assigned_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_assigned_users handles the productcatalog_get_assigned_users tool with context-based auth
func HandleProductcatalog_get_assigned_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_assigned_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_assigned_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_assigned_users handles the productcatalog_post_assigned_users tool with context-based auth
func HandleProductcatalog_post_assigned_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_assigned_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_assigned_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_automotive_models handles the productcatalog_get_automotive_models tool with context-based auth
func HandleProductcatalog_get_automotive_models(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_automotive_models(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_automotive_models: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_batch handles the productcatalog_post_batch tool with context-based auth
func HandleProductcatalog_post_batch(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_batch(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_batch: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_catalog_store handles the productcatalog_post_catalog_store tool with context-based auth
func HandleProductcatalog_post_catalog_store(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_catalog_store(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_catalog_store: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_categories handles the productcatalog_get_categories tool with context-based auth
func HandleProductcatalog_get_categories(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_categories(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_categories: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_categories handles the productcatalog_post_categories tool with context-based auth
func HandleProductcatalog_post_categories(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_categories(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_categories: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_check_batch_request_status handles the productcatalog_get_check_batch_request_status tool with context-based auth
func HandleProductcatalog_get_check_batch_request_status(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_check_batch_request_status(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_check_batch_request_status: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_check_marketplace_partner_sellers_status handles the productcatalog_get_check_marketplace_partner_sellers_status tool with context-based auth
func HandleProductcatalog_get_check_marketplace_partner_sellers_status(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_check_marketplace_partner_sellers_status(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_check_marketplace_partner_sellers_status: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_collaborative_ads_lsb_image_bank handles the productcatalog_get_collaborative_ads_lsb_image_bank tool with context-based auth
func HandleProductcatalog_get_collaborative_ads_lsb_image_bank(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_collaborative_ads_lsb_image_bank(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_collaborative_ads_lsb_image_bank: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_collaborative_ads_share_settings handles the productcatalog_get_collaborative_ads_share_settings tool with context-based auth
func HandleProductcatalog_get_collaborative_ads_share_settings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_collaborative_ads_share_settings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_collaborative_ads_share_settings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_cpas_lsb_image_bank handles the productcatalog_post_cpas_lsb_image_bank tool with context-based auth
func HandleProductcatalog_post_cpas_lsb_image_bank(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_cpas_lsb_image_bank(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_cpas_lsb_image_bank: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_creator_asset_creatives handles the productcatalog_get_creator_asset_creatives tool with context-based auth
func HandleProductcatalog_get_creator_asset_creatives(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_creator_asset_creatives(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_creator_asset_creatives: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_data_sources handles the productcatalog_get_data_sources tool with context-based auth
func HandleProductcatalog_get_data_sources(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_data_sources(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_data_sources: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_destinations handles the productcatalog_get_destinations tool with context-based auth
func HandleProductcatalog_get_destinations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_destinations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_destinations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_diagnostics handles the productcatalog_get_diagnostics tool with context-based auth
func HandleProductcatalog_get_diagnostics(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_diagnostics(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_diagnostics: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_event_stats handles the productcatalog_get_event_stats tool with context-based auth
func HandleProductcatalog_get_event_stats(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_event_stats(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_event_stats: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_delete_external_event_sources handles the productcatalog_delete_external_event_sources tool with context-based auth
func HandleProductcatalog_delete_external_event_sources(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Productcatalog_delete_external_event_sources(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_delete_external_event_sources: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_external_event_sources handles the productcatalog_get_external_event_sources tool with context-based auth
func HandleProductcatalog_get_external_event_sources(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_external_event_sources(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_external_event_sources: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_external_event_sources handles the productcatalog_post_external_event_sources tool with context-based auth
func HandleProductcatalog_post_external_event_sources(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Productcatalog_post_external_event_sources(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_external_event_sources: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_flights handles the productcatalog_get_flights tool with context-based auth
func HandleProductcatalog_get_flights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_flights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_flights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_geolocated_items_batch handles the productcatalog_post_geolocated_items_batch tool with context-based auth
func HandleProductcatalog_post_geolocated_items_batch(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_geolocated_items_batch(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_geolocated_items_batch: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_home_listings handles the productcatalog_get_home_listings tool with context-based auth
func HandleProductcatalog_get_home_listings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_home_listings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_home_listings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_home_listings handles the productcatalog_post_home_listings tool with context-based auth
func HandleProductcatalog_post_home_listings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_home_listings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_home_listings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_hotel_rooms_batch handles the productcatalog_get_hotel_rooms_batch tool with context-based auth
func HandleProductcatalog_get_hotel_rooms_batch(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_hotel_rooms_batch(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_hotel_rooms_batch: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_hotel_rooms_batch handles the productcatalog_post_hotel_rooms_batch tool with context-based auth
func HandleProductcatalog_post_hotel_rooms_batch(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_hotel_rooms_batch(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_hotel_rooms_batch: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_hotels handles the productcatalog_get_hotels tool with context-based auth
func HandleProductcatalog_get_hotels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_hotels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_hotels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_hotels handles the productcatalog_post_hotels tool with context-based auth
func HandleProductcatalog_post_hotels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_hotels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_hotels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_items_batch handles the productcatalog_post_items_batch tool with context-based auth
func HandleProductcatalog_post_items_batch(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_items_batch(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_items_batch: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_localized_items_batch handles the productcatalog_post_localized_items_batch tool with context-based auth
func HandleProductcatalog_post_localized_items_batch(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_localized_items_batch(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_localized_items_batch: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_marketplace_partner_sellers_details handles the productcatalog_post_marketplace_partner_sellers_details tool with context-based auth
func HandleProductcatalog_post_marketplace_partner_sellers_details(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_marketplace_partner_sellers_details(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_marketplace_partner_sellers_details: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_marketplace_partner_signals handles the productcatalog_post_marketplace_partner_signals tool with context-based auth
func HandleProductcatalog_post_marketplace_partner_signals(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_marketplace_partner_signals(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_marketplace_partner_signals: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_pricing_variables_batch handles the productcatalog_get_pricing_variables_batch tool with context-based auth
func HandleProductcatalog_get_pricing_variables_batch(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_pricing_variables_batch(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_pricing_variables_batch: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_pricing_variables_batch handles the productcatalog_post_pricing_variables_batch tool with context-based auth
func HandleProductcatalog_post_pricing_variables_batch(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_pricing_variables_batch(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_pricing_variables_batch: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_product_feeds handles the productcatalog_get_product_feeds tool with context-based auth
func HandleProductcatalog_get_product_feeds(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_product_feeds(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_product_feeds: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_product_feeds handles the productcatalog_post_product_feeds tool with context-based auth
func HandleProductcatalog_post_product_feeds(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Productcatalog_post_product_feeds(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_product_feeds: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_product_groups handles the productcatalog_get_product_groups tool with context-based auth
func HandleProductcatalog_get_product_groups(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_product_groups(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_product_groups: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_product_groups handles the productcatalog_post_product_groups tool with context-based auth
func HandleProductcatalog_post_product_groups(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Productcatalog_post_product_groups(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_product_groups: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_product_sets handles the productcatalog_get_product_sets tool with context-based auth
func HandleProductcatalog_get_product_sets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_product_sets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_product_sets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_product_sets handles the productcatalog_post_product_sets tool with context-based auth
func HandleProductcatalog_post_product_sets(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_product_sets(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_product_sets: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_product_sets_batch handles the productcatalog_get_product_sets_batch tool with context-based auth
func HandleProductcatalog_get_product_sets_batch(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_product_sets_batch(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_product_sets_batch: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_products handles the productcatalog_get_products tool with context-based auth
func HandleProductcatalog_get_products(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_products(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_products: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_products handles the productcatalog_post_products tool with context-based auth
func HandleProductcatalog_post_products(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_products(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_products: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_update_generated_image_config handles the productcatalog_post_update_generated_image_config tool with context-based auth
func HandleProductcatalog_post_update_generated_image_config(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_update_generated_image_config(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_update_generated_image_config: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_vehicle_offers handles the productcatalog_get_vehicle_offers tool with context-based auth
func HandleProductcatalog_get_vehicle_offers(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_vehicle_offers(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_vehicle_offers: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_vehicles handles the productcatalog_get_vehicles tool with context-based auth
func HandleProductcatalog_get_vehicles(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_vehicles(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_vehicles: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_vehicles handles the productcatalog_post_vehicles tool with context-based auth
func HandleProductcatalog_post_vehicles(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_vehicles(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_vehicles: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_version_configs handles the productcatalog_get_version_configs tool with context-based auth
func HandleProductcatalog_get_version_configs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_version_configs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_version_configs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_version_items_batch handles the productcatalog_post_version_items_batch tool with context-based auth
func HandleProductcatalog_post_version_items_batch(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Productcatalog_post_version_items_batch(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_version_items_batch: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_delete_ handles the productcatalog_delete_ tool with context-based auth
func HandleProductcatalog_delete_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Productcatalog_delete_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_delete_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_get_ handles the productcatalog_get_ tool with context-based auth
func HandleProductcatalog_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Productcatalog_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleProductcatalog_post_ handles the productcatalog_post_ tool with context-based auth
func HandleProductcatalog_post_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductCatalogClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Productcatalog_post_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productcatalog_post_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

