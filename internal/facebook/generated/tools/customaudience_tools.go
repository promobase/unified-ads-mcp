// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetCustomAudienceTools returns MCP tools for CustomAudience
func GetCustomAudienceTools() []mcp.Tool {
	var tools []mcp.Tool

	// customaudience_delete_adaccounts tool
	// Params object accepts: adaccounts (list<string>)
	customaudience_delete_adaccountsTool := mcp.NewTool("customaudience_delete_adaccounts",
		mcp.WithDescription("DELETE adaccounts for CustomAudience"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"adaccounts": map[string]any{
					"type":        "array",
					"description": "adaccounts parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: adaccounts (array<string>)"),
		),
	)
	tools = append(tools, customaudience_delete_adaccountsTool)

	// customaudience_get_adaccounts tool
	// Available fields for CustomAudienceAdAccount: id
	// Params object accepts: permissions (string)
	customaudience_get_adaccountsTool := mcp.NewTool("customaudience_get_adaccounts",
		mcp.WithDescription("GET adaccounts for CustomAudience"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"permissions": map[string]any{
					"type":        "string",
					"description": "permissions parameter",
				},
			}),
			mcp.Description("Parameters object containing: permissions (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CustomAudienceAdAccount objects. Available fields: id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, customaudience_get_adaccountsTool)

	// customaudience_post_adaccounts tool
	// Params object accepts: adaccounts (list<string>), permissions (string), relationship_type (list<string>), replace (bool)
	customaudience_post_adaccountsTool := mcp.NewTool("customaudience_post_adaccounts",
		mcp.WithDescription("POST adaccounts for CustomAudience"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"adaccounts": map[string]any{
					"type":        "array",
					"description": "adaccounts parameter",
					"items":       map[string]any{"type": "string"},
				},
				"permissions": map[string]any{
					"type":        "string",
					"description": "permissions parameter",
				},
				"relationship_type": map[string]any{
					"type":        "array",
					"description": "relationship_type parameter",
					"items":       map[string]any{"type": "string"},
				},
				"replace": map[string]any{
					"type":        "boolean",
					"description": "replace parameter",
				},
			}),
			mcp.Description("Parameters object containing: adaccounts (array<string>), permissions (string), relationship_type (array<string>), replace (boolean)"),
		),
	)
	tools = append(tools, customaudience_post_adaccountsTool)

	// customaudience_get_ads tool
	// Available fields for Ad: account_id, ad_active_time, ad_review_feedback, ad_schedule_end_time, ad_schedule_start_time, adlabels, adset, adset_id, bid_amount, bid_info, bid_type, campaign, campaign_id, configured_status, conversion_domain, conversion_specs, created_time, creative, creative_asset_groups_spec, demolink_hash, display_sequence, effective_status, engagement_audience, failed_delivery_checks, id, issues_info, last_updated_by_app_id, name, placement, preview_shareable_link, priority, recommendations, source_ad, source_ad_id, status, targeting, tracking_and_conversion_with_defaults, tracking_specs, updated_time
	// Params object accepts: effective_status (list<string>), status (list<string>)
	customaudience_get_adsTool := mcp.NewTool("customaudience_get_ads",
		mcp.WithDescription("GET ads for CustomAudience"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"effective_status": map[string]any{
					"type":        "array",
					"description": "effective_status parameter",
					"items":       map[string]any{"type": "string"},
				},
				"status": map[string]any{
					"type":        "array",
					"description": "status parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: effective_status (array<string>), status (array<string>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Ad objects. Available fields: account_id, ad_active_time, ad_review_feedback, ad_schedule_end_time, ad_schedule_start_time, adlabels, adset, adset_id, bid_amount, bid_info, bid_type, campaign, campaign_id, configured_status, conversion_domain (and 24 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, customaudience_get_adsTool)

	// customaudience_get_health tool
	// Available fields for CustomAudienceHealth: health
	// Params object accepts: calculated_date (string), processed_date (string), value_aggregation_duration (unsigned int), value_country (string), value_currency (string), value_version (unsigned int)
	customaudience_get_healthTool := mcp.NewTool("customaudience_get_health",
		mcp.WithDescription("GET health for CustomAudience"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"calculated_date": map[string]any{
					"type":        "string",
					"description": "calculated_date parameter",
				},
				"processed_date": map[string]any{
					"type":        "string",
					"description": "processed_date parameter",
				},
				"value_aggregation_duration": map[string]any{
					"type":        "integer",
					"description": "value_aggregation_duration parameter",
				},
				"value_country": map[string]any{
					"type":        "string",
					"description": "value_country parameter",
				},
				"value_currency": map[string]any{
					"type":        "string",
					"description": "value_currency parameter",
				},
				"value_version": map[string]any{
					"type":        "integer",
					"description": "value_version parameter",
				},
			}),
			mcp.Description("Parameters object containing: calculated_date (string), processed_date (string), value_aggregation_duration (integer), value_country (string), value_currency (string), value_version (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CustomAudienceHealth objects. Available fields: health"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, customaudience_get_healthTool)

	// customaudience_get_salts tool
	// Available fields for CustomAudienceSalts: app_id, public_key, salts, user_id
	// Params object accepts: params (list<string>)
	customaudience_get_saltsTool := mcp.NewTool("customaudience_get_salts",
		mcp.WithDescription("GET salts for CustomAudience"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"params": map[string]any{
					"type":        "array",
					"description": "params parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: params (array<string>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CustomAudienceSalts objects. Available fields: app_id, public_key, salts, user_id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, customaudience_get_saltsTool)

	// customaudience_post_salts tool
	// Params object accepts: salt (string), valid_from (datetime), valid_to (datetime)
	customaudience_post_saltsTool := mcp.NewTool("customaudience_post_salts",
		mcp.WithDescription("POST salts for CustomAudience"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"salt": map[string]any{
					"type":        "string",
					"description": "salt parameter",
					"required":    true,
				},
				"valid_from": map[string]any{
					"type":        "string",
					"description": "valid_from parameter",
					"required":    true,
				},
				"valid_to": map[string]any{
					"type":        "string",
					"description": "valid_to parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: salt (string) [required], valid_from (datetime) [required], valid_to (datetime) [required]"),
		),
	)
	tools = append(tools, customaudience_post_saltsTool)

	// customaudience_get_sessions tool
	// Available fields for CustomAudienceSession: end_time, num_invalid_entries, num_matched, num_received, progress, session_id, stage, start_time
	// Params object accepts: session_id (unsigned int)
	customaudience_get_sessionsTool := mcp.NewTool("customaudience_get_sessions",
		mcp.WithDescription("GET sessions for CustomAudience"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"session_id": map[string]any{
					"type":        "integer",
					"description": "session_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: session_id (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CustomAudienceSession objects. Available fields: end_time, num_invalid_entries, num_matched, num_received, progress, session_id, stage, start_time"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, customaudience_get_sessionsTool)

	// customaudience_get_shared_account_info tool
	// Available fields for CustomAudiencesharedAccountInfo: account_id, account_name, business_id, business_name, sharing_status
	customaudience_get_shared_account_infoTool := mcp.NewTool("customaudience_get_shared_account_info",
		mcp.WithDescription("GET shared_account_info for CustomAudience"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CustomAudiencesharedAccountInfo objects. Available fields: account_id, account_name, business_id, business_name, sharing_status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, customaudience_get_shared_account_infoTool)

	// customaudience_delete_users tool
	// Params object accepts: namespace (string), payload (Object), session (Object)
	customaudience_delete_usersTool := mcp.NewTool("customaudience_delete_users",
		mcp.WithDescription("DELETE users for CustomAudience"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"namespace": map[string]any{
					"type":        "string",
					"description": "namespace parameter",
				},
				"payload": map[string]any{
					"type":        "object",
					"description": "payload parameter",
				},
				"session": map[string]any{
					"type":        "object",
					"description": "session parameter",
				},
			}),
			mcp.Description("Parameters object containing: namespace (string), payload (object), session (object)"),
		),
	)
	tools = append(tools, customaudience_delete_usersTool)

	// customaudience_post_users tool
	// Params object accepts: namespace (string), payload (Object), session (Object)
	customaudience_post_usersTool := mcp.NewTool("customaudience_post_users",
		mcp.WithDescription("POST users for CustomAudience"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"namespace": map[string]any{
					"type":        "string",
					"description": "namespace parameter",
				},
				"payload": map[string]any{
					"type":        "object",
					"description": "payload parameter",
				},
				"session": map[string]any{
					"type":        "object",
					"description": "session parameter",
				},
			}),
			mcp.Description("Parameters object containing: namespace (string), payload (object), session (object)"),
		),
	)
	tools = append(tools, customaudience_post_usersTool)

	// customaudience_post_usersreplace tool
	// Params object accepts: namespace (string), payload (Object), session (Object)
	customaudience_post_usersreplaceTool := mcp.NewTool("customaudience_post_usersreplace",
		mcp.WithDescription("POST usersreplace for CustomAudience"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"namespace": map[string]any{
					"type":        "string",
					"description": "namespace parameter",
				},
				"payload": map[string]any{
					"type":        "object",
					"description": "payload parameter",
					"required":    true,
				},
				"session": map[string]any{
					"type":        "object",
					"description": "session parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: namespace (string), payload (object) [required], session (object) [required]"),
		),
	)
	tools = append(tools, customaudience_post_usersreplaceTool)

	// customaudience_delete_ tool
	customaudience_delete_Tool := mcp.NewTool("customaudience_delete_",
		mcp.WithDescription("DELETE  for CustomAudience"),
	)
	tools = append(tools, customaudience_delete_Tool)

	// customaudience_get_ tool
	// Available fields for CustomAudience: account_id, approximate_count_lower_bound, approximate_count_upper_bound, customer_file_source, data_source, data_source_types, datafile_custom_audience_uploading_status, delete_time, delivery_status, description, excluded_custom_audiences, external_event_source, household_audience, id, included_custom_audiences, is_eligible_for_sac_campaigns, is_household, is_snapshot, is_value_based, lookalike_audience_ids, lookalike_spec, name, operation_status, opt_out_link, owner_business, page_deletion_marked_delete_time, permission_for_actions, pixel_id, regulated_audience_spec, retention_days, rev_share_policy_id, rule, rule_aggregation, rule_v2, seed_audience, sharing_status, subtype, time_content_updated, time_created, time_updated
	// Params object accepts: ad_account_id (string), special_ad_categories (list<string>), special_ad_category_countries (list<string>), target_countries (list<string>)
	customaudience_get_Tool := mcp.NewTool("customaudience_get_",
		mcp.WithDescription("GET  for CustomAudience"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"ad_account_id": map[string]any{
					"type":        "string",
					"description": "ad_account_id parameter",
				},
				"special_ad_categories": map[string]any{
					"type":        "array",
					"description": "special_ad_categories parameter",
					"items":       map[string]any{"type": "string"},
				},
				"special_ad_category_countries": map[string]any{
					"type":        "array",
					"description": "special_ad_category_countries parameter",
					"items":       map[string]any{"type": "string"},
				},
				"target_countries": map[string]any{
					"type":        "array",
					"description": "target_countries parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: ad_account_id (string), special_ad_categories (array<string>), special_ad_category_countries (array<string>), target_countries (array<string>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for CustomAudience objects. Available fields: account_id, approximate_count_lower_bound, approximate_count_upper_bound, customer_file_source, data_source, data_source_types, datafile_custom_audience_uploading_status, delete_time, delivery_status, description, excluded_custom_audiences, external_event_source, household_audience, id, included_custom_audiences (and 25 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, customaudience_get_Tool)

	// customaudience_post_ tool
	// Params object accepts: allowed_domains (list<string>), claim_objective (customaudience_claim_objective), content_type (customaudience_content_type), countries (string), customer_file_source (customaudience_customer_file_source), description (string), enable_fetch_or_create (bool), event_source_group (string), event_sources (list<map>), exclusions (list<Object>), inclusions (list<Object>), lookalike_spec (string), name (string), opt_out_link (string), parent_audience_id (unsigned int), product_set_id (string), retention_days (unsigned int), rev_share_policy_id (unsigned int), rule (string), rule_aggregation (string), tags (list<string>), use_in_campaigns (bool)
	customaudience_post_Tool := mcp.NewTool("customaudience_post_",
		mcp.WithDescription("POST  for CustomAudience"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"allowed_domains": map[string]any{
					"type":        "array",
					"description": "allowed_domains parameter",
					"items":       map[string]any{"type": "string"},
				},
				"claim_objective": map[string]any{
					"type":        "string",
					"description": "claim_objective parameter",
					"enum":        []string{"AUTOMOTIVE_MODEL", "COLLABORATIVE_ADS", "HOME_LISTING", "MEDIA_TITLE", "PRODUCT", "TRAVEL", "VEHICLE", "VEHICLE_OFFER"},
				},
				"content_type": map[string]any{
					"type":        "string",
					"description": "content_type parameter",
					"enum":        []string{"AUTOMOTIVE_MODEL", "DESTINATION", "FLIGHT", "GENERIC", "HOME_LISTING", "HOTEL", "LOCAL_SERVICE_BUSINESS", "MEDIA_TITLE", "OFFLINE_PRODUCT", "PRODUCT", "VEHICLE", "VEHICLE_OFFER"},
				},
				"countries": map[string]any{
					"type":        "string",
					"description": "countries parameter",
				},
				"customer_file_source": map[string]any{
					"type":        "string",
					"description": "customer_file_source parameter",
					"enum":        []string{"BOTH_USER_AND_PARTNER_PROVIDED", "PARTNER_PROVIDED_ONLY", "USER_PROVIDED_ONLY"},
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"enable_fetch_or_create": map[string]any{
					"type":        "boolean",
					"description": "enable_fetch_or_create parameter",
				},
				"event_source_group": map[string]any{
					"type":        "string",
					"description": "event_source_group parameter",
				},
				"event_sources": map[string]any{
					"type":        "array",
					"description": "event_sources parameter",
					"items":       map[string]any{"type": "object"},
				},
				"exclusions": map[string]any{
					"type":        "array",
					"description": "exclusions parameter",
					"items":       map[string]any{"type": "object"},
				},
				"inclusions": map[string]any{
					"type":        "array",
					"description": "inclusions parameter",
					"items":       map[string]any{"type": "object"},
				},
				"lookalike_spec": map[string]any{
					"type":        "string",
					"description": "lookalike_spec parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"opt_out_link": map[string]any{
					"type":        "string",
					"description": "opt_out_link parameter",
				},
				"parent_audience_id": map[string]any{
					"type":        "integer",
					"description": "parent_audience_id parameter",
				},
				"product_set_id": map[string]any{
					"type":        "string",
					"description": "product_set_id parameter",
				},
				"retention_days": map[string]any{
					"type":        "integer",
					"description": "retention_days parameter",
				},
				"rev_share_policy_id": map[string]any{
					"type":        "integer",
					"description": "rev_share_policy_id parameter",
				},
				"rule": map[string]any{
					"type":        "string",
					"description": "rule parameter",
				},
				"rule_aggregation": map[string]any{
					"type":        "string",
					"description": "rule_aggregation parameter",
				},
				"tags": map[string]any{
					"type":        "array",
					"description": "tags parameter",
					"items":       map[string]any{"type": "string"},
				},
				"use_in_campaigns": map[string]any{
					"type":        "boolean",
					"description": "use_in_campaigns parameter",
				},
			}),
			mcp.Description("Parameters object containing: allowed_domains (array<string>), claim_objective (customaudience_claim_objective) [AUTOMOTIVE_MODEL, COLLABORATIVE_ADS, HOME_LISTING, MEDIA_TITLE, PRODUCT, ...], content_type (customaudience_content_type) [AUTOMOTIVE_MODEL, DESTINATION, FLIGHT, GENERIC, HOME_LISTING, ...], countries (string), customer_file_source (customaudience_customer_file_source) [BOTH_USER_AND_PARTNER_PROVIDED, PARTNER_PROVIDED_ONLY, USER_PROVIDED_ONLY], description (string), enable_fetch_or_create (boolean), event_source_group (string), event_sources (array<object>), exclusions (array<object>), inclusions (array<object>), lookalike_spec (string), name (string), opt_out_link (string), parent_audience_id (integer), product_set_id (string), retention_days (integer), rev_share_policy_id (integer), rule (string), rule_aggregation (string), tags (array<string>), use_in_campaigns (boolean)"),
		),
	)
	tools = append(tools, customaudience_post_Tool)

	return tools
}

// CustomAudience handlers

// HandleCustomaudience_delete_adaccounts handles the customaudience_delete_adaccounts tool with context-based auth
func HandleCustomaudience_delete_adaccounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Customaudience_delete_adaccounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_delete_adaccounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_get_adaccounts handles the customaudience_get_adaccounts tool with context-based auth
func HandleCustomaudience_get_adaccounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Customaudience_get_adaccounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_get_adaccounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_post_adaccounts handles the customaudience_post_adaccounts tool with context-based auth
func HandleCustomaudience_post_adaccounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Customaudience_post_adaccounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_post_adaccounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_get_ads handles the customaudience_get_ads tool with context-based auth
func HandleCustomaudience_get_ads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Customaudience_get_ads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_get_ads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_get_health handles the customaudience_get_health tool with context-based auth
func HandleCustomaudience_get_health(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Customaudience_get_health(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_get_health: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_get_salts handles the customaudience_get_salts tool with context-based auth
func HandleCustomaudience_get_salts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Customaudience_get_salts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_get_salts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_post_salts handles the customaudience_post_salts tool with context-based auth
func HandleCustomaudience_post_salts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Customaudience_post_salts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_post_salts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_get_sessions handles the customaudience_get_sessions tool with context-based auth
func HandleCustomaudience_get_sessions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Customaudience_get_sessions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_get_sessions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_get_shared_account_info handles the customaudience_get_shared_account_info tool with context-based auth
func HandleCustomaudience_get_shared_account_info(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Customaudience_get_shared_account_info(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_get_shared_account_info: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_delete_users handles the customaudience_delete_users tool with context-based auth
func HandleCustomaudience_delete_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Customaudience_delete_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_delete_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_post_users handles the customaudience_post_users tool with context-based auth
func HandleCustomaudience_post_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Customaudience_post_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_post_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_post_usersreplace handles the customaudience_post_usersreplace tool with context-based auth
func HandleCustomaudience_post_usersreplace(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Customaudience_post_usersreplace(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_post_usersreplace: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_delete_ handles the customaudience_delete_ tool with context-based auth
func HandleCustomaudience_delete_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Customaudience_delete_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_delete_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_get_ handles the customaudience_get_ tool with context-based auth
func HandleCustomaudience_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Customaudience_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleCustomaudience_post_ handles the customaudience_post_ tool with context-based auth
func HandleCustomaudience_post_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewCustomAudienceClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Customaudience_post_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute customaudience_post_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}
