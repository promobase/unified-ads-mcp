// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetAlbumTools returns MCP tools for Album
func GetAlbumTools() []mcp.Tool {
	var tools []mcp.Tool

	// album_get_comments tool
	// Available fields for Comment: admin_creator, application, attachment, can_comment, can_hide, can_like, can_remove, can_reply_privately, comment_count, created_time, from, id, is_hidden, is_private, like_count, live_broadcast_timestamp, message, message_tags, object, parent, permalink_url, private_reply_conversation, user_likes
	// Params object accepts: filter (albumcomments_filter_enum_param), live_filter (albumcomments_live_filter_enum_param), order (albumcomments_order_enum_param), since (datetime)
	album_get_commentsTool := mcp.NewTool("album_get_comments",
		mcp.WithDescription("GET comments for Album"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"filter": map[string]any{
					"type":        "string",
					"description": "filter parameter",
					"enum":        []string{"stream", "toplevel"},
				},
				"live_filter": map[string]any{
					"type":        "string",
					"description": "live_filter parameter",
					"enum":        []string{"filter_low_quality", "no_filter"},
				},
				"order": map[string]any{
					"type":        "string",
					"description": "order parameter",
					"enum":        []string{"chronological", "reverse_chronological"},
				},
				"since": map[string]any{
					"type":        "string",
					"description": "since parameter",
				},
			}),
			mcp.Description("Parameters object containing: filter (enum) [stream, toplevel], live_filter (enum) [filter_low_quality, no_filter], order (enum) [chronological, reverse_chronological], since (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Comment objects. Available fields: admin_creator, application, attachment, can_comment, can_hide, can_like, can_remove, can_reply_privately, comment_count, created_time, from, id, is_hidden, is_private, like_count (and 8 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, album_get_commentsTool)

	// album_post_comments tool
	// Params object accepts: attachment_id (string), attachment_share_url (string), attachment_url (string), comment_privacy_value (albumcomments_comment_privacy_value_enum_param), facepile_mentioned_ids (list<string>), feedback_source (string), is_offline (bool), message (string), nectar_module (string), object_id (string), parent_comment_id (Object), text (string), tracking (string)
	album_post_commentsTool := mcp.NewTool("album_post_comments",
		mcp.WithDescription("POST comments for Album"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"attachment_id": map[string]any{
					"type":        "string",
					"description": "attachment_id parameter",
				},
				"attachment_share_url": map[string]any{
					"type":        "string",
					"description": "attachment_share_url parameter",
				},
				"attachment_url": map[string]any{
					"type":        "string",
					"description": "attachment_url parameter",
				},
				"comment_privacy_value": map[string]any{
					"type":        "string",
					"description": "comment_privacy_value parameter",
					"enum":        []string{"DECLINED_BY_ADMIN_ASSISTANT", "DEFAULT_PRIVACY", "FRIENDS_AND_POST_OWNER", "FRIENDS_ONLY", "GRAPHQL_MULTIPLE_VALUE_HACK_DO_NOT_USE", "OWNER_OR_COMMENTER", "PENDING_APPROVAL", "REMOVED_BY_ADMIN_ASSISTANT", "SIDE_CONVERSATION", "SIDE_CONVERSATION_AND_POST_OWNER", "SPOTLIGHT_TAB"},
				},
				"facepile_mentioned_ids": map[string]any{
					"type":        "array",
					"description": "facepile_mentioned_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"feedback_source": map[string]any{
					"type":        "string",
					"description": "feedback_source parameter",
				},
				"is_offline": map[string]any{
					"type":        "boolean",
					"description": "is_offline parameter",
				},
				"message": map[string]any{
					"type":        "string",
					"description": "message parameter",
				},
				"nectar_module": map[string]any{
					"type":        "string",
					"description": "nectar_module parameter",
				},
				"object_id": map[string]any{
					"type":        "string",
					"description": "object_id parameter",
				},
				"parent_comment_id": map[string]any{
					"type":        "object",
					"description": "parent_comment_id parameter",
				},
				"text": map[string]any{
					"type":        "string",
					"description": "text parameter",
				},
				"tracking": map[string]any{
					"type":        "string",
					"description": "tracking parameter",
				},
			}),
			mcp.Description("Parameters object containing: attachment_id (string), attachment_share_url (string), attachment_url (string), comment_privacy_value (enum) [DECLINED_BY_ADMIN_ASSISTANT, DEFAULT_PRIVACY, FRIENDS_AND_POST_OWNER, FRIENDS_ONLY, GRAPHQL_MULTIPLE_VALUE_HACK_DO_NOT_USE, ...], facepile_mentioned_ids (array<string>), feedback_source (string), is_offline (boolean), message (string), nectar_module (string), object_id (string), parent_comment_id (object), text (string), tracking (string)"),
		),
	)
	tools = append(tools, album_post_commentsTool)

	// album_get_likes tool
	// Available fields for Profile: can_post, id, link, name, pic, pic_crop, pic_large, pic_small, pic_square, profile_type, username
	album_get_likesTool := mcp.NewTool("album_get_likes",
		mcp.WithDescription("GET likes for Album"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Profile objects. Available fields: can_post, id, link, name, pic, pic_crop, pic_large, pic_small, pic_square, profile_type, username"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, album_get_likesTool)

	// album_post_likes tool
	// Params object accepts: feedback_source (string), nectar_module (string), notify (bool), tracking (string)
	album_post_likesTool := mcp.NewTool("album_post_likes",
		mcp.WithDescription("POST likes for Album"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"feedback_source": map[string]any{
					"type":        "string",
					"description": "feedback_source parameter",
				},
				"nectar_module": map[string]any{
					"type":        "string",
					"description": "nectar_module parameter",
				},
				"notify": map[string]any{
					"type":        "boolean",
					"description": "notify parameter",
				},
				"tracking": map[string]any{
					"type":        "string",
					"description": "tracking parameter",
				},
			}),
			mcp.Description("Parameters object containing: feedback_source (string), nectar_module (string), notify (boolean), tracking (string)"),
		),
	)
	tools = append(tools, album_post_likesTool)

	// album_get_photos tool
	// Available fields for Photo: album, alt_text, alt_text_custom, backdated_time, backdated_time_granularity, can_backdate, can_delete, can_tag, created_time, event, from, height, icon, id, images, link, name, name_tags, page_story_id, picture, place, position, source, target, updated_time, webp_images, width
	album_get_photosTool := mcp.NewTool("album_get_photos",
		mcp.WithDescription("GET photos for Album"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Photo objects. Available fields: album, alt_text, alt_text_custom, backdated_time, backdated_time_granularity, can_backdate, can_delete, can_tag, created_time, event, from, height, icon, id, images (and 12 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, album_get_photosTool)

	// album_post_photos tool
	// Params object accepts: aid (string), allow_spherical_photo (bool), alt_text_custom (string), android_key_hash (string), application_id (string), attempt (unsigned int), audience_exp (bool), backdated_time (datetime), backdated_time_granularity (albumphotos_backdated_time_granularity_enum_param), caption (string), composer_session_id (string), direct_share_status (unsigned int), feed_targeting (Object), filter_type (unsigned int), full_res_is_coming_later (bool), initial_view_heading_override_degrees (unsigned int), initial_view_pitch_override_degrees (unsigned int), initial_view_vertical_fov_override_degrees (unsigned int), ios_bundle_id (string), is_explicit_location (bool), is_explicit_place (bool), manual_privacy (bool), message (string), name (string), no_story (bool), offline_id (unsigned int), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_set_profile_badge (bool), og_suggestion_mechanism (string), place (Object), privacy (string), profile_id (int), provenance_info (map), proxied_app_id (string), published (bool), qn (string), spherical_metadata (map), sponsor_id (string), sponsor_relationship (unsigned int), tags (list<Object>), target_id (int), targeting (Object), time_since_original_post (unsigned int), uid (int), unpublished_content_type (albumphotos_unpublished_content_type_enum_param), url (string), user_selected_tags (bool), vault_image_id (string)
	album_post_photosTool := mcp.NewTool("album_post_photos",
		mcp.WithDescription("POST photos for Album"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"aid": map[string]any{
					"type":        "string",
					"description": "aid parameter",
				},
				"allow_spherical_photo": map[string]any{
					"type":        "boolean",
					"description": "allow_spherical_photo parameter",
				},
				"alt_text_custom": map[string]any{
					"type":        "string",
					"description": "alt_text_custom parameter",
				},
				"android_key_hash": map[string]any{
					"type":        "string",
					"description": "android_key_hash parameter",
				},
				"application_id": map[string]any{
					"type":        "string",
					"description": "application_id parameter",
				},
				"attempt": map[string]any{
					"type":        "integer",
					"description": "attempt parameter",
				},
				"audience_exp": map[string]any{
					"type":        "boolean",
					"description": "audience_exp parameter",
				},
				"backdated_time": map[string]any{
					"type":        "string",
					"description": "backdated_time parameter",
				},
				"backdated_time_granularity": map[string]any{
					"type":        "string",
					"description": "backdated_time_granularity parameter",
					"enum":        []string{"day", "hour", "min", "month", "none", "year"},
				},
				"caption": map[string]any{
					"type":        "string",
					"description": "caption parameter",
				},
				"composer_session_id": map[string]any{
					"type":        "string",
					"description": "composer_session_id parameter",
				},
				"direct_share_status": map[string]any{
					"type":        "integer",
					"description": "direct_share_status parameter",
				},
				"feed_targeting": map[string]any{
					"type":        "object",
					"description": "feed_targeting parameter",
				},
				"filter_type": map[string]any{
					"type":        "integer",
					"description": "filter_type parameter",
				},
				"full_res_is_coming_later": map[string]any{
					"type":        "boolean",
					"description": "full_res_is_coming_later parameter",
				},
				"initial_view_heading_override_degrees": map[string]any{
					"type":        "integer",
					"description": "initial_view_heading_override_degrees parameter",
				},
				"initial_view_pitch_override_degrees": map[string]any{
					"type":        "integer",
					"description": "initial_view_pitch_override_degrees parameter",
				},
				"initial_view_vertical_fov_override_degrees": map[string]any{
					"type":        "integer",
					"description": "initial_view_vertical_fov_override_degrees parameter",
				},
				"ios_bundle_id": map[string]any{
					"type":        "string",
					"description": "ios_bundle_id parameter",
				},
				"is_explicit_location": map[string]any{
					"type":        "boolean",
					"description": "is_explicit_location parameter",
				},
				"is_explicit_place": map[string]any{
					"type":        "boolean",
					"description": "is_explicit_place parameter",
				},
				"manual_privacy": map[string]any{
					"type":        "boolean",
					"description": "manual_privacy parameter",
				},
				"message": map[string]any{
					"type":        "string",
					"description": "message parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"no_story": map[string]any{
					"type":        "boolean",
					"description": "no_story parameter",
				},
				"offline_id": map[string]any{
					"type":        "integer",
					"description": "offline_id parameter",
				},
				"og_action_type_id": map[string]any{
					"type":        "string",
					"description": "og_action_type_id parameter",
				},
				"og_icon_id": map[string]any{
					"type":        "string",
					"description": "og_icon_id parameter",
				},
				"og_object_id": map[string]any{
					"type":        "string",
					"description": "og_object_id parameter",
				},
				"og_phrase": map[string]any{
					"type":        "string",
					"description": "og_phrase parameter",
				},
				"og_set_profile_badge": map[string]any{
					"type":        "boolean",
					"description": "og_set_profile_badge parameter",
				},
				"og_suggestion_mechanism": map[string]any{
					"type":        "string",
					"description": "og_suggestion_mechanism parameter",
				},
				"place": map[string]any{
					"type":        "object",
					"description": "place parameter",
				},
				"privacy": map[string]any{
					"type":        "string",
					"description": "privacy parameter",
				},
				"profile_id": map[string]any{
					"type":        "integer",
					"description": "profile_id parameter",
				},
				"provenance_info": map[string]any{
					"type":        "object",
					"description": "provenance_info parameter",
				},
				"proxied_app_id": map[string]any{
					"type":        "string",
					"description": "proxied_app_id parameter",
				},
				"published": map[string]any{
					"type":        "boolean",
					"description": "published parameter",
				},
				"qn": map[string]any{
					"type":        "string",
					"description": "qn parameter",
				},
				"spherical_metadata": map[string]any{
					"type":        "object",
					"description": "spherical_metadata parameter",
				},
				"sponsor_id": map[string]any{
					"type":        "string",
					"description": "sponsor_id parameter",
				},
				"sponsor_relationship": map[string]any{
					"type":        "integer",
					"description": "sponsor_relationship parameter",
				},
				"tags": map[string]any{
					"type":        "array",
					"description": "tags parameter",
					"items":       map[string]any{"type": "object"},
				},
				"target_id": map[string]any{
					"type":        "integer",
					"description": "target_id parameter",
				},
				"targeting": map[string]any{
					"type":        "object",
					"description": "targeting parameter",
				},
				"time_since_original_post": map[string]any{
					"type":        "integer",
					"description": "time_since_original_post parameter",
				},
				"uid": map[string]any{
					"type":        "integer",
					"description": "uid parameter",
				},
				"unpublished_content_type": map[string]any{
					"type":        "string",
					"description": "unpublished_content_type parameter",
					"enum":        []string{"ADS_POST", "DRAFT", "INLINE_CREATED", "PUBLISHED", "REVIEWABLE_BRANDED_CONTENT", "SCHEDULED", "SCHEDULED_RECURRING"},
				},
				"url": map[string]any{
					"type":        "string",
					"description": "url parameter",
				},
				"user_selected_tags": map[string]any{
					"type":        "boolean",
					"description": "user_selected_tags parameter",
				},
				"vault_image_id": map[string]any{
					"type":        "string",
					"description": "vault_image_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: aid (string), allow_spherical_photo (boolean), alt_text_custom (string), android_key_hash (string), application_id (string), attempt (integer), audience_exp (boolean), backdated_time (datetime), backdated_time_granularity (enum) [day, hour, min, month, none, ...], caption (string), composer_session_id (string), direct_share_status (integer), feed_targeting (object), filter_type (integer), full_res_is_coming_later (boolean), initial_view_heading_override_degrees (integer), initial_view_pitch_override_degrees (integer), initial_view_vertical_fov_override_degrees (integer), ios_bundle_id (string), is_explicit_location (boolean), is_explicit_place (boolean), manual_privacy (boolean), message (string), name (string), no_story (boolean), offline_id (integer), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_set_profile_badge (boolean), og_suggestion_mechanism (string), place (object), privacy (string), profile_id (integer), provenance_info (object), proxied_app_id (string), published (boolean), qn (string), spherical_metadata (object), sponsor_id (string), sponsor_relationship (integer), tags (array<object>), target_id (integer), targeting (object), time_since_original_post (integer), uid (integer), unpublished_content_type (enum) [ADS_POST, DRAFT, INLINE_CREATED, PUBLISHED, REVIEWABLE_BRANDED_CONTENT, ...], url (string), user_selected_tags (boolean), vault_image_id (string)"),
		),
	)
	tools = append(tools, album_post_photosTool)

	// album_get_picture tool
	// Available fields for ProfilePictureSource: bottom, cache_key, height, is_silhouette, left, right, top, url, width
	// Params object accepts: redirect (bool), type (albumpicture_type_enum_param)
	album_get_pictureTool := mcp.NewTool("album_get_picture",
		mcp.WithDescription("GET picture for Album"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"redirect": map[string]any{
					"type":        "boolean",
					"description": "redirect parameter",
				},
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"album", "small", "thumbnail"},
				},
			}),
			mcp.Description("Parameters object containing: redirect (boolean), type (enum) [album, small, thumbnail]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProfilePictureSource objects. Available fields: bottom, cache_key, height, is_silhouette, left, right, top, url, width"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, album_get_pictureTool)

	// album_get_ tool
	// Available fields for Album: backdated_time, backdated_time_granularity, can_backdate, can_upload, count, cover_photo, created_time, description, edit_link, event, from, id, is_user_facing, link, location, modified_major, name, photo_count, place, privacy, type, updated_time, video_count
	album_get_Tool := mcp.NewTool("album_get_",
		mcp.WithDescription("GET  for Album"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Album objects. Available fields: backdated_time, backdated_time_granularity, can_backdate, can_upload, count, cover_photo, created_time, description, edit_link, event, from, id, is_user_facing, link, location (and 8 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, album_get_Tool)

	return tools
}

// Album handlers

// HandleAlbum_get_comments handles the album_get_comments tool with context-based auth
func HandleAlbum_get_comments(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAlbumClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Album_get_comments(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute album_get_comments: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAlbum_post_comments handles the album_post_comments tool with context-based auth
func HandleAlbum_post_comments(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAlbumClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Album_post_comments(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute album_post_comments: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAlbum_get_likes handles the album_get_likes tool with context-based auth
func HandleAlbum_get_likes(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAlbumClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Album_get_likes(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute album_get_likes: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAlbum_post_likes handles the album_post_likes tool with context-based auth
func HandleAlbum_post_likes(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAlbumClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Album_post_likes(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute album_post_likes: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAlbum_get_photos handles the album_get_photos tool with context-based auth
func HandleAlbum_get_photos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAlbumClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Album_get_photos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute album_get_photos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAlbum_post_photos handles the album_post_photos tool with context-based auth
func HandleAlbum_post_photos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAlbumClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Album_post_photos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute album_post_photos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAlbum_get_picture handles the album_get_picture tool with context-based auth
func HandleAlbum_get_picture(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAlbumClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Album_get_picture(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute album_get_picture: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAlbum_get_ handles the album_get_ tool with context-based auth
func HandleAlbum_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAlbumClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Album_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute album_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}
