// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetUserTools returns MCP tools for User
func GetUserTools() []mcp.Tool {
	var tools []mcp.Tool

	// user_delete_access_tokens tool
	user_delete_access_tokensTool := mcp.NewTool("user_delete_access_tokens",
		mcp.WithDescription("DELETE access_tokens for User"),
	)
	tools = append(tools, user_delete_access_tokensTool)

	// user_post_access_tokens tool
	// Params object accepts: business_app (string), page_id (string), scope (list<string>), set_token_expires_in_60_days (bool)
	user_post_access_tokensTool := mcp.NewTool("user_post_access_tokens",
		mcp.WithDescription("POST access_tokens for User"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business_app": map[string]any{
					"type":        "string",
					"description": "business_app parameter",
					"required":    true,
				},
				"page_id": map[string]any{
					"type":        "string",
					"description": "page_id parameter",
				},
				"scope": map[string]any{
					"type":        "array",
					"description": "scope parameter",
					"items":       map[string]any{"type": "string"},
				},
				"set_token_expires_in_60_days": map[string]any{
					"type":        "boolean",
					"description": "set_token_expires_in_60_days parameter",
				},
			}),
			mcp.Description("Parameters object containing: business_app (string) [required], page_id (string), scope (array<string>), set_token_expires_in_60_days (boolean)"),
		),
	)
	tools = append(tools, user_post_access_tokensTool)

	// user_get_accounts tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	// Params object accepts: ad_id (string), is_place (bool), is_promotable (bool)
	user_get_accountsTool := mcp.NewTool("user_get_accounts",
		mcp.WithDescription("GET accounts for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"ad_id": map[string]any{
					"type":        "string",
					"description": "ad_id parameter",
				},
				"is_place": map[string]any{
					"type":        "boolean",
					"description": "is_place parameter",
				},
				"is_promotable": map[string]any{
					"type":        "boolean",
					"description": "is_promotable parameter",
				},
			}),
			mcp.Description("Parameters object containing: ad_id (string), is_place (boolean), is_promotable (boolean)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_accountsTool)

	// user_post_accounts tool
	// Params object accepts: about (string), address (string), category (int), category_enum (string), category_list (list<string>), city_id (string), coordinates (Object), cover_photo (Object), description (string), ignore_coordinate_warnings (bool), location (Object), name (string), phone (string), picture (string), website (string), zip (string)
	user_post_accountsTool := mcp.NewTool("user_post_accounts",
		mcp.WithDescription("POST accounts for User"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"about": map[string]any{
					"type":        "string",
					"description": "about parameter",
				},
				"address": map[string]any{
					"type":        "string",
					"description": "address parameter",
				},
				"category": map[string]any{
					"type":        "integer",
					"description": "category parameter",
				},
				"category_enum": map[string]any{
					"type":        "string",
					"description": "category_enum parameter",
				},
				"category_list": map[string]any{
					"type":        "array",
					"description": "category_list parameter",
					"items":       map[string]any{"type": "string"},
				},
				"city_id": map[string]any{
					"type":        "string",
					"description": "city_id parameter",
				},
				"coordinates": map[string]any{
					"type":        "object",
					"description": "coordinates parameter",
				},
				"cover_photo": map[string]any{
					"type":        "object",
					"description": "cover_photo parameter",
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"ignore_coordinate_warnings": map[string]any{
					"type":        "boolean",
					"description": "ignore_coordinate_warnings parameter",
				},
				"location": map[string]any{
					"type":        "object",
					"description": "location parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"phone": map[string]any{
					"type":        "string",
					"description": "phone parameter",
				},
				"picture": map[string]any{
					"type":        "string",
					"description": "picture parameter",
				},
				"website": map[string]any{
					"type":        "string",
					"description": "website parameter",
				},
				"zip": map[string]any{
					"type":        "string",
					"description": "zip parameter",
				},
			}),
			mcp.Description("Parameters object containing: about (string), address (string), category (integer), category_enum (string), category_list (array<string>), city_id (string), coordinates (object), cover_photo (object), description (string), ignore_coordinate_warnings (boolean), location (object), name (string) [required], phone (string), picture (string), website (string), zip (string)"),
		),
	)
	tools = append(tools, user_post_accountsTool)

	// user_get_ad_studies tool
	// Available fields for AdStudy: business, canceled_time, client_business, cooldown_start_time, created_by, created_time, description, end_time, id, measurement_contact, name, observation_end_time, results_first_available_date, sales_contact, start_time, type, updated_by, updated_time
	user_get_ad_studiesTool := mcp.NewTool("user_get_ad_studies",
		mcp.WithDescription("GET ad_studies for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdStudy objects. Available fields: business, canceled_time, client_business, cooldown_start_time, created_by, created_time, description, end_time, id, measurement_contact, name, observation_end_time, results_first_available_date, sales_contact, start_time (and 3 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_ad_studiesTool)

	// user_post_ad_studies tool
	// Params object accepts: cells (list<Object>), client_business (string), confidence_level (float), cooldown_start_time (int), description (string), end_time (int), name (string), objectives (list<Object>), observation_end_time (int), start_time (int), type (userad_studies_type_enum_param), viewers (list<int>)
	user_post_ad_studiesTool := mcp.NewTool("user_post_ad_studies",
		mcp.WithDescription("POST ad_studies for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"cells": map[string]any{
					"type":        "array",
					"description": "cells parameter",
					"items":       map[string]any{"type": "object"},
				},
				"client_business": map[string]any{
					"type":        "string",
					"description": "client_business parameter",
				},
				"confidence_level": map[string]any{
					"type":        "number",
					"description": "confidence_level parameter",
				},
				"cooldown_start_time": map[string]any{
					"type":        "integer",
					"description": "cooldown_start_time parameter",
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"end_time": map[string]any{
					"type":        "integer",
					"description": "end_time parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"objectives": map[string]any{
					"type":        "array",
					"description": "objectives parameter",
					"items":       map[string]any{"type": "object"},
				},
				"observation_end_time": map[string]any{
					"type":        "integer",
					"description": "observation_end_time parameter",
				},
				"start_time": map[string]any{
					"type":        "integer",
					"description": "start_time parameter",
				},
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"BACKEND_AB_TESTING", "CONTINUOUS_LIFT_CONFIG", "GEO_LIFT", "LIFT", "SPLIT_TEST"},
				},
				"viewers": map[string]any{
					"type":        "array",
					"description": "viewers parameter",
					"items":       map[string]any{"type": "integer"},
				},
			}),
			mcp.Description("Parameters object containing: cells (array<object>), client_business (string), confidence_level (number), cooldown_start_time (integer), description (string), end_time (integer), name (string), objectives (array<object>), observation_end_time (integer), start_time (integer), type (enum) [BACKEND_AB_TESTING, CONTINUOUS_LIFT_CONFIG, GEO_LIFT, LIFT, SPLIT_TEST], viewers (array<integer>)"),
		),
	)
	tools = append(tools, user_post_ad_studiesTool)

	// user_get_adaccounts tool
	// Available fields for AdAccount: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state, business_street, business_street2, business_zip, can_create_brand_lift_study, capabilities, created_time, currency, custom_audience_info, default_dsa_beneficiary, default_dsa_payor, disable_reason, end_advertiser, end_advertiser_name, existing_customers, expired_funding_source_details, extended_credit_invoice_group, failed_delivery_checks, fb_entity, funding_source, funding_source_details, has_migrated_permissions, has_page_authorized_adaccount, id, io_number, is_attribution_spec_system_default, is_ba_skip_delayed_eligible, is_direct_deals_enabled, is_in_3ds_authorization_enabled_market, is_notifications_enabled, is_personal, is_prepay_account, is_tax_id_required, liable_address, line_numbers, media_agency, min_campaign_group_spend_cap, min_daily_budget, name, offsite_pixels_tos_accepted, owner, owner_business, partner, rf_spec, send_bill_to_address, show_checkout_experience, sold_to_address, spend_cap, tax_id, tax_id_status, tax_id_type, timezone_id, timezone_name, timezone_offset_hours_utc, tos_accepted, user_access_expire_time, user_tasks, user_tos_accepted, viewable_business
	user_get_adaccountsTool := mcp.NewTool("user_get_adaccounts",
		mcp.WithDescription("GET adaccounts for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccount objects. Available fields: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state (and 58 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_adaccountsTool)

	// user_get_albums tool
	// Available fields for Album: backdated_time, backdated_time_granularity, can_backdate, can_upload, count, cover_photo, created_time, description, edit_link, event, from, id, is_user_facing, link, location, modified_major, name, photo_count, place, privacy, type, updated_time, video_count
	user_get_albumsTool := mcp.NewTool("user_get_albums",
		mcp.WithDescription("GET albums for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Album objects. Available fields: backdated_time, backdated_time_granularity, can_backdate, can_upload, count, cover_photo, created_time, description, edit_link, event, from, id, is_user_facing, link, location (and 8 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_albumsTool)

	// user_post_applications tool
	// Params object accepts: business_app (int)
	user_post_applicationsTool := mcp.NewTool("user_post_applications",
		mcp.WithDescription("POST applications for User"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business_app": map[string]any{
					"type":        "integer",
					"description": "business_app parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: business_app (integer) [required]"),
		),
	)
	tools = append(tools, user_post_applicationsTool)

	// user_get_apprequestformerrecipients tool
	// Available fields for AppRequestFormerRecipient: id, recipient_id
	user_get_apprequestformerrecipientsTool := mcp.NewTool("user_get_apprequestformerrecipients",
		mcp.WithDescription("GET apprequestformerrecipients for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AppRequestFormerRecipient objects. Available fields: id, recipient_id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_apprequestformerrecipientsTool)

	// user_get_apprequests tool
	// Available fields for AppRequest: action_type, application, created_time, data, from, id, message, object, to
	user_get_apprequestsTool := mcp.NewTool("user_get_apprequests",
		mcp.WithDescription("GET apprequests for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AppRequest objects. Available fields: action_type, application, created_time, data, from, id, message, object, to"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_apprequestsTool)

	// user_get_assigned_ad_accounts tool
	// Available fields for AdAccount: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state, business_street, business_street2, business_zip, can_create_brand_lift_study, capabilities, created_time, currency, custom_audience_info, default_dsa_beneficiary, default_dsa_payor, disable_reason, end_advertiser, end_advertiser_name, existing_customers, expired_funding_source_details, extended_credit_invoice_group, failed_delivery_checks, fb_entity, funding_source, funding_source_details, has_migrated_permissions, has_page_authorized_adaccount, id, io_number, is_attribution_spec_system_default, is_ba_skip_delayed_eligible, is_direct_deals_enabled, is_in_3ds_authorization_enabled_market, is_notifications_enabled, is_personal, is_prepay_account, is_tax_id_required, liable_address, line_numbers, media_agency, min_campaign_group_spend_cap, min_daily_budget, name, offsite_pixels_tos_accepted, owner, owner_business, partner, rf_spec, send_bill_to_address, show_checkout_experience, sold_to_address, spend_cap, tax_id, tax_id_status, tax_id_type, timezone_id, timezone_name, timezone_offset_hours_utc, tos_accepted, user_access_expire_time, user_tasks, user_tos_accepted, viewable_business
	user_get_assigned_ad_accountsTool := mcp.NewTool("user_get_assigned_ad_accounts",
		mcp.WithDescription("GET assigned_ad_accounts for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccount objects. Available fields: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state (and 58 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_assigned_ad_accountsTool)

	// user_get_assigned_applications tool
	// Available fields for Application: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline, auth_dialog_perms_explanation, auth_referral_default_activity_privacy, auth_referral_enabled, auth_referral_extended_perms, auth_referral_friend_perms, auth_referral_response_type, auth_referral_user_perms, auto_event_mapping_android, auto_event_mapping_ios, auto_event_setup_enabled, auto_log_app_events_default, auto_log_app_events_enabled, business, canvas_fluid_height, canvas_fluid_width, canvas_url, category, client_config, company, configured_ios_sso, contact_email, created_time, creator_uid, daily_active_users, daily_active_users_rank, deauth_callback_url, default_share_mode, description, enigma_config, financial_id, gdpv4_chrome_custom_tabs_enabled, gdpv4_enabled, gdpv4_nux_content, gdpv4_nux_enabled, has_messenger_product, hosting_url, icon_url, id, ios_bundle_id, ios_sdk_dialog_flows, ios_sdk_error_categories, ios_sfvc_attr, ios_supports_native_proxy_auth_flow, ios_supports_system_auth, ipad_app_store_id, iphone_app_store_id, latest_sdk_version, link, logging_token, logo_url, migrations, mobile_profile_section_url, mobile_web_url, monthly_active_users, monthly_active_users_rank, name, namespace, object_store_urls, owner_business, page_tab_default_name, page_tab_url, photo_url, privacy_policy_url, profile_section_url, property_id, protected_mode_rules, real_time_mode_devices, restrictions, restrictive_data_filter_params, restrictive_data_filter_rules, sdk_update_message, seamless_login, secure_canvas_url, secure_page_tab_url, server_ip_whitelist, smart_login_bookmark_icon_url, smart_login_menu_icon_url, social_discovery, subcategory, suggested_events_setting, supported_platforms, supports_apprequests_fast_app_switch, supports_attribution, supports_implicit_sdk_logging, suppress_native_ios_gdp, terms_of_service_url, url_scheme_suffix, user_support_email, user_support_url, website_url, weekly_active_users
	user_get_assigned_applicationsTool := mcp.NewTool("user_get_assigned_applications",
		mcp.WithDescription("GET assigned_applications for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Application objects. Available fields: aam_rules, an_ad_space_limit, an_platforms, android_key_hash, android_sdk_error_categories, app_domains, app_events_config, app_events_feature_bitmask, app_events_session_timeout, app_install_tracked, app_name, app_signals_binding_ios, app_type, auth_dialog_data_help_url, auth_dialog_headline (and 91 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_assigned_applicationsTool)

	// user_get_assigned_business_asset_groups tool
	// Available fields for BusinessAssetGroup: id, name, owner_business
	// Params object accepts: contained_asset_id (string)
	user_get_assigned_business_asset_groupsTool := mcp.NewTool("user_get_assigned_business_asset_groups",
		mcp.WithDescription("GET assigned_business_asset_groups for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"contained_asset_id": map[string]any{
					"type":        "string",
					"description": "contained_asset_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: contained_asset_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for BusinessAssetGroup objects. Available fields: id, name, owner_business"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_assigned_business_asset_groupsTool)

	// user_get_assigned_pages tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	// Params object accepts: pages (list<unsigned int>)
	user_get_assigned_pagesTool := mcp.NewTool("user_get_assigned_pages",
		mcp.WithDescription("GET assigned_pages for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"pages": map[string]any{
					"type":        "array",
					"description": "pages parameter",
					"items":       map[string]any{"type": "integer"},
				},
			}),
			mcp.Description("Parameters object containing: pages (array<integer>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_assigned_pagesTool)

	// user_get_assigned_product_catalogs tool
	// Available fields for ProductCatalog: ad_account_to_collaborative_ads_share_settings, agency_collaborative_ads_share_settings, business, catalog_store, commerce_merchant_settings, creator_user, da_display_settings, default_image_url, fallback_image_url, feed_count, id, is_catalog_segment, is_local_catalog, name, owner_business, product_count, store_catalog_settings, user_access_expire_time, vertical
	user_get_assigned_product_catalogsTool := mcp.NewTool("user_get_assigned_product_catalogs",
		mcp.WithDescription("GET assigned_product_catalogs for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProductCatalog objects. Available fields: ad_account_to_collaborative_ads_share_settings, agency_collaborative_ads_share_settings, business, catalog_store, commerce_merchant_settings, creator_user, da_display_settings, default_image_url, fallback_image_url, feed_count, id, is_catalog_segment, is_local_catalog, name, owner_business (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_assigned_product_catalogsTool)

	// user_get_avatars tool
	// Available fields for Avatar: id
	user_get_avatarsTool := mcp.NewTool("user_get_avatars",
		mcp.WithDescription("GET avatars for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Avatar objects. Available fields: id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_avatarsTool)

	// user_get_business_users tool
	// Available fields for BusinessUser: business, business_role_request, email, finance_permission, first_name, id, ip_permission, last_name, marked_for_removal, name, pending_email, role, tasks, title, two_fac_status
	user_get_business_usersTool := mcp.NewTool("user_get_business_users",
		mcp.WithDescription("GET business_users for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for BusinessUser objects. Available fields: business, business_role_request, email, finance_permission, first_name, id, ip_permission, last_name, marked_for_removal, name, pending_email, role, tasks, title, two_fac_status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_business_usersTool)

	// user_delete_businesses tool
	// Params object accepts: business (string)
	user_delete_businessesTool := mcp.NewTool("user_delete_businesses",
		mcp.WithDescription("DELETE businesses for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
				},
			}),
			mcp.Description("Parameters object containing: business (string)"),
		),
	)
	tools = append(tools, user_delete_businessesTool)

	// user_get_businesses tool
	// Available fields for Business: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id, two_factor_type, updated_by, updated_time, user_access_expire_time, verification_status, vertical, vertical_id
	user_get_businessesTool := mcp.NewTool("user_get_businesses",
		mcp.WithDescription("GET businesses for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Business objects. Available fields: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id (and 7 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_businessesTool)

	// user_post_businesses tool
	// Params object accepts: child_business_external_id (string), email (string), name (string), primary_page (string), sales_rep_email (string), survey_business_type (userbusinesses_survey_business_type_enum_param), survey_num_assets (unsigned int), survey_num_people (unsigned int), timezone_id (userbusinesses_timezone_id_enum_param), vertical (userbusinesses_vertical_enum_param)
	user_post_businessesTool := mcp.NewTool("user_post_businesses",
		mcp.WithDescription("POST businesses for User"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"child_business_external_id": map[string]any{
					"type":        "string",
					"description": "child_business_external_id parameter",
				},
				"email": map[string]any{
					"type":        "string",
					"description": "email parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"primary_page": map[string]any{
					"type":        "string",
					"description": "primary_page parameter",
				},
				"sales_rep_email": map[string]any{
					"type":        "string",
					"description": "sales_rep_email parameter",
				},
				"survey_business_type": map[string]any{
					"type":        "string",
					"description": "survey_business_type parameter",
					"enum":        []string{"ADVERTISER", "AGENCY", "APP_DEVELOPER", "PUBLISHER"},
				},
				"survey_num_assets": map[string]any{
					"type":        "integer",
					"description": "survey_num_assets parameter",
				},
				"survey_num_people": map[string]any{
					"type":        "integer",
					"description": "survey_num_people parameter",
				},
				"timezone_id": map[string]any{
					"type":        "string",
					"description": "timezone_id parameter",
					"enum":        []string{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100", "101", "102", "103", "104", "105", "106", "107", "108", "109", "110", "111", "112", "113", "114", "115", "116", "117", "118", "119", "120", "121", "122", "123", "124", "125", "126", "127", "128", "129", "130", "131", "132", "133", "134", "135", "136", "137", "138", "139", "140", "141", "142", "143", "144", "145", "146", "147", "148", "149", "150", "151", "152", "153", "154", "155", "156", "157", "158", "159", "160", "161", "162", "163", "164", "165", "166", "167", "168", "169", "170", "171", "172", "173", "174", "175", "176", "177", "178", "179", "180", "181", "182", "183", "184", "185", "186", "187", "188", "189", "190", "191", "192", "193", "194", "195", "196", "197", "198", "199", "200", "201", "202", "203", "204", "205", "206", "207", "208", "209", "210", "211", "212", "213", "214", "215", "216", "217", "218", "219", "220", "221", "222", "223", "224", "225", "226", "227", "228", "229", "230", "231", "232", "233", "234", "235", "236", "237", "238", "239", "240", "241", "242", "243", "244", "245", "246", "247", "248", "249", "250", "251", "252", "253", "254", "255", "256", "257", "258", "259", "260", "261", "262", "263", "264", "265", "266", "267", "268", "269", "270", "271", "272", "273", "274", "275", "276", "277", "278", "279", "280", "281", "282", "283", "284", "285", "286", "287", "288", "289", "290", "291", "292", "293", "294", "295", "296", "297", "298", "299", "300", "301", "302", "303", "304", "305", "306", "307", "308", "309", "310", "311", "312", "313", "314", "315", "316", "317", "318", "319", "320", "321", "322", "323", "324", "325", "326", "327", "328", "329", "330", "331", "332", "333", "334", "335", "336", "337", "338", "339", "340", "341", "342", "343", "344", "345", "346", "347", "348", "349", "350", "351", "352", "353", "354", "355", "356", "357", "358", "359", "360", "361", "362", "363", "364", "365", "366", "367", "368", "369", "370", "371", "372", "373", "374", "375", "376", "377", "378", "379", "380", "381", "382", "383", "384", "385", "386", "387", "388", "389", "390", "391", "392", "393", "394", "395", "396", "397", "398", "399", "400", "401", "402", "403", "404", "405", "406", "407", "408", "409", "410", "411", "412", "413", "414", "415", "416", "417", "418", "419", "420", "421", "422", "423", "424", "425", "426", "427", "428", "429", "430", "431", "432", "433", "434", "435", "436", "437", "438", "439", "440", "441", "442", "443", "444", "445", "446", "447", "448", "449", "450", "451", "452", "453", "454", "455", "456", "457", "458", "459", "460", "461", "462", "463", "464", "465", "466", "467", "468", "469", "470", "471", "472", "473", "474", "475", "476", "477", "478", "479", "480"},
				},
				"vertical": map[string]any{
					"type":        "string",
					"description": "vertical parameter",
					"required":    true,
					"enum":        []string{"ADVERTISING", "AUTOMOTIVE", "CONSUMER_PACKAGED_GOODS", "ECOMMERCE", "EDUCATION", "ENERGY_AND_UTILITIES", "ENTERTAINMENT_AND_MEDIA", "FINANCIAL_SERVICES", "GAMING", "GOVERNMENT_AND_POLITICS", "HEALTH", "LUXURY", "MARKETING", "NON_PROFIT", "NOT_SET", "ORGANIZATIONS_AND_ASSOCIATIONS", "OTHER", "PROFESSIONAL_SERVICES", "RESTAURANT", "RETAIL", "TECHNOLOGY", "TELECOM", "TRAVEL"},
				},
			}),
			mcp.Description("Parameters object containing: child_business_external_id (string), email (string), name (string) [required], primary_page (string), sales_rep_email (string), survey_business_type (enum) [ADVERTISER, AGENCY, APP_DEVELOPER, PUBLISHER], survey_num_assets (integer), survey_num_people (integer), timezone_id (enum) [0, 1, 2, 3, 4, ...], vertical (enum) [ADVERTISING, AUTOMOTIVE, CONSUMER_PACKAGED_GOODS, ECOMMERCE, EDUCATION, ...] [required]"),
		),
	)
	tools = append(tools, user_post_businessesTool)

	// user_get_conversations tool
	// Available fields for UnifiedThread: can_reply, folder, former_participants, id, is_subscribed, link, linked_group, message_count, name, participants, scoped_thread_key, senders, snippet, subject, unread_count, updated_time, wallpaper
	// Params object accepts: folder (string), platform (userconversations_platform_enum_param), tags (list<string>), user_id (string)
	user_get_conversationsTool := mcp.NewTool("user_get_conversations",
		mcp.WithDescription("GET conversations for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"folder": map[string]any{
					"type":        "string",
					"description": "folder parameter",
				},
				"platform": map[string]any{
					"type":        "string",
					"description": "platform parameter",
					"enum":        []string{"INSTAGRAM", "MESSENGER"},
				},
				"tags": map[string]any{
					"type":        "array",
					"description": "tags parameter",
					"items":       map[string]any{"type": "string"},
				},
				"user_id": map[string]any{
					"type":        "string",
					"description": "user_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: folder (string), platform (enum) [INSTAGRAM, MESSENGER], tags (array<string>), user_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for UnifiedThread objects. Available fields: can_reply, folder, former_participants, id, is_subscribed, link, linked_group, message_count, name, participants, scoped_thread_key, senders, snippet, subject, unread_count (and 2 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_conversationsTool)

	// user_get_custom_labels tool
	// Available fields for PageUserMessageThreadLabel: id, page_label_name
	user_get_custom_labelsTool := mcp.NewTool("user_get_custom_labels",
		mcp.WithDescription("GET custom_labels for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PageUserMessageThreadLabel objects. Available fields: id, page_label_name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_custom_labelsTool)

	// user_get_events tool
	// Available fields for Event: attending_count, can_guests_invite, category, cover, created_time, declined_count, description, discount_code_enabled, end_time, event_times, guest_list_enabled, id, interested_count, is_canceled, is_draft, is_online, is_page_owned, maybe_count, name, noreply_count, online_event_format, online_event_third_party_url, owner, parent_group, place, registration_setting, scheduled_publish_time, start_time, sub_categories, ticket_selling_status, ticket_setting, ticket_uri, ticket_uri_start_sales_time, ticketing_privacy_uri, ticketing_terms_uri, timezone, type, updated_time
	// Params object accepts: include_canceled (bool), type (userevents_type_enum_param)
	user_get_eventsTool := mcp.NewTool("user_get_events",
		mcp.WithDescription("GET events for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"include_canceled": map[string]any{
					"type":        "boolean",
					"description": "include_canceled parameter",
				},
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"attending", "created", "declined", "maybe", "not_replied"},
				},
			}),
			mcp.Description("Parameters object containing: include_canceled (boolean), type (enum) [attending, created, declined, maybe, not_replied]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Event objects. Available fields: attending_count, can_guests_invite, category, cover, created_time, declined_count, description, discount_code_enabled, end_time, event_times, guest_list_enabled, id, interested_count, is_canceled, is_draft (and 23 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_eventsTool)

	// user_get_feed tool
	// Available fields for Post: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, caption, child_attachments, comments_mirroring_domain, coordinates, created_time, description, event, expanded_height, expanded_width, feed_targeting, from, full_picture, height, icon, id, instagram_eligibility, is_app_share, is_eligible_for_promotion, is_expired, is_hidden, is_inline_created, is_instagram_eligible, is_popular, is_published, is_spherical, link, message, message_tags, multi_share_end_card, multi_share_optimized, name, object_id, parent_id, permalink_url, picture, place, privacy, promotable_id, promotion_status, properties, scheduled_publish_time, shares, source, status_type, story, story_tags, subscribed, target, targeting, timeline_visibility, type, updated_time, via, video_buying_eligibility, width
	// Params object accepts: include_hidden (bool), q (string), show_expired (bool), since (datetime), until (datetime), with (string)
	user_get_feedTool := mcp.NewTool("user_get_feed",
		mcp.WithDescription("GET feed for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"include_hidden": map[string]any{
					"type":        "boolean",
					"description": "include_hidden parameter",
				},
				"q": map[string]any{
					"type":        "string",
					"description": "q parameter",
				},
				"show_expired": map[string]any{
					"type":        "boolean",
					"description": "show_expired parameter",
				},
				"since": map[string]any{
					"type":        "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type":        "string",
					"description": "until parameter",
				},
				"with": map[string]any{
					"type":        "string",
					"description": "with parameter",
				},
			}),
			mcp.Description("Parameters object containing: include_hidden (boolean), q (string), show_expired (boolean), since (datetime), until (datetime), with (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Post objects. Available fields: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, caption, child_attachments, comments_mirroring_domain, coordinates, created_time, description, event, expanded_height (and 47 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_feedTool)

	// user_post_feed tool
	// Params object accepts: actions (Object), album_id (string), android_key_hash (string), application_id (string), asked_fun_fact_prompt_id (unsigned int), asset3d_id (string), associated_id (string), attach_place_suggestion (bool), attached_media (list<Object>), audience_exp (bool), backdated_time (datetime), backdated_time_granularity (userfeed_backdated_time_granularity_enum_param), breaking_news (bool), breaking_news_expiration (unsigned int), call_to_action (Object), caption (string), child_attachments (list<Object>), client_mutation_id (string), composer_entry_picker (string), composer_entry_point (string), composer_entry_time (unsigned int), composer_session_events_log (string), composer_session_id (string), composer_source_surface (string), composer_type (string), connection_class (string), content_attachment (string), coordinates (Object), cta_link (string), cta_type (string), description (string), direct_share_status (unsigned int), expanded_height (unsigned int), expanded_width (unsigned int), feed_targeting (Object), formatting (userfeed_formatting_enum_param), fun_fact_prompt_id (string), fun_fact_toastee_id (unsigned int), height (unsigned int), home_checkin_city_id (Object), image_crops (map), implicit_with_tags (list<int>), instant_game_entry_point_data (string), ios_bundle_id (string), is_backout_draft (bool), is_boost_intended (bool), is_explicit_location (bool), is_explicit_share (bool), is_group_linking_post (bool), is_photo_container (bool), link (string), location_source_id (string), manual_privacy (bool), message (string), multi_share_end_card (bool), multi_share_optimized (bool), name (string), nectar_module (string), object_attachment (string), og_action_type_id (string), og_hide_object_attachment (bool), og_icon_id (string), og_object_id (string), og_phrase (string), og_set_profile_badge (bool), og_suggestion_mechanism (string), page_recommendation (string), picture (string), place (Object), place_attachment_setting (userfeed_place_attachment_setting_enum_param), place_list (string), place_list_data (list), post_surfaces_blacklist (list<userfeed_post_surfaces_blacklist_enum_param>), posting_to_redspace (userfeed_posting_to_redspace_enum_param), privacy (string), prompt_id (string), prompt_tracking_string (string), properties (Object), proxied_app_id (string), publish_event_id (unsigned int), published (bool), quote (string), ref (list<string>), referenceable_image_ids (list<string>), referral_id (string), scheduled_publish_time (datetime), source (string), sponsor_id (string), sponsor_relationship (unsigned int), suggested_place_id (Object), tags (list<int>), target_surface (userfeed_target_surface_enum_param), targeting (Object), text_format_metadata (string), text_format_preset_id (string), text_only_place (string), thumbnail (file), time_since_original_post (unsigned int), title (string), tracking_info (string), unpublished_content_type (userfeed_unpublished_content_type_enum_param), user_selected_tags (bool), video_start_time_ms (unsigned int), viewer_coordinates (Object), width (unsigned int)
	user_post_feedTool := mcp.NewTool("user_post_feed",
		mcp.WithDescription("POST feed for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"actions": map[string]any{
					"type":        "object",
					"description": "actions parameter",
				},
				"album_id": map[string]any{
					"type":        "string",
					"description": "album_id parameter",
				},
				"android_key_hash": map[string]any{
					"type":        "string",
					"description": "android_key_hash parameter",
				},
				"application_id": map[string]any{
					"type":        "string",
					"description": "application_id parameter",
				},
				"asked_fun_fact_prompt_id": map[string]any{
					"type":        "integer",
					"description": "asked_fun_fact_prompt_id parameter",
				},
				"asset3d_id": map[string]any{
					"type":        "string",
					"description": "asset3d_id parameter",
				},
				"associated_id": map[string]any{
					"type":        "string",
					"description": "associated_id parameter",
				},
				"attach_place_suggestion": map[string]any{
					"type":        "boolean",
					"description": "attach_place_suggestion parameter",
				},
				"attached_media": map[string]any{
					"type":        "array",
					"description": "attached_media parameter",
					"items":       map[string]any{"type": "object"},
				},
				"audience_exp": map[string]any{
					"type":        "boolean",
					"description": "audience_exp parameter",
				},
				"backdated_time": map[string]any{
					"type":        "string",
					"description": "backdated_time parameter",
				},
				"backdated_time_granularity": map[string]any{
					"type":        "string",
					"description": "backdated_time_granularity parameter",
					"enum":        []string{"day", "hour", "min", "month", "none", "year"},
				},
				"breaking_news": map[string]any{
					"type":        "boolean",
					"description": "breaking_news parameter",
				},
				"breaking_news_expiration": map[string]any{
					"type":        "integer",
					"description": "breaking_news_expiration parameter",
				},
				"call_to_action": map[string]any{
					"type":        "object",
					"description": "call_to_action parameter",
				},
				"caption": map[string]any{
					"type":        "string",
					"description": "caption parameter",
				},
				"child_attachments": map[string]any{
					"type":        "array",
					"description": "child_attachments parameter",
					"items":       map[string]any{"type": "object"},
				},
				"client_mutation_id": map[string]any{
					"type":        "string",
					"description": "client_mutation_id parameter",
				},
				"composer_entry_picker": map[string]any{
					"type":        "string",
					"description": "composer_entry_picker parameter",
				},
				"composer_entry_point": map[string]any{
					"type":        "string",
					"description": "composer_entry_point parameter",
				},
				"composer_entry_time": map[string]any{
					"type":        "integer",
					"description": "composer_entry_time parameter",
				},
				"composer_session_events_log": map[string]any{
					"type":        "string",
					"description": "composer_session_events_log parameter",
				},
				"composer_session_id": map[string]any{
					"type":        "string",
					"description": "composer_session_id parameter",
				},
				"composer_source_surface": map[string]any{
					"type":        "string",
					"description": "composer_source_surface parameter",
				},
				"composer_type": map[string]any{
					"type":        "string",
					"description": "composer_type parameter",
				},
				"connection_class": map[string]any{
					"type":        "string",
					"description": "connection_class parameter",
				},
				"content_attachment": map[string]any{
					"type":        "string",
					"description": "content_attachment parameter",
				},
				"coordinates": map[string]any{
					"type":        "object",
					"description": "coordinates parameter",
				},
				"cta_link": map[string]any{
					"type":        "string",
					"description": "cta_link parameter",
				},
				"cta_type": map[string]any{
					"type":        "string",
					"description": "cta_type parameter",
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"direct_share_status": map[string]any{
					"type":        "integer",
					"description": "direct_share_status parameter",
				},
				"expanded_height": map[string]any{
					"type":        "integer",
					"description": "expanded_height parameter",
				},
				"expanded_width": map[string]any{
					"type":        "integer",
					"description": "expanded_width parameter",
				},
				"feed_targeting": map[string]any{
					"type":        "object",
					"description": "feed_targeting parameter",
				},
				"formatting": map[string]any{
					"type":        "string",
					"description": "formatting parameter",
					"enum":        []string{"MARKDOWN", "PLAINTEXT"},
				},
				"fun_fact_prompt_id": map[string]any{
					"type":        "string",
					"description": "fun_fact_prompt_id parameter",
				},
				"fun_fact_toastee_id": map[string]any{
					"type":        "integer",
					"description": "fun_fact_toastee_id parameter",
				},
				"height": map[string]any{
					"type":        "integer",
					"description": "height parameter",
				},
				"home_checkin_city_id": map[string]any{
					"type":        "object",
					"description": "home_checkin_city_id parameter",
				},
				"image_crops": map[string]any{
					"type":        "object",
					"description": "image_crops parameter",
				},
				"implicit_with_tags": map[string]any{
					"type":        "array",
					"description": "implicit_with_tags parameter",
					"items":       map[string]any{"type": "integer"},
				},
				"instant_game_entry_point_data": map[string]any{
					"type":        "string",
					"description": "instant_game_entry_point_data parameter",
				},
				"ios_bundle_id": map[string]any{
					"type":        "string",
					"description": "ios_bundle_id parameter",
				},
				"is_backout_draft": map[string]any{
					"type":        "boolean",
					"description": "is_backout_draft parameter",
				},
				"is_boost_intended": map[string]any{
					"type":        "boolean",
					"description": "is_boost_intended parameter",
				},
				"is_explicit_location": map[string]any{
					"type":        "boolean",
					"description": "is_explicit_location parameter",
				},
				"is_explicit_share": map[string]any{
					"type":        "boolean",
					"description": "is_explicit_share parameter",
				},
				"is_group_linking_post": map[string]any{
					"type":        "boolean",
					"description": "is_group_linking_post parameter",
				},
				"is_photo_container": map[string]any{
					"type":        "boolean",
					"description": "is_photo_container parameter",
				},
				"link": map[string]any{
					"type":        "string",
					"description": "link parameter",
				},
				"location_source_id": map[string]any{
					"type":        "string",
					"description": "location_source_id parameter",
				},
				"manual_privacy": map[string]any{
					"type":        "boolean",
					"description": "manual_privacy parameter",
				},
				"message": map[string]any{
					"type":        "string",
					"description": "message parameter",
				},
				"multi_share_end_card": map[string]any{
					"type":        "boolean",
					"description": "multi_share_end_card parameter",
				},
				"multi_share_optimized": map[string]any{
					"type":        "boolean",
					"description": "multi_share_optimized parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"nectar_module": map[string]any{
					"type":        "string",
					"description": "nectar_module parameter",
				},
				"object_attachment": map[string]any{
					"type":        "string",
					"description": "object_attachment parameter",
				},
				"og_action_type_id": map[string]any{
					"type":        "string",
					"description": "og_action_type_id parameter",
				},
				"og_hide_object_attachment": map[string]any{
					"type":        "boolean",
					"description": "og_hide_object_attachment parameter",
				},
				"og_icon_id": map[string]any{
					"type":        "string",
					"description": "og_icon_id parameter",
				},
				"og_object_id": map[string]any{
					"type":        "string",
					"description": "og_object_id parameter",
				},
				"og_phrase": map[string]any{
					"type":        "string",
					"description": "og_phrase parameter",
				},
				"og_set_profile_badge": map[string]any{
					"type":        "boolean",
					"description": "og_set_profile_badge parameter",
				},
				"og_suggestion_mechanism": map[string]any{
					"type":        "string",
					"description": "og_suggestion_mechanism parameter",
				},
				"page_recommendation": map[string]any{
					"type":        "string",
					"description": "page_recommendation parameter",
				},
				"picture": map[string]any{
					"type":        "string",
					"description": "picture parameter",
				},
				"place": map[string]any{
					"type":        "object",
					"description": "place parameter",
				},
				"place_attachment_setting": map[string]any{
					"type":        "string",
					"description": "place_attachment_setting parameter",
					"enum":        []string{"1", "2"},
				},
				"place_list": map[string]any{
					"type":        "string",
					"description": "place_list parameter",
				},
				"place_list_data": map[string]any{
					"type":        "string",
					"description": "place_list_data parameter",
				},
				"post_surfaces_blacklist": map[string]any{
					"type":        "array",
					"description": "post_surfaces_blacklist parameter",
					"enum":        []string{"1", "2", "3", "4", "5"},
					"items":       map[string]any{"type": "string"},
				},
				"posting_to_redspace": map[string]any{
					"type":        "string",
					"description": "posting_to_redspace parameter",
					"enum":        []string{"disabled", "enabled"},
				},
				"privacy": map[string]any{
					"type":        "string",
					"description": "privacy parameter",
				},
				"prompt_id": map[string]any{
					"type":        "string",
					"description": "prompt_id parameter",
				},
				"prompt_tracking_string": map[string]any{
					"type":        "string",
					"description": "prompt_tracking_string parameter",
				},
				"properties": map[string]any{
					"type":        "object",
					"description": "properties parameter",
				},
				"proxied_app_id": map[string]any{
					"type":        "string",
					"description": "proxied_app_id parameter",
				},
				"publish_event_id": map[string]any{
					"type":        "integer",
					"description": "publish_event_id parameter",
				},
				"published": map[string]any{
					"type":        "boolean",
					"description": "published parameter",
				},
				"quote": map[string]any{
					"type":        "string",
					"description": "quote parameter",
				},
				"ref": map[string]any{
					"type":        "array",
					"description": "ref parameter",
					"items":       map[string]any{"type": "string"},
				},
				"referenceable_image_ids": map[string]any{
					"type":        "array",
					"description": "referenceable_image_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"referral_id": map[string]any{
					"type":        "string",
					"description": "referral_id parameter",
				},
				"scheduled_publish_time": map[string]any{
					"type":        "string",
					"description": "scheduled_publish_time parameter",
				},
				"source": map[string]any{
					"type":        "string",
					"description": "source parameter",
				},
				"sponsor_id": map[string]any{
					"type":        "string",
					"description": "sponsor_id parameter",
				},
				"sponsor_relationship": map[string]any{
					"type":        "integer",
					"description": "sponsor_relationship parameter",
				},
				"suggested_place_id": map[string]any{
					"type":        "object",
					"description": "suggested_place_id parameter",
				},
				"tags": map[string]any{
					"type":        "array",
					"description": "tags parameter",
					"items":       map[string]any{"type": "integer"},
				},
				"target_surface": map[string]any{
					"type":        "string",
					"description": "target_surface parameter",
					"enum":        []string{"STORY", "TIMELINE"},
				},
				"targeting": map[string]any{
					"type":        "object",
					"description": "targeting parameter",
				},
				"text_format_metadata": map[string]any{
					"type":        "string",
					"description": "text_format_metadata parameter",
				},
				"text_format_preset_id": map[string]any{
					"type":        "string",
					"description": "text_format_preset_id parameter",
				},
				"text_only_place": map[string]any{
					"type":        "string",
					"description": "text_only_place parameter",
				},
				"thumbnail": map[string]any{
					"type":        "string",
					"description": "thumbnail parameter",
				},
				"time_since_original_post": map[string]any{
					"type":        "integer",
					"description": "time_since_original_post parameter",
				},
				"title": map[string]any{
					"type":        "string",
					"description": "title parameter",
				},
				"tracking_info": map[string]any{
					"type":        "string",
					"description": "tracking_info parameter",
				},
				"unpublished_content_type": map[string]any{
					"type":        "string",
					"description": "unpublished_content_type parameter",
					"enum":        []string{"ADS_POST", "DRAFT", "INLINE_CREATED", "PUBLISHED", "REVIEWABLE_BRANDED_CONTENT", "SCHEDULED", "SCHEDULED_RECURRING"},
				},
				"user_selected_tags": map[string]any{
					"type":        "boolean",
					"description": "user_selected_tags parameter",
				},
				"video_start_time_ms": map[string]any{
					"type":        "integer",
					"description": "video_start_time_ms parameter",
				},
				"viewer_coordinates": map[string]any{
					"type":        "object",
					"description": "viewer_coordinates parameter",
				},
				"width": map[string]any{
					"type":        "integer",
					"description": "width parameter",
				},
			}),
			mcp.Description("Parameters object containing: actions (object), album_id (string), android_key_hash (string), application_id (string), asked_fun_fact_prompt_id (integer), asset3d_id (string), associated_id (string), attach_place_suggestion (boolean), attached_media (array<object>), audience_exp (boolean), backdated_time (datetime), backdated_time_granularity (enum) [day, hour, min, month, none, ...], breaking_news (boolean), breaking_news_expiration (integer), call_to_action (object), caption (string), child_attachments (array<object>), client_mutation_id (string), composer_entry_picker (string), composer_entry_point (string), composer_entry_time (integer), composer_session_events_log (string), composer_session_id (string), composer_source_surface (string), composer_type (string), connection_class (string), content_attachment (string), coordinates (object), cta_link (string), cta_type (string), description (string), direct_share_status (integer), expanded_height (integer), expanded_width (integer), feed_targeting (object), formatting (enum) [MARKDOWN, PLAINTEXT], fun_fact_prompt_id (string), fun_fact_toastee_id (integer), height (integer), home_checkin_city_id (object), image_crops (object), implicit_with_tags (array<integer>), instant_game_entry_point_data (string), ios_bundle_id (string), is_backout_draft (boolean), is_boost_intended (boolean), is_explicit_location (boolean), is_explicit_share (boolean), is_group_linking_post (boolean), is_photo_container (boolean), link (string), location_source_id (string), manual_privacy (boolean), message (string), multi_share_end_card (boolean), multi_share_optimized (boolean), name (string), nectar_module (string), object_attachment (string), og_action_type_id (string), og_hide_object_attachment (boolean), og_icon_id (string), og_object_id (string), og_phrase (string), og_set_profile_badge (boolean), og_suggestion_mechanism (string), page_recommendation (string), picture (string), place (object), place_attachment_setting (enum) [1, 2], place_list (string), place_list_data (list), post_surfaces_blacklist (array<enum>) [1, 2, 3, 4, 5], posting_to_redspace (enum) [disabled, enabled], privacy (string), prompt_id (string), prompt_tracking_string (string), properties (object), proxied_app_id (string), publish_event_id (integer), published (boolean), quote (string), ref (array<string>), referenceable_image_ids (array<string>), referral_id (string), scheduled_publish_time (datetime), source (string), sponsor_id (string), sponsor_relationship (integer), suggested_place_id (object), tags (array<integer>), target_surface (enum) [STORY, TIMELINE], targeting (object), text_format_metadata (string), text_format_preset_id (string), text_only_place (string), thumbnail (file), time_since_original_post (integer), title (string), tracking_info (string), unpublished_content_type (enum) [ADS_POST, DRAFT, INLINE_CREATED, PUBLISHED, REVIEWABLE_BRANDED_CONTENT, ...], user_selected_tags (boolean), video_start_time_ms (integer), viewer_coordinates (object), width (integer)"),
		),
	)
	tools = append(tools, user_post_feedTool)

	// user_get_friends tool
	// Available fields for User: about, age_range, avatar_2d_profile_picture, birthday, client_business_id, community, cover, currency, education, email, favorite_athletes, favorite_teams, first_name, gender, hometown, id, id_for_avatars, inspirational_people, install_type, installed, is_guest_user, is_work_account, languages, last_name, link, local_news_megaphone_dismiss_status, local_news_subscription_status, locale, location, meeting_for, middle_name, name, name_format, payment_pricepoints, political, profile_pic, quotes, relationship_status, religion, shared_login_upgrade_required_by, short_name, significant_other, sports, supports_donate_button_in_live_video, third_party_id, timezone, token_for_business, updated_time, verified, video_upload_limits, website
	// Params object accepts: uid (int)
	user_get_friendsTool := mcp.NewTool("user_get_friends",
		mcp.WithDescription("GET friends for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"uid": map[string]any{
					"type":        "integer",
					"description": "uid parameter",
				},
			}),
			mcp.Description("Parameters object containing: uid (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for User objects. Available fields: about, age_range, avatar_2d_profile_picture, birthday, client_business_id, community, cover, currency, education, email, favorite_athletes, favorite_teams, first_name, gender, hometown (and 36 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_friendsTool)

	// user_get_fundraisers tool
	// Available fields for FundraiserPersonToCharity: amount_raised, charity_id, currency, description, donations_count, donors_count, end_time, external_amount_raised, external_donations_count, external_donors_count, external_event_name, external_event_start_time, external_event_uri, external_fundraiser_uri, external_id, goal_amount, id, internal_amount_raised, internal_donations_count, internal_donors_count, name, uri
	user_get_fundraisersTool := mcp.NewTool("user_get_fundraisers",
		mcp.WithDescription("GET fundraisers for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for FundraiserPersonToCharity objects. Available fields: amount_raised, charity_id, currency, description, donations_count, donors_count, end_time, external_amount_raised, external_donations_count, external_donors_count, external_event_name, external_event_start_time, external_event_uri, external_fundraiser_uri, external_id (and 7 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_fundraisersTool)

	// user_post_fundraisers tool
	// Params object accepts: charity_id (string), cover_photo (file), currency (string), description (string), end_time (datetime), external_event_name (string), external_event_start_time (datetime), external_event_uri (string), external_fundraiser_uri (string), external_id (string), fundraiser_type (userfundraisers_fundraiser_type_enum_param), goal_amount (unsigned int), name (string), page_id (string)
	user_post_fundraisersTool := mcp.NewTool("user_post_fundraisers",
		mcp.WithDescription("POST fundraisers for User"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"charity_id": map[string]any{
					"type":        "string",
					"description": "charity_id parameter",
				},
				"cover_photo": map[string]any{
					"type":        "string",
					"description": "cover_photo parameter",
				},
				"currency": map[string]any{
					"type":        "string",
					"description": "currency parameter",
					"required":    true,
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
					"required":    true,
				},
				"end_time": map[string]any{
					"type":        "string",
					"description": "end_time parameter",
					"required":    true,
				},
				"external_event_name": map[string]any{
					"type":        "string",
					"description": "external_event_name parameter",
				},
				"external_event_start_time": map[string]any{
					"type":        "string",
					"description": "external_event_start_time parameter",
				},
				"external_event_uri": map[string]any{
					"type":        "string",
					"description": "external_event_uri parameter",
				},
				"external_fundraiser_uri": map[string]any{
					"type":        "string",
					"description": "external_fundraiser_uri parameter",
				},
				"external_id": map[string]any{
					"type":        "string",
					"description": "external_id parameter",
					"required":    true,
				},
				"fundraiser_type": map[string]any{
					"type":        "string",
					"description": "fundraiser_type parameter",
					"required":    true,
					"enum":        []string{"person_for_charity"},
				},
				"goal_amount": map[string]any{
					"type":        "integer",
					"description": "goal_amount parameter",
					"required":    true,
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
					"required":    true,
				},
				"page_id": map[string]any{
					"type":        "string",
					"description": "page_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: charity_id (string), cover_photo (file), currency (string) [required], description (string) [required], end_time (datetime) [required], external_event_name (string), external_event_start_time (datetime), external_event_uri (string), external_fundraiser_uri (string), external_id (string) [required], fundraiser_type (enum) [person_for_charity] [required], goal_amount (integer) [required], name (string) [required], page_id (string)"),
		),
	)
	tools = append(tools, user_post_fundraisersTool)

	// user_get_groups tool
	// Available fields for Group: archived, cover, created_time, description, email, icon, id, install, link, member_count, member_request_count, name, parent, permissions, privacy, purpose, subdomain, updated_time, venue
	// Params object accepts: admin_only (bool), parent (string)
	user_get_groupsTool := mcp.NewTool("user_get_groups",
		mcp.WithDescription("GET groups for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"admin_only": map[string]any{
					"type":        "boolean",
					"description": "admin_only parameter",
				},
				"parent": map[string]any{
					"type":        "string",
					"description": "parent parameter",
				},
			}),
			mcp.Description("Parameters object containing: admin_only (boolean), parent (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Group objects. Available fields: archived, cover, created_time, description, email, icon, id, install, link, member_count, member_request_count, name, parent, permissions, privacy (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_groupsTool)

	// user_get_ids_for_apps tool
	// Available fields for UserIDForApp: app, id
	// Params object accepts: app (int)
	user_get_ids_for_appsTool := mcp.NewTool("user_get_ids_for_apps",
		mcp.WithDescription("GET ids_for_apps for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"app": map[string]any{
					"type":        "integer",
					"description": "app parameter",
				},
			}),
			mcp.Description("Parameters object containing: app (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for UserIDForApp objects. Available fields: app, id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_ids_for_appsTool)

	// user_get_ids_for_business tool
	// Available fields for UserIDForApp: app, id
	// Params object accepts: app (int)
	user_get_ids_for_businessTool := mcp.NewTool("user_get_ids_for_business",
		mcp.WithDescription("GET ids_for_business for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"app": map[string]any{
					"type":        "integer",
					"description": "app parameter",
				},
			}),
			mcp.Description("Parameters object containing: app (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for UserIDForApp objects. Available fields: app, id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_ids_for_businessTool)

	// user_get_ids_for_pages tool
	// Available fields for UserIDForPage: id, page
	// Params object accepts: page (int)
	user_get_ids_for_pagesTool := mcp.NewTool("user_get_ids_for_pages",
		mcp.WithDescription("GET ids_for_pages for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"page": map[string]any{
					"type":        "integer",
					"description": "page parameter",
				},
			}),
			mcp.Description("Parameters object containing: page (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for UserIDForPage objects. Available fields: id, page"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_ids_for_pagesTool)

	// user_get_likes tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	// Params object accepts: target_id (string)
	user_get_likesTool := mcp.NewTool("user_get_likes",
		mcp.WithDescription("GET likes for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"target_id": map[string]any{
					"type":        "string",
					"description": "target_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: target_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_likesTool)

	// user_get_live_videos tool
	// Available fields for LiveVideo: ad_break_config, ad_break_failure_reason, broadcast_start_time, copyright, creation_time, dash_ingest_url, dash_preview_url, description, embed_html, from, id, ingest_streams, is_manual_mode, is_reference_only, live_views, overlay_url, permalink_url, planned_start_time, recommended_encoder_settings, seconds_left, secure_stream_url, status, stream_url, targeting, title, total_views, video
	// Params object accepts: broadcast_status (list<userlive_videos_broadcast_status_enum_param>), source (userlive_videos_source_enum_param)
	user_get_live_videosTool := mcp.NewTool("user_get_live_videos",
		mcp.WithDescription("GET live_videos for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"broadcast_status": map[string]any{
					"type":        "array",
					"description": "broadcast_status parameter",
					"enum":        []string{"LIVE", "LIVE_STOPPED", "PROCESSING", "SCHEDULED_CANCELED", "SCHEDULED_EXPIRED", "SCHEDULED_LIVE", "SCHEDULED_UNPUBLISHED", "UNPUBLISHED", "VOD"},
					"items":       map[string]any{"type": "string"},
				},
				"source": map[string]any{
					"type":        "string",
					"description": "source parameter",
					"enum":        []string{"owner", "target"},
				},
			}),
			mcp.Description("Parameters object containing: broadcast_status (array<enum>) [LIVE, LIVE_STOPPED, PROCESSING, SCHEDULED_CANCELED, SCHEDULED_EXPIRED, ...], source (enum) [owner, target]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for LiveVideo objects. Available fields: ad_break_config, ad_break_failure_reason, broadcast_start_time, copyright, creation_time, dash_ingest_url, dash_preview_url, description, embed_html, from, id, ingest_streams, is_manual_mode, is_reference_only, live_views (and 12 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_live_videosTool)

	// user_post_live_videos tool
	// Params object accepts: content_tags (list<string>), description (string), enable_backup_ingest (bool), encoding_settings (string), event_params (Object), fisheye_video_cropped (bool), front_z_rotation (float), is_audio_only (bool), is_spherical (bool), original_fov (unsigned int), privacy (string), projection (userlive_videos_projection_enum_param), published (bool), schedule_custom_profile_image (file), spatial_audio_format (userlive_videos_spatial_audio_format_enum_param), status (userlive_videos_status_enum_param), stereoscopic_mode (userlive_videos_stereoscopic_mode_enum_param), stop_on_delete_stream (bool), stream_type (userlive_videos_stream_type_enum_param), title (string)
	user_post_live_videosTool := mcp.NewTool("user_post_live_videos",
		mcp.WithDescription("POST live_videos for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"content_tags": map[string]any{
					"type":        "array",
					"description": "content_tags parameter",
					"items":       map[string]any{"type": "string"},
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"enable_backup_ingest": map[string]any{
					"type":        "boolean",
					"description": "enable_backup_ingest parameter",
				},
				"encoding_settings": map[string]any{
					"type":        "string",
					"description": "encoding_settings parameter",
				},
				"event_params": map[string]any{
					"type":        "object",
					"description": "event_params parameter",
				},
				"fisheye_video_cropped": map[string]any{
					"type":        "boolean",
					"description": "fisheye_video_cropped parameter",
				},
				"front_z_rotation": map[string]any{
					"type":        "number",
					"description": "front_z_rotation parameter",
				},
				"is_audio_only": map[string]any{
					"type":        "boolean",
					"description": "is_audio_only parameter",
				},
				"is_spherical": map[string]any{
					"type":        "boolean",
					"description": "is_spherical parameter",
				},
				"original_fov": map[string]any{
					"type":        "integer",
					"description": "original_fov parameter",
				},
				"privacy": map[string]any{
					"type":        "string",
					"description": "privacy parameter",
				},
				"projection": map[string]any{
					"type":        "string",
					"description": "projection parameter",
					"enum":        []string{"CUBEMAP", "EQUIRECTANGULAR", "HALF_EQUIRECTANGULAR"},
				},
				"published": map[string]any{
					"type":        "boolean",
					"description": "published parameter",
				},
				"schedule_custom_profile_image": map[string]any{
					"type":        "string",
					"description": "schedule_custom_profile_image parameter",
				},
				"spatial_audio_format": map[string]any{
					"type":        "string",
					"description": "spatial_audio_format parameter",
					"enum":        []string{"ambiX_4"},
				},
				"status": map[string]any{
					"type":        "string",
					"description": "status parameter",
					"enum":        []string{"LIVE_NOW", "SCHEDULED_CANCELED", "SCHEDULED_LIVE", "SCHEDULED_UNPUBLISHED", "UNPUBLISHED"},
				},
				"stereoscopic_mode": map[string]any{
					"type":        "string",
					"description": "stereoscopic_mode parameter",
					"enum":        []string{"LEFT_RIGHT", "MONO", "TOP_BOTTOM"},
				},
				"stop_on_delete_stream": map[string]any{
					"type":        "boolean",
					"description": "stop_on_delete_stream parameter",
				},
				"stream_type": map[string]any{
					"type":        "string",
					"description": "stream_type parameter",
					"enum":        []string{"AMBIENT", "REGULAR"},
				},
				"title": map[string]any{
					"type":        "string",
					"description": "title parameter",
				},
			}),
			mcp.Description("Parameters object containing: content_tags (array<string>), description (string), enable_backup_ingest (boolean), encoding_settings (string), event_params (object), fisheye_video_cropped (boolean), front_z_rotation (number), is_audio_only (boolean), is_spherical (boolean), original_fov (integer), privacy (string), projection (enum) [CUBEMAP, EQUIRECTANGULAR, HALF_EQUIRECTANGULAR], published (boolean), schedule_custom_profile_image (file), spatial_audio_format (enum) [ambiX_4], status (enum) [LIVE_NOW, SCHEDULED_CANCELED, SCHEDULED_LIVE, SCHEDULED_UNPUBLISHED, UNPUBLISHED], stereoscopic_mode (enum) [LEFT_RIGHT, MONO, TOP_BOTTOM], stop_on_delete_stream (boolean), stream_type (enum) [AMBIENT, REGULAR], title (string)"),
		),
	)
	tools = append(tools, user_post_live_videosTool)

	// user_post_messenger_desktop_performance_traces tool
	user_post_messenger_desktop_performance_tracesTool := mcp.NewTool("user_post_messenger_desktop_performance_traces",
		mcp.WithDescription("POST messenger_desktop_performance_traces for User"),
	)
	tools = append(tools, user_post_messenger_desktop_performance_tracesTool)

	// user_post_messenger_kids_accounts_unread_badge tool
	// Params object accepts: proxied_app_id (int)
	user_post_messenger_kids_accounts_unread_badgeTool := mcp.NewTool("user_post_messenger_kids_accounts_unread_badge",
		mcp.WithDescription("POST messenger_kids_accounts_unread_badge for User"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"proxied_app_id": map[string]any{
					"type":        "integer",
					"description": "proxied_app_id parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: proxied_app_id (integer) [required]"),
		),
	)
	tools = append(tools, user_post_messenger_kids_accounts_unread_badgeTool)

	// user_get_music tool
	// Available fields for Page: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent, breaking_news_usage, built, business, can_checkin, can_post, category, category_list, checkins, company_overview, connected_instagram_account, connected_page_backed_instagram_account, contact_address, copyright_whitelisted_ig_partners, country_page_likes, cover, culinary_team, current_location, delivery_and_pickup_option_info, description, description_html, differently_open_offerings, directed_by, display_subtext, displayed_message_response_time, does_viewer_have_page_permission_link_ig, emails, engagement, fan_count, featured_video, features, followers_count, food_styles, founded, general_info, general_manager, genre, global_brand_page_name, global_brand_root_id, has_added_app, has_lead_access, has_transitioned_to_new_page_experience, has_whatsapp_business_number, has_whatsapp_number, hometown, hours, id, impressum, influences, instagram_business_account, is_always_open, is_calling_eligible, is_chain, is_community_page, is_eligible_for_branded_content, is_eligible_for_disable_connect_ig_btn_for_non_page_admin_am_web, is_messenger_bot_get_started_enabled, is_messenger_platform_bot, is_owned, is_permanently_closed, is_published, is_unclaimed, is_verified, is_webhooks_subscribed, keywords, leadgen_tos_acceptance_time, leadgen_tos_accepted, leadgen_tos_accepting_user, link, location, members, merchant_id, merchant_review_status, messaging_feature_status, messenger_ads_default_icebreakers, messenger_ads_default_quick_replies, messenger_ads_quick_replies_type, mini_shop_storefront, mission, mpg, name, name_with_location_descriptor, network, new_like_count, offer_eligible, overall_star_rating, owner_business, page_token, parent_page, parking, payment_options, personal_info, personal_interests, pharma_safety_info, phone, pickup_options, place_type, plot_outline, preferred_audience, press_contact, price_range, privacy_info_url, produced_by, products, promotion_eligible, promotion_ineligible_reason, public_transit, rating_count, recipient, record_label, release_date, restaurant_services, restaurant_specialties, schedule, screenplay_by, season, single_line_address, starring, start_info, store_code, store_location_descriptor, store_number, studio, supports_donate_button_in_live_video, talking_about_count, temporary_status, unread_message_count, unread_notif_count, unseen_message_count, user_access_expire_time, username, verification_status, voip_info, website, were_here_count, whatsapp_number, written_by
	// Params object accepts: target_id (string)
	user_get_musicTool := mcp.NewTool("user_get_music",
		mcp.WithDescription("GET music for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"target_id": map[string]any{
					"type":        "string",
					"description": "target_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: target_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Page objects. Available fields: about, access_token, ad_campaign, affiliation, app_id, artists_we_like, attire, available_promo_offer_ids, awards, band_interests, band_members, best_page, bio, birthday, booking_agent (and 136 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_musicTool)

	// user_post_notifications tool
	// Params object accepts: bot_message_payload_elements (string), filtering (list<usernotifications_filtering_enum_param>), href (Object), label (string), message (map), notif_ids (list<string>), payload (string), read (bool), ref (string), schedule_interval (unsigned int), seen (bool), template (Object), type (usernotifications_type_enum_param)
	user_post_notificationsTool := mcp.NewTool("user_post_notifications",
		mcp.WithDescription("POST notifications for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"bot_message_payload_elements": map[string]any{
					"type":        "string",
					"description": "bot_message_payload_elements parameter",
				},
				"filtering": map[string]any{
					"type":        "array",
					"description": "filtering parameter",
					"enum":        []string{"ema", "groups", "groups_social"},
					"items":       map[string]any{"type": "string"},
				},
				"href": map[string]any{
					"type":        "object",
					"description": "href parameter",
				},
				"label": map[string]any{
					"type":        "string",
					"description": "label parameter",
				},
				"message": map[string]any{
					"type":        "object",
					"description": "message parameter",
				},
				"notif_ids": map[string]any{
					"type":        "array",
					"description": "notif_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
				"payload": map[string]any{
					"type":        "string",
					"description": "payload parameter",
				},
				"read": map[string]any{
					"type":        "boolean",
					"description": "read parameter",
				},
				"ref": map[string]any{
					"type":        "string",
					"description": "ref parameter",
				},
				"schedule_interval": map[string]any{
					"type":        "integer",
					"description": "schedule_interval parameter",
				},
				"seen": map[string]any{
					"type":        "boolean",
					"description": "seen parameter",
				},
				"template": map[string]any{
					"type":        "object",
					"description": "template parameter",
				},
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"content_update", "generic"},
				},
			}),
			mcp.Description("Parameters object containing: bot_message_payload_elements (string), filtering (array<enum>) [ema, groups, groups_social], href (object), label (string), message (object), notif_ids (array<string>), payload (string), read (boolean), ref (string), schedule_interval (integer), seen (boolean), template (object), type (enum) [content_update, generic]"),
		),
	)
	tools = append(tools, user_post_notificationsTool)

	// user_get_payment_transactions tool
	// Available fields for PaymentEnginePayment: actions, application, country, created_time, disputes, fraud_status, fulfillment_status, id, is_from_ad, is_from_page_post, items, payout_foreign_exchange_rate, phone_support_eligible, platform, refundable_amount, request_id, tax, tax_country, test, user
	user_get_payment_transactionsTool := mcp.NewTool("user_get_payment_transactions",
		mcp.WithDescription("GET payment_transactions for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for PaymentEnginePayment objects. Available fields: actions, application, country, created_time, disputes, fraud_status, fulfillment_status, id, is_from_ad, is_from_page_post, items, payout_foreign_exchange_rate, phone_support_eligible, platform, refundable_amount (and 5 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_payment_transactionsTool)

	// user_delete_permissions tool
	// Params object accepts: permission (string)
	user_delete_permissionsTool := mcp.NewTool("user_delete_permissions",
		mcp.WithDescription("DELETE permissions for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"permission": map[string]any{
					"type":        "string",
					"description": "permission parameter",
				},
			}),
			mcp.Description("Parameters object containing: permission (string)"),
		),
	)
	tools = append(tools, user_delete_permissionsTool)

	// user_get_permissions tool
	// Available fields for Permission: permission, status
	// Params object accepts: permission (string), status (userpermissions_status_enum_param)
	user_get_permissionsTool := mcp.NewTool("user_get_permissions",
		mcp.WithDescription("GET permissions for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"permission": map[string]any{
					"type":        "string",
					"description": "permission parameter",
				},
				"status": map[string]any{
					"type":        "string",
					"description": "status parameter",
					"enum":        []string{"declined", "expired", "granted"},
				},
			}),
			mcp.Description("Parameters object containing: permission (string), status (enum) [declined, expired, granted]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Permission objects. Available fields: permission, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_permissionsTool)

	// user_get_personal_ad_accounts tool
	// Available fields for AdAccount: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state, business_street, business_street2, business_zip, can_create_brand_lift_study, capabilities, created_time, currency, custom_audience_info, default_dsa_beneficiary, default_dsa_payor, disable_reason, end_advertiser, end_advertiser_name, existing_customers, expired_funding_source_details, extended_credit_invoice_group, failed_delivery_checks, fb_entity, funding_source, funding_source_details, has_migrated_permissions, has_page_authorized_adaccount, id, io_number, is_attribution_spec_system_default, is_ba_skip_delayed_eligible, is_direct_deals_enabled, is_in_3ds_authorization_enabled_market, is_notifications_enabled, is_personal, is_prepay_account, is_tax_id_required, liable_address, line_numbers, media_agency, min_campaign_group_spend_cap, min_daily_budget, name, offsite_pixels_tos_accepted, owner, owner_business, partner, rf_spec, send_bill_to_address, show_checkout_experience, sold_to_address, spend_cap, tax_id, tax_id_status, tax_id_type, timezone_id, timezone_name, timezone_offset_hours_utc, tos_accepted, user_access_expire_time, user_tasks, user_tos_accepted, viewable_business
	user_get_personal_ad_accountsTool := mcp.NewTool("user_get_personal_ad_accounts",
		mcp.WithDescription("GET personal_ad_accounts for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccount objects. Available fields: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state (and 58 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_personal_ad_accountsTool)

	// user_get_photos tool
	// Available fields for Photo: album, alt_text, alt_text_custom, backdated_time, backdated_time_granularity, can_backdate, can_delete, can_tag, created_time, event, from, height, icon, id, images, link, name, name_tags, page_story_id, picture, place, position, source, target, updated_time, webp_images, width
	// Params object accepts: type (userphotos_type_enum_param)
	user_get_photosTool := mcp.NewTool("user_get_photos",
		mcp.WithDescription("GET photos for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"tagged", "uploaded"},
				},
			}),
			mcp.Description("Parameters object containing: type (enum) [tagged, uploaded]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Photo objects. Available fields: album, alt_text, alt_text_custom, backdated_time, backdated_time_granularity, can_backdate, can_delete, can_tag, created_time, event, from, height, icon, id, images (and 12 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_photosTool)

	// user_post_photos tool
	// Params object accepts: aid (string), allow_spherical_photo (bool), alt_text_custom (string), android_key_hash (string), application_id (string), attempt (unsigned int), audience_exp (bool), backdated_time (datetime), backdated_time_granularity (userphotos_backdated_time_granularity_enum_param), caption (string), composer_session_id (string), direct_share_status (unsigned int), feed_targeting (Object), filter_type (unsigned int), full_res_is_coming_later (bool), initial_view_heading_override_degrees (unsigned int), initial_view_pitch_override_degrees (unsigned int), initial_view_vertical_fov_override_degrees (unsigned int), ios_bundle_id (string), is_explicit_location (bool), is_explicit_place (bool), manual_privacy (bool), message (string), name (string), no_story (bool), offline_id (unsigned int), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_set_profile_badge (bool), og_suggestion_mechanism (string), place (Object), privacy (string), profile_id (int), provenance_info (map), proxied_app_id (string), published (bool), qn (string), scheduled_publish_time (unsigned int), spherical_metadata (map), sponsor_id (string), sponsor_relationship (unsigned int), tags (list<Object>), target_id (int), targeting (Object), time_since_original_post (unsigned int), uid (int), unpublished_content_type (userphotos_unpublished_content_type_enum_param), url (string), user_selected_tags (bool), vault_image_id (string)
	user_post_photosTool := mcp.NewTool("user_post_photos",
		mcp.WithDescription("POST photos for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"aid": map[string]any{
					"type":        "string",
					"description": "aid parameter",
				},
				"allow_spherical_photo": map[string]any{
					"type":        "boolean",
					"description": "allow_spherical_photo parameter",
				},
				"alt_text_custom": map[string]any{
					"type":        "string",
					"description": "alt_text_custom parameter",
				},
				"android_key_hash": map[string]any{
					"type":        "string",
					"description": "android_key_hash parameter",
				},
				"application_id": map[string]any{
					"type":        "string",
					"description": "application_id parameter",
				},
				"attempt": map[string]any{
					"type":        "integer",
					"description": "attempt parameter",
				},
				"audience_exp": map[string]any{
					"type":        "boolean",
					"description": "audience_exp parameter",
				},
				"backdated_time": map[string]any{
					"type":        "string",
					"description": "backdated_time parameter",
				},
				"backdated_time_granularity": map[string]any{
					"type":        "string",
					"description": "backdated_time_granularity parameter",
					"enum":        []string{"day", "hour", "min", "month", "none", "year"},
				},
				"caption": map[string]any{
					"type":        "string",
					"description": "caption parameter",
				},
				"composer_session_id": map[string]any{
					"type":        "string",
					"description": "composer_session_id parameter",
				},
				"direct_share_status": map[string]any{
					"type":        "integer",
					"description": "direct_share_status parameter",
				},
				"feed_targeting": map[string]any{
					"type":        "object",
					"description": "feed_targeting parameter",
				},
				"filter_type": map[string]any{
					"type":        "integer",
					"description": "filter_type parameter",
				},
				"full_res_is_coming_later": map[string]any{
					"type":        "boolean",
					"description": "full_res_is_coming_later parameter",
				},
				"initial_view_heading_override_degrees": map[string]any{
					"type":        "integer",
					"description": "initial_view_heading_override_degrees parameter",
				},
				"initial_view_pitch_override_degrees": map[string]any{
					"type":        "integer",
					"description": "initial_view_pitch_override_degrees parameter",
				},
				"initial_view_vertical_fov_override_degrees": map[string]any{
					"type":        "integer",
					"description": "initial_view_vertical_fov_override_degrees parameter",
				},
				"ios_bundle_id": map[string]any{
					"type":        "string",
					"description": "ios_bundle_id parameter",
				},
				"is_explicit_location": map[string]any{
					"type":        "boolean",
					"description": "is_explicit_location parameter",
				},
				"is_explicit_place": map[string]any{
					"type":        "boolean",
					"description": "is_explicit_place parameter",
				},
				"manual_privacy": map[string]any{
					"type":        "boolean",
					"description": "manual_privacy parameter",
				},
				"message": map[string]any{
					"type":        "string",
					"description": "message parameter",
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"no_story": map[string]any{
					"type":        "boolean",
					"description": "no_story parameter",
				},
				"offline_id": map[string]any{
					"type":        "integer",
					"description": "offline_id parameter",
				},
				"og_action_type_id": map[string]any{
					"type":        "string",
					"description": "og_action_type_id parameter",
				},
				"og_icon_id": map[string]any{
					"type":        "string",
					"description": "og_icon_id parameter",
				},
				"og_object_id": map[string]any{
					"type":        "string",
					"description": "og_object_id parameter",
				},
				"og_phrase": map[string]any{
					"type":        "string",
					"description": "og_phrase parameter",
				},
				"og_set_profile_badge": map[string]any{
					"type":        "boolean",
					"description": "og_set_profile_badge parameter",
				},
				"og_suggestion_mechanism": map[string]any{
					"type":        "string",
					"description": "og_suggestion_mechanism parameter",
				},
				"place": map[string]any{
					"type":        "object",
					"description": "place parameter",
				},
				"privacy": map[string]any{
					"type":        "string",
					"description": "privacy parameter",
				},
				"profile_id": map[string]any{
					"type":        "integer",
					"description": "profile_id parameter",
				},
				"provenance_info": map[string]any{
					"type":        "object",
					"description": "provenance_info parameter",
				},
				"proxied_app_id": map[string]any{
					"type":        "string",
					"description": "proxied_app_id parameter",
				},
				"published": map[string]any{
					"type":        "boolean",
					"description": "published parameter",
				},
				"qn": map[string]any{
					"type":        "string",
					"description": "qn parameter",
				},
				"scheduled_publish_time": map[string]any{
					"type":        "integer",
					"description": "scheduled_publish_time parameter",
				},
				"spherical_metadata": map[string]any{
					"type":        "object",
					"description": "spherical_metadata parameter",
				},
				"sponsor_id": map[string]any{
					"type":        "string",
					"description": "sponsor_id parameter",
				},
				"sponsor_relationship": map[string]any{
					"type":        "integer",
					"description": "sponsor_relationship parameter",
				},
				"tags": map[string]any{
					"type":        "array",
					"description": "tags parameter",
					"items":       map[string]any{"type": "object"},
				},
				"target_id": map[string]any{
					"type":        "integer",
					"description": "target_id parameter",
				},
				"targeting": map[string]any{
					"type":        "object",
					"description": "targeting parameter",
				},
				"time_since_original_post": map[string]any{
					"type":        "integer",
					"description": "time_since_original_post parameter",
				},
				"uid": map[string]any{
					"type":        "integer",
					"description": "uid parameter",
				},
				"unpublished_content_type": map[string]any{
					"type":        "string",
					"description": "unpublished_content_type parameter",
					"enum":        []string{"ADS_POST", "DRAFT", "INLINE_CREATED", "PUBLISHED", "REVIEWABLE_BRANDED_CONTENT", "SCHEDULED", "SCHEDULED_RECURRING"},
				},
				"url": map[string]any{
					"type":        "string",
					"description": "url parameter",
				},
				"user_selected_tags": map[string]any{
					"type":        "boolean",
					"description": "user_selected_tags parameter",
				},
				"vault_image_id": map[string]any{
					"type":        "string",
					"description": "vault_image_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: aid (string), allow_spherical_photo (boolean), alt_text_custom (string), android_key_hash (string), application_id (string), attempt (integer), audience_exp (boolean), backdated_time (datetime), backdated_time_granularity (enum) [day, hour, min, month, none, ...], caption (string), composer_session_id (string), direct_share_status (integer), feed_targeting (object), filter_type (integer), full_res_is_coming_later (boolean), initial_view_heading_override_degrees (integer), initial_view_pitch_override_degrees (integer), initial_view_vertical_fov_override_degrees (integer), ios_bundle_id (string), is_explicit_location (boolean), is_explicit_place (boolean), manual_privacy (boolean), message (string), name (string), no_story (boolean), offline_id (integer), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_set_profile_badge (boolean), og_suggestion_mechanism (string), place (object), privacy (string), profile_id (integer), provenance_info (object), proxied_app_id (string), published (boolean), qn (string), scheduled_publish_time (integer), spherical_metadata (object), sponsor_id (string), sponsor_relationship (integer), tags (array<object>), target_id (integer), targeting (object), time_since_original_post (integer), uid (integer), unpublished_content_type (enum) [ADS_POST, DRAFT, INLINE_CREATED, PUBLISHED, REVIEWABLE_BRANDED_CONTENT, ...], url (string), user_selected_tags (boolean), vault_image_id (string)"),
		),
	)
	tools = append(tools, user_post_photosTool)

	// user_get_picture tool
	// Available fields for ProfilePictureSource: bottom, cache_key, height, is_silhouette, left, right, top, url, width
	// Params object accepts: height (int), redirect (bool), type (userpicture_type_enum_param), width (int)
	user_get_pictureTool := mcp.NewTool("user_get_picture",
		mcp.WithDescription("GET picture for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"height": map[string]any{
					"type":        "integer",
					"description": "height parameter",
				},
				"redirect": map[string]any{
					"type":        "boolean",
					"description": "redirect parameter",
				},
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"album", "large", "normal", "small", "square"},
				},
				"width": map[string]any{
					"type":        "integer",
					"description": "width parameter",
				},
			}),
			mcp.Description("Parameters object containing: height (integer), redirect (boolean), type (enum) [album, large, normal, small, square], width (integer)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ProfilePictureSource objects. Available fields: bottom, cache_key, height, is_silhouette, left, right, top, url, width"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_pictureTool)

	// user_get_posts tool
	// Available fields for Post: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, caption, child_attachments, comments_mirroring_domain, coordinates, created_time, description, event, expanded_height, expanded_width, feed_targeting, from, full_picture, height, icon, id, instagram_eligibility, is_app_share, is_eligible_for_promotion, is_expired, is_hidden, is_inline_created, is_instagram_eligible, is_popular, is_published, is_spherical, link, message, message_tags, multi_share_end_card, multi_share_optimized, name, object_id, parent_id, permalink_url, picture, place, privacy, promotable_id, promotion_status, properties, scheduled_publish_time, shares, source, status_type, story, story_tags, subscribed, target, targeting, timeline_visibility, type, updated_time, via, video_buying_eligibility, width
	// Params object accepts: include_hidden (bool), q (string), show_expired (bool), since (datetime), until (datetime), with (string)
	user_get_postsTool := mcp.NewTool("user_get_posts",
		mcp.WithDescription("GET posts for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"include_hidden": map[string]any{
					"type":        "boolean",
					"description": "include_hidden parameter",
				},
				"q": map[string]any{
					"type":        "string",
					"description": "q parameter",
				},
				"show_expired": map[string]any{
					"type":        "boolean",
					"description": "show_expired parameter",
				},
				"since": map[string]any{
					"type":        "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type":        "string",
					"description": "until parameter",
				},
				"with": map[string]any{
					"type":        "string",
					"description": "with parameter",
				},
			}),
			mcp.Description("Parameters object containing: include_hidden (boolean), q (string), show_expired (boolean), since (datetime), until (datetime), with (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Post objects. Available fields: actions, admin_creator, allowed_advertising_objectives, application, backdated_time, call_to_action, can_reply_privately, caption, child_attachments, comments_mirroring_domain, coordinates, created_time, description, event, expanded_height (and 47 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_postsTool)

	// user_get_rich_media_documents tool
	// Available fields for Canvas: background_color, body_elements, business_id, canvas_link, collection_hero_image, collection_hero_video, collection_thumbnails, dynamic_setting, element_payload, elements, fb_body_elements, id, is_hidden, is_published, last_editor, linked_documents, name, owner, property_list, source_template, store_url, style_list, tags, ui_property_list, unused_body_elements, update_time, use_retailer_item_ids
	// Params object accepts: query (string)
	user_get_rich_media_documentsTool := mcp.NewTool("user_get_rich_media_documents",
		mcp.WithDescription("GET rich_media_documents for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"query": map[string]any{
					"type":        "string",
					"description": "query parameter",
				},
			}),
			mcp.Description("Parameters object containing: query (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Canvas objects. Available fields: background_color, body_elements, business_id, canvas_link, collection_hero_image, collection_hero_video, collection_thumbnails, dynamic_setting, element_payload, elements, fb_body_elements, id, is_hidden, is_published, last_editor (and 12 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_rich_media_documentsTool)

	// user_post_staging_resources tool
	// Params object accepts: file (file)
	user_post_staging_resourcesTool := mcp.NewTool("user_post_staging_resources",
		mcp.WithDescription("POST staging_resources for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"file": map[string]any{
					"type":        "string",
					"description": "file parameter",
				},
			}),
			mcp.Description("Parameters object containing: file (file)"),
		),
	)
	tools = append(tools, user_post_staging_resourcesTool)

	// user_get_videos tool
	// Available fields for AdVideo: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html, embeddable, event, expiration, format, from, icon, id, is_crosspost_video, is_crossposting_eligible, is_episode, is_instagram_eligible, is_reference_only, length, live_audience_count, live_status, music_video_copyright, permalink_url, picture, place, post_id, post_views, premiere_living_room_status, privacy, published, scheduled_publish_time, source, spherical, status, title, universal_video_id, updated_time, views
	// Params object accepts: type (uservideos_type_enum_param)
	user_get_videosTool := mcp.NewTool("user_get_videos",
		mcp.WithDescription("GET videos for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"type": map[string]any{
					"type":        "string",
					"description": "type parameter",
					"enum":        []string{"TAGGED", "UPLOADED"},
				},
			}),
			mcp.Description("Parameters object containing: type (enum) [TAGGED, UPLOADED]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdVideo objects. Available fields: ad_breaks, admin_creator, audio_isrc, backdated_time, backdated_time_granularity, boost_eligibility_info, content_category, content_tags, copyright, copyright_check_information, copyright_monitoring_status, created_time, custom_labels, description, embed_html (and 32 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_videosTool)

	// user_post_videos tool
	// Params object accepts: application_id (string), asked_fun_fact_prompt_id (unsigned int), audio_story_wave_animation_handle (string), composer_entry_picker (string), composer_entry_point (string), composer_entry_time (unsigned int), composer_session_events_log (string), composer_session_id (string), composer_source_surface (string), composer_type (string), container_type (uservideos_container_type_enum_param), content_category (uservideos_content_category_enum_param), creative_tools (string), description (string), direct_share_status (unsigned int), embeddable (bool), end_offset (unsigned int), fbuploader_video_file_chunk (string), file_size (unsigned int), file_url (string), fisheye_video_cropped (bool), formatting (uservideos_formatting_enum_param), fov (unsigned int), front_z_rotation (float), fun_fact_prompt_id (string), fun_fact_toastee_id (unsigned int), guide (list<list<unsigned int>>), guide_enabled (bool), initial_heading (unsigned int), initial_pitch (unsigned int), instant_game_entry_point_data (string), is_boost_intended (bool), is_explicit_share (bool), is_group_linking_post (bool), is_partnership_ad (bool), is_voice_clip (bool), location_source_id (string), manual_privacy (bool), no_story (bool), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_suggestion_mechanism (string), original_fov (unsigned int), original_projection_type (uservideos_original_projection_type_enum_param), partnership_ad_ad_code (string), privacy (string), publish_event_id (unsigned int), referenced_sticker_id (string), replace_video_id (string), slideshow_spec (map), source (string), source_instagram_media_id (string), spherical (bool), sponsor_id (string), start_offset (unsigned int), swap_mode (uservideos_swap_mode_enum_param), text_format_metadata (string), thumb (file), time_since_original_post (unsigned int), title (string), transcode_setting_properties (string), unpublished_content_type (uservideos_unpublished_content_type_enum_param), upload_phase (uservideos_upload_phase_enum_param), upload_session_id (string), upload_setting_properties (string), video_file_chunk (string), video_id_original (string), video_start_time_ms (unsigned int), waterfall_id (string)
	user_post_videosTool := mcp.NewTool("user_post_videos",
		mcp.WithDescription("POST videos for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"application_id": map[string]any{
					"type":        "string",
					"description": "application_id parameter",
				},
				"asked_fun_fact_prompt_id": map[string]any{
					"type":        "integer",
					"description": "asked_fun_fact_prompt_id parameter",
				},
				"audio_story_wave_animation_handle": map[string]any{
					"type":        "string",
					"description": "audio_story_wave_animation_handle parameter",
				},
				"composer_entry_picker": map[string]any{
					"type":        "string",
					"description": "composer_entry_picker parameter",
				},
				"composer_entry_point": map[string]any{
					"type":        "string",
					"description": "composer_entry_point parameter",
				},
				"composer_entry_time": map[string]any{
					"type":        "integer",
					"description": "composer_entry_time parameter",
				},
				"composer_session_events_log": map[string]any{
					"type":        "string",
					"description": "composer_session_events_log parameter",
				},
				"composer_session_id": map[string]any{
					"type":        "string",
					"description": "composer_session_id parameter",
				},
				"composer_source_surface": map[string]any{
					"type":        "string",
					"description": "composer_source_surface parameter",
				},
				"composer_type": map[string]any{
					"type":        "string",
					"description": "composer_type parameter",
				},
				"container_type": map[string]any{
					"type":        "string",
					"description": "container_type parameter",
					"enum":        []string{"ACO_VIDEO_VARIATION", "ADS_AI_GENERATED", "AD_BREAK_PREVIEW", "AD_DERIVATIVE", "AD_LIBRARY_WATERMARK", "ALBUM_MULTIMEDIA_POST", "ALOHA_SUPERFRAME", "APP_REREVIEW_SCREENCAST", "APP_REVIEW_SCREENCAST", "ASSET_MANAGER", "ATLAS_VIDEO", "AUDIO_BROADCAST", "AUDIO_COMMENT", "BROADCAST", "CANVAS", "CMS_MEDIA_MANAGER", "CONTAINED_POST_ATTACHMENT", "CONTAINED_POST_AUDIO_BROADCAST", "CONTAINED_POST_COPYRIGHT_REFERENCE_BROADCAST", "COPYRIGHT_REFERENCE_BROADCAST", "COPYRIGHT_REFERENCE_IG_XPOST_VIDEO", "COPYRIGHT_REFERENCE_VIDEO", "CREATION_ML_PRECREATION", "CREATOR_FAN_CHALLENGE", "CREATOR_STOREFRONT_PERSONALIZED_VIDEO", "DATAGENIX_VIDEO", "DCO_AD_ASSET_FEED", "DCO_AUTOGEN_VIDEO", "DCO_TRIMMED_VIDEO", "DIM_SUM", "DIRECTED_POST_ATTACHMENT", "DIRECT_INBOX", "DROPS_SHOPPING_EVENT_PAGE", "DYNAMIC_ITEM_VIDEO", "DYNAMIC_TEMPLATE_VIDEO", "EVENT_COVER_VIDEO", "EVENT_TOUR", "FACECAST_DVR", "FB_AVATAR_ANIMATED_SATP", "FB_COLLECTIBLE_VIDEO", "FB_SHORTS", "FB_SHORTS_CONTENT_REMIXABLE", "FB_SHORTS_GROUP_POST", "FB_SHORTS_LINKED_PRODUCT", "FB_SHORTS_PMV_POST", "FB_SHORTS_POST", "FB_SHORTS_REMIX_POST", "FUNDRAISER_COVER_VIDEO", "GAME_CLIP", "GIF_TO_VIDEO", "GOODWILL_ANNIVERSARY_DEPRECATED", "GOODWILL_ANNIVERSARY_PROMOTION_DEPRECATED", "GOODWILL_VIDEO_CONTAINED_SHARE", "GOODWILL_VIDEO_PROMOTION", "GOODWILL_VIDEO_SHARE", "GOODWILL_VIDEO_TOKEN_REQUIRED", "GROUP_POST", "HEURISTIC_CLUSTER_VIDEO", "HIGHLIGHT_CLIP_VIDEO", "HORIZON_WORLDS_TV", "HUDDLE_BROADCAST", "IG_REELS_XPV", "IG_STORIES_READER", "INJECTABLE", "INSPIRATION_VIDEO", "INSTAGRAM_VIDEO_COPY", "INSTANT_APPLICATION_PREVIEW", "INSTANT_ARTICLE", "ISSUE_MODULE", "LEARN", "LEGACY", "LEGACY_CONTAINED_POST_BROADCAST", "LIVE_AUDIO_ROOM_BROADCAST", "LIVE_CLIP_PREVIEW", "LIVE_CLIP_WORKCHAT", "LIVE_CREATIVE_KIT_VIDEO", "LIVE_PHOTO", "LOOK_NOW_DEPRECATED", "MARKETPLACE_LISTING_VIDEO", "MARKETPLACE_PRE_RECORDED_VIDEO", "MOMENTS_VIDEO", "MUSIC_CLIP", "MUSIC_CLIP_IN_COMMENT", "MUSIC_CLIP_IN_LIGHTWEIGHT_STATUS", "MUSIC_CLIP_IN_MSGR_NOTE", "MUSIC_CLIP_IN_POLL_OPTION", "MUSIC_CLIP_ON_DATING_PROFILE", "NEO_ASYNC_GAME_VIDEO", "NEW_CONTAINED_POST_BROADCAST", "NO_STORY", "OCULUS_CREATOR_PORTAL", "OCULUS_VENUES_BROADCAST", "ORIGINALITY_SELF_ADVOCACY", "PAGES_COVER_VIDEO", "PAGE_REVIEW_SCREENCAST", "PAGE_SLIDESHOW_VIDEO", "PAID_CONTENT_PREVIEW", "PAID_CONTENT_VIDEO", "PAID_CONTENT_VIDEO__POST", "PIXELCLOUD", "PODCAST_HIGHLIGHT", "PODCAST_ML_PREVIEW", "PODCAST_ML_PREVIEW_NO_NEWSFEED_STORY", "PODCAST_RSS", "PODCAST_RSS_EPHEMERAL", "PODCAST_RSS_NO_NEWSFEED_STORY", "PODCAST_VOICES", "PODCAST_VOICES_NO_NEWSFEED_STORY", "PREMIERE_SOURCE", "PREMIUM_MUSIC_VIDEO_CLIP", "PREMIUM_MUSIC_VIDEO_CROPPED_CLIP", "PREMIUM_MUSIC_VIDEO_NO_NEWSFEED_STORY", "PREMIUM_MUSIC_VIDEO_WITH_NEWSFEED_STORY", "PRIVATE_GALLERY_VIDEO", "PRODUCT_VIDEO", "PROFILE_COVER_VIDEO", "PROFILE_INTRO_CARD", "PROFILE_VIDEO", "PROTON", "QUICK_CLIP_WORKPLACE_POST", "QUICK_PROMOTION", "REPLACE_VIDEO", "SALES_CLIENT_INTERACTION", "SHOWREEL_NATIVE_DUMMY_VIDEO", "SLIDESHOW_ANIMOTO", "SLIDESHOW_SHAKR", "SLIDESHOW_VARIATION_VIDEO", "SOUND_PLATFORM_STREAM", "SRT_ATTACHMENT", "STORIES_VIDEO", "STORYLINE", "STORYLINE_WITH_EXTERNAL_MUSIC", "STORY_ARCHIVE_VIDEO", "STORY_CARD_TEMPLATE", "STREAM_HIGHLIGHTS_VIDEO", "TAROT_DIGEST", "TEMPORARY_UNLISTED", "TEMP_VIDEO_COPYRIGHT_SCAN", "UNLISTED", "UNLISTED_OCULUS", "VIDEO_COMMENT", "VIDEO_COMPOSITION_VARIATION", "VIDEO_CREATIVE_EDITOR_AUTOGEN_AD_VIDEO", "VIDEO_SUPERRES", "VOICES_ARTICLE_VIDEO", "VU_GENERATED_VIDEO", "WOODHENGE", "WORK_KNOWLEDGE_VIDEO", "YOUR_DAY"},
				},
				"content_category": map[string]any{
					"type":        "string",
					"description": "content_category parameter",
					"enum":        []string{"BEAUTY_FASHION", "BUSINESS", "CARS_TRUCKS", "COMEDY", "CUTE_ANIMALS", "ENTERTAINMENT", "FAMILY", "FOOD_HEALTH", "HOME", "LIFESTYLE", "MUSIC", "NEWS", "OTHER", "POLITICS", "SCIENCE", "SPORTS", "TECHNOLOGY", "VIDEO_GAMING"},
				},
				"creative_tools": map[string]any{
					"type":        "string",
					"description": "creative_tools parameter",
				},
				"description": map[string]any{
					"type":        "string",
					"description": "description parameter",
				},
				"direct_share_status": map[string]any{
					"type":        "integer",
					"description": "direct_share_status parameter",
				},
				"embeddable": map[string]any{
					"type":        "boolean",
					"description": "embeddable parameter",
				},
				"end_offset": map[string]any{
					"type":        "integer",
					"description": "end_offset parameter",
				},
				"fbuploader_video_file_chunk": map[string]any{
					"type":        "string",
					"description": "fbuploader_video_file_chunk parameter",
				},
				"file_size": map[string]any{
					"type":        "integer",
					"description": "file_size parameter",
				},
				"file_url": map[string]any{
					"type":        "string",
					"description": "file_url parameter",
				},
				"fisheye_video_cropped": map[string]any{
					"type":        "boolean",
					"description": "fisheye_video_cropped parameter",
				},
				"formatting": map[string]any{
					"type":        "string",
					"description": "formatting parameter",
					"enum":        []string{"MARKDOWN", "PLAINTEXT"},
				},
				"fov": map[string]any{
					"type":        "integer",
					"description": "fov parameter",
				},
				"front_z_rotation": map[string]any{
					"type":        "number",
					"description": "front_z_rotation parameter",
				},
				"fun_fact_prompt_id": map[string]any{
					"type":        "string",
					"description": "fun_fact_prompt_id parameter",
				},
				"fun_fact_toastee_id": map[string]any{
					"type":        "integer",
					"description": "fun_fact_toastee_id parameter",
				},
				"guide": map[string]any{
					"type":        "array",
					"description": "guide parameter",
					"items":       map[string]any{"type": "array"},
				},
				"guide_enabled": map[string]any{
					"type":        "boolean",
					"description": "guide_enabled parameter",
				},
				"initial_heading": map[string]any{
					"type":        "integer",
					"description": "initial_heading parameter",
				},
				"initial_pitch": map[string]any{
					"type":        "integer",
					"description": "initial_pitch parameter",
				},
				"instant_game_entry_point_data": map[string]any{
					"type":        "string",
					"description": "instant_game_entry_point_data parameter",
				},
				"is_boost_intended": map[string]any{
					"type":        "boolean",
					"description": "is_boost_intended parameter",
				},
				"is_explicit_share": map[string]any{
					"type":        "boolean",
					"description": "is_explicit_share parameter",
				},
				"is_group_linking_post": map[string]any{
					"type":        "boolean",
					"description": "is_group_linking_post parameter",
				},
				"is_partnership_ad": map[string]any{
					"type":        "boolean",
					"description": "is_partnership_ad parameter",
				},
				"is_voice_clip": map[string]any{
					"type":        "boolean",
					"description": "is_voice_clip parameter",
				},
				"location_source_id": map[string]any{
					"type":        "string",
					"description": "location_source_id parameter",
				},
				"manual_privacy": map[string]any{
					"type":        "boolean",
					"description": "manual_privacy parameter",
				},
				"no_story": map[string]any{
					"type":        "boolean",
					"description": "no_story parameter",
				},
				"og_action_type_id": map[string]any{
					"type":        "string",
					"description": "og_action_type_id parameter",
				},
				"og_icon_id": map[string]any{
					"type":        "string",
					"description": "og_icon_id parameter",
				},
				"og_object_id": map[string]any{
					"type":        "string",
					"description": "og_object_id parameter",
				},
				"og_phrase": map[string]any{
					"type":        "string",
					"description": "og_phrase parameter",
				},
				"og_suggestion_mechanism": map[string]any{
					"type":        "string",
					"description": "og_suggestion_mechanism parameter",
				},
				"original_fov": map[string]any{
					"type":        "integer",
					"description": "original_fov parameter",
				},
				"original_projection_type": map[string]any{
					"type":        "string",
					"description": "original_projection_type parameter",
					"enum":        []string{"cubemap", "equirectangular", "half_equirectangular"},
				},
				"partnership_ad_ad_code": map[string]any{
					"type":        "string",
					"description": "partnership_ad_ad_code parameter",
				},
				"privacy": map[string]any{
					"type":        "string",
					"description": "privacy parameter",
				},
				"publish_event_id": map[string]any{
					"type":        "integer",
					"description": "publish_event_id parameter",
				},
				"referenced_sticker_id": map[string]any{
					"type":        "string",
					"description": "referenced_sticker_id parameter",
				},
				"replace_video_id": map[string]any{
					"type":        "string",
					"description": "replace_video_id parameter",
				},
				"slideshow_spec": map[string]any{
					"type":        "object",
					"description": "slideshow_spec parameter",
				},
				"source": map[string]any{
					"type":        "string",
					"description": "source parameter",
				},
				"source_instagram_media_id": map[string]any{
					"type":        "string",
					"description": "source_instagram_media_id parameter",
				},
				"spherical": map[string]any{
					"type":        "boolean",
					"description": "spherical parameter",
				},
				"sponsor_id": map[string]any{
					"type":        "string",
					"description": "sponsor_id parameter",
				},
				"start_offset": map[string]any{
					"type":        "integer",
					"description": "start_offset parameter",
				},
				"swap_mode": map[string]any{
					"type":        "string",
					"description": "swap_mode parameter",
					"enum":        []string{"replace"},
				},
				"text_format_metadata": map[string]any{
					"type":        "string",
					"description": "text_format_metadata parameter",
				},
				"thumb": map[string]any{
					"type":        "string",
					"description": "thumb parameter",
				},
				"time_since_original_post": map[string]any{
					"type":        "integer",
					"description": "time_since_original_post parameter",
				},
				"title": map[string]any{
					"type":        "string",
					"description": "title parameter",
				},
				"transcode_setting_properties": map[string]any{
					"type":        "string",
					"description": "transcode_setting_properties parameter",
				},
				"unpublished_content_type": map[string]any{
					"type":        "string",
					"description": "unpublished_content_type parameter",
					"enum":        []string{"ADS_POST", "DRAFT", "INLINE_CREATED", "PUBLISHED", "REVIEWABLE_BRANDED_CONTENT", "SCHEDULED", "SCHEDULED_RECURRING"},
				},
				"upload_phase": map[string]any{
					"type":        "string",
					"description": "upload_phase parameter",
					"enum":        []string{"cancel", "finish", "start", "transfer"},
				},
				"upload_session_id": map[string]any{
					"type":        "string",
					"description": "upload_session_id parameter",
				},
				"upload_setting_properties": map[string]any{
					"type":        "string",
					"description": "upload_setting_properties parameter",
				},
				"video_file_chunk": map[string]any{
					"type":        "string",
					"description": "video_file_chunk parameter",
				},
				"video_id_original": map[string]any{
					"type":        "string",
					"description": "video_id_original parameter",
				},
				"video_start_time_ms": map[string]any{
					"type":        "integer",
					"description": "video_start_time_ms parameter",
				},
				"waterfall_id": map[string]any{
					"type":        "string",
					"description": "waterfall_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: application_id (string), asked_fun_fact_prompt_id (integer), audio_story_wave_animation_handle (string), composer_entry_picker (string), composer_entry_point (string), composer_entry_time (integer), composer_session_events_log (string), composer_session_id (string), composer_source_surface (string), composer_type (string), container_type (enum) [ACO_VIDEO_VARIATION, ADS_AI_GENERATED, AD_BREAK_PREVIEW, AD_DERIVATIVE, AD_LIBRARY_WATERMARK, ...], content_category (enum) [BEAUTY_FASHION, BUSINESS, CARS_TRUCKS, COMEDY, CUTE_ANIMALS, ...], creative_tools (string), description (string), direct_share_status (integer), embeddable (boolean), end_offset (integer), fbuploader_video_file_chunk (string), file_size (integer), file_url (string), fisheye_video_cropped (boolean), formatting (enum) [MARKDOWN, PLAINTEXT], fov (integer), front_z_rotation (number), fun_fact_prompt_id (string), fun_fact_toastee_id (integer), guide (array<array<integer>>), guide_enabled (boolean), initial_heading (integer), initial_pitch (integer), instant_game_entry_point_data (string), is_boost_intended (boolean), is_explicit_share (boolean), is_group_linking_post (boolean), is_partnership_ad (boolean), is_voice_clip (boolean), location_source_id (string), manual_privacy (boolean), no_story (boolean), og_action_type_id (string), og_icon_id (string), og_object_id (string), og_phrase (string), og_suggestion_mechanism (string), original_fov (integer), original_projection_type (enum) [cubemap, equirectangular, half_equirectangular], partnership_ad_ad_code (string), privacy (string), publish_event_id (integer), referenced_sticker_id (string), replace_video_id (string), slideshow_spec (object), source (string), source_instagram_media_id (string), spherical (boolean), sponsor_id (string), start_offset (integer), swap_mode (enum) [replace], text_format_metadata (string), thumb (file), time_since_original_post (integer), title (string), transcode_setting_properties (string), unpublished_content_type (enum) [ADS_POST, DRAFT, INLINE_CREATED, PUBLISHED, REVIEWABLE_BRANDED_CONTENT, ...], upload_phase (enum) [cancel, finish, start, transfer], upload_session_id (string), upload_setting_properties (string), video_file_chunk (string), video_id_original (string), video_start_time_ms (integer), waterfall_id (string)"),
		),
	)
	tools = append(tools, user_post_videosTool)

	// user_delete_ tool
	user_delete_Tool := mcp.NewTool("user_delete_",
		mcp.WithDescription("DELETE  for User"),
	)
	tools = append(tools, user_delete_Tool)

	// user_get_ tool
	// Available fields for User: about, age_range, avatar_2d_profile_picture, birthday, client_business_id, community, cover, currency, education, email, favorite_athletes, favorite_teams, first_name, gender, hometown, id, id_for_avatars, inspirational_people, install_type, installed, is_guest_user, is_work_account, languages, last_name, link, local_news_megaphone_dismiss_status, local_news_subscription_status, locale, location, meeting_for, middle_name, name, name_format, payment_pricepoints, political, profile_pic, quotes, relationship_status, religion, shared_login_upgrade_required_by, short_name, significant_other, sports, supports_donate_button_in_live_video, third_party_id, timezone, token_for_business, updated_time, verified, video_upload_limits, website
	user_get_Tool := mcp.NewTool("user_get_",
		mcp.WithDescription("GET  for User"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for User objects. Available fields: about, age_range, avatar_2d_profile_picture, birthday, client_business_id, community, cover, currency, education, email, favorite_athletes, favorite_teams, first_name, gender, hometown (and 36 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, user_get_Tool)

	// user_post_ tool
	// Params object accepts: emoji_color_pref (unsigned int), firstname (string), lastname (string), local_news_megaphone_dismiss_status (user_local_news_megaphone_dismiss_status), local_news_subscription_status (user_local_news_subscription_status), name (string), password (string)
	user_post_Tool := mcp.NewTool("user_post_",
		mcp.WithDescription("POST  for User"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"emoji_color_pref": map[string]any{
					"type":        "integer",
					"description": "emoji_color_pref parameter",
				},
				"firstname": map[string]any{
					"type":        "string",
					"description": "firstname parameter",
				},
				"lastname": map[string]any{
					"type":        "string",
					"description": "lastname parameter",
				},
				"local_news_megaphone_dismiss_status": map[string]any{
					"type":        "string",
					"description": "local_news_megaphone_dismiss_status parameter",
					"enum":        []string{"NO", "YES"},
				},
				"local_news_subscription_status": map[string]any{
					"type":        "string",
					"description": "local_news_subscription_status parameter",
					"enum":        []string{"STATUS_OFF", "STATUS_ON"},
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"password": map[string]any{
					"type":        "string",
					"description": "password parameter",
				},
			}),
			mcp.Description("Parameters object containing: emoji_color_pref (integer), firstname (string), lastname (string), local_news_megaphone_dismiss_status (user_local_news_megaphone_dismiss_status) [NO, YES], local_news_subscription_status (user_local_news_subscription_status) [STATUS_OFF, STATUS_ON], name (string), password (string)"),
		),
	)
	tools = append(tools, user_post_Tool)

	return tools
}

// User handlers

// HandleUser_delete_access_tokens handles the user_delete_access_tokens tool with context-based auth
func HandleUser_delete_access_tokens(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.User_delete_access_tokens(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_delete_access_tokens: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_access_tokens handles the user_post_access_tokens tool with context-based auth
func HandleUser_post_access_tokens(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.User_post_access_tokens(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_access_tokens: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_accounts handles the user_get_accounts tool with context-based auth
func HandleUser_get_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_accounts handles the user_post_accounts tool with context-based auth
func HandleUser_post_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.User_post_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_ad_studies handles the user_get_ad_studies tool with context-based auth
func HandleUser_get_ad_studies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_ad_studies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_ad_studies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_ad_studies handles the user_post_ad_studies tool with context-based auth
func HandleUser_post_ad_studies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.User_post_ad_studies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_ad_studies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_adaccounts handles the user_get_adaccounts tool with context-based auth
func HandleUser_get_adaccounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_adaccounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_adaccounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_albums handles the user_get_albums tool with context-based auth
func HandleUser_get_albums(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_albums(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_albums: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_applications handles the user_post_applications tool with context-based auth
func HandleUser_post_applications(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.User_post_applications(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_applications: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_apprequestformerrecipients handles the user_get_apprequestformerrecipients tool with context-based auth
func HandleUser_get_apprequestformerrecipients(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_apprequestformerrecipients(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_apprequestformerrecipients: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_apprequests handles the user_get_apprequests tool with context-based auth
func HandleUser_get_apprequests(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_apprequests(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_apprequests: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_assigned_ad_accounts handles the user_get_assigned_ad_accounts tool with context-based auth
func HandleUser_get_assigned_ad_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_assigned_ad_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_assigned_ad_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_assigned_applications handles the user_get_assigned_applications tool with context-based auth
func HandleUser_get_assigned_applications(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_assigned_applications(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_assigned_applications: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_assigned_business_asset_groups handles the user_get_assigned_business_asset_groups tool with context-based auth
func HandleUser_get_assigned_business_asset_groups(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_assigned_business_asset_groups(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_assigned_business_asset_groups: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_assigned_pages handles the user_get_assigned_pages tool with context-based auth
func HandleUser_get_assigned_pages(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_assigned_pages(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_assigned_pages: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_assigned_product_catalogs handles the user_get_assigned_product_catalogs tool with context-based auth
func HandleUser_get_assigned_product_catalogs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_assigned_product_catalogs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_assigned_product_catalogs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_avatars handles the user_get_avatars tool with context-based auth
func HandleUser_get_avatars(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_avatars(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_avatars: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_business_users handles the user_get_business_users tool with context-based auth
func HandleUser_get_business_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_business_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_business_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_delete_businesses handles the user_delete_businesses tool with context-based auth
func HandleUser_delete_businesses(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.User_delete_businesses(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_delete_businesses: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_businesses handles the user_get_businesses tool with context-based auth
func HandleUser_get_businesses(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_businesses(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_businesses: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_businesses handles the user_post_businesses tool with context-based auth
func HandleUser_post_businesses(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.User_post_businesses(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_businesses: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_conversations handles the user_get_conversations tool with context-based auth
func HandleUser_get_conversations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_conversations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_conversations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_custom_labels handles the user_get_custom_labels tool with context-based auth
func HandleUser_get_custom_labels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_custom_labels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_custom_labels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_events handles the user_get_events tool with context-based auth
func HandleUser_get_events(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_events(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_events: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_feed handles the user_get_feed tool with context-based auth
func HandleUser_get_feed(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_feed(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_feed: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_feed handles the user_post_feed tool with context-based auth
func HandleUser_post_feed(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.User_post_feed(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_feed: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_friends handles the user_get_friends tool with context-based auth
func HandleUser_get_friends(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_friends(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_friends: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_fundraisers handles the user_get_fundraisers tool with context-based auth
func HandleUser_get_fundraisers(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_fundraisers(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_fundraisers: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_fundraisers handles the user_post_fundraisers tool with context-based auth
func HandleUser_post_fundraisers(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.User_post_fundraisers(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_fundraisers: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_groups handles the user_get_groups tool with context-based auth
func HandleUser_get_groups(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_groups(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_groups: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_ids_for_apps handles the user_get_ids_for_apps tool with context-based auth
func HandleUser_get_ids_for_apps(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_ids_for_apps(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_ids_for_apps: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_ids_for_business handles the user_get_ids_for_business tool with context-based auth
func HandleUser_get_ids_for_business(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_ids_for_business(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_ids_for_business: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_ids_for_pages handles the user_get_ids_for_pages tool with context-based auth
func HandleUser_get_ids_for_pages(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_ids_for_pages(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_ids_for_pages: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_likes handles the user_get_likes tool with context-based auth
func HandleUser_get_likes(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_likes(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_likes: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_live_videos handles the user_get_live_videos tool with context-based auth
func HandleUser_get_live_videos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_live_videos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_live_videos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_live_videos handles the user_post_live_videos tool with context-based auth
func HandleUser_post_live_videos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.User_post_live_videos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_live_videos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_messenger_desktop_performance_traces handles the user_post_messenger_desktop_performance_traces tool with context-based auth
func HandleUser_post_messenger_desktop_performance_traces(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.User_post_messenger_desktop_performance_traces(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_messenger_desktop_performance_traces: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_messenger_kids_accounts_unread_badge handles the user_post_messenger_kids_accounts_unread_badge tool with context-based auth
func HandleUser_post_messenger_kids_accounts_unread_badge(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.User_post_messenger_kids_accounts_unread_badge(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_messenger_kids_accounts_unread_badge: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_music handles the user_get_music tool with context-based auth
func HandleUser_get_music(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_music(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_music: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_notifications handles the user_post_notifications tool with context-based auth
func HandleUser_post_notifications(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.User_post_notifications(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_notifications: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_payment_transactions handles the user_get_payment_transactions tool with context-based auth
func HandleUser_get_payment_transactions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_payment_transactions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_payment_transactions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_delete_permissions handles the user_delete_permissions tool with context-based auth
func HandleUser_delete_permissions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.User_delete_permissions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_delete_permissions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_permissions handles the user_get_permissions tool with context-based auth
func HandleUser_get_permissions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_permissions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_permissions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_personal_ad_accounts handles the user_get_personal_ad_accounts tool with context-based auth
func HandleUser_get_personal_ad_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_personal_ad_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_personal_ad_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_photos handles the user_get_photos tool with context-based auth
func HandleUser_get_photos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_photos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_photos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_photos handles the user_post_photos tool with context-based auth
func HandleUser_post_photos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.User_post_photos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_photos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_picture handles the user_get_picture tool with context-based auth
func HandleUser_get_picture(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_picture(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_picture: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_posts handles the user_get_posts tool with context-based auth
func HandleUser_get_posts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_posts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_posts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_rich_media_documents handles the user_get_rich_media_documents tool with context-based auth
func HandleUser_get_rich_media_documents(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_rich_media_documents(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_rich_media_documents: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_staging_resources handles the user_post_staging_resources tool with context-based auth
func HandleUser_post_staging_resources(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.User_post_staging_resources(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_staging_resources: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_videos handles the user_get_videos tool with context-based auth
func HandleUser_get_videos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_videos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_videos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_videos handles the user_post_videos tool with context-based auth
func HandleUser_post_videos(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.User_post_videos(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_videos: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_delete_ handles the user_delete_ tool with context-based auth
func HandleUser_delete_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.User_delete_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_delete_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_get_ handles the user_get_ tool with context-based auth
func HandleUser_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.User_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleUser_post_ handles the user_post_ tool with context-based auth
func HandleUser_post_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.User_post_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute user_post_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}
