// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetAdsPixelTools returns MCP tools for AdsPixel
func GetAdsPixelTools() []mcp.Tool {
	var tools []mcp.Tool

	// adspixel_get_adaccounts tool
	// Available fields for AdAccount: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state, business_street, business_street2, business_zip, can_create_brand_lift_study, capabilities, created_time, currency, custom_audience_info, default_dsa_beneficiary, default_dsa_payor, disable_reason, end_advertiser, end_advertiser_name, existing_customers, expired_funding_source_details, extended_credit_invoice_group, failed_delivery_checks, fb_entity, funding_source, funding_source_details, has_migrated_permissions, has_page_authorized_adaccount, id, io_number, is_attribution_spec_system_default, is_ba_skip_delayed_eligible, is_direct_deals_enabled, is_in_3ds_authorization_enabled_market, is_notifications_enabled, is_personal, is_prepay_account, is_tax_id_required, liable_address, line_numbers, media_agency, min_campaign_group_spend_cap, min_daily_budget, name, offsite_pixels_tos_accepted, owner, owner_business, partner, rf_spec, send_bill_to_address, show_checkout_experience, sold_to_address, spend_cap, tax_id, tax_id_status, tax_id_type, timezone_id, timezone_name, timezone_offset_hours_utc, tos_accepted, user_access_expire_time, user_tasks, user_tos_accepted, viewable_business
	// Params object accepts: business (string)
	adspixel_get_adaccountsTool := mcp.NewTool("adspixel_get_adaccounts",
		mcp.WithDescription("GET adaccounts for AdsPixel"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccount objects. Available fields: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state (and 58 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adspixel_get_adaccountsTool)

	// adspixel_delete_agencies tool
	// Params object accepts: business (string)
	adspixel_delete_agenciesTool := mcp.NewTool("adspixel_delete_agencies",
		mcp.WithDescription("DELETE agencies for AdsPixel"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required]"),
		),
	)
	tools = append(tools, adspixel_delete_agenciesTool)

	// adspixel_get_agencies tool
	// Available fields for Business: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id, two_factor_type, updated_by, updated_time, user_access_expire_time, verification_status, vertical, vertical_id
	adspixel_get_agenciesTool := mcp.NewTool("adspixel_get_agencies",
		mcp.WithDescription("GET agencies for AdsPixel"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Business objects. Available fields: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id (and 7 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adspixel_get_agenciesTool)

	// adspixel_post_agencies tool
	// Params object accepts: business (string), permitted_tasks (list<adspixelagencies_permitted_tasks_enum_param>)
	adspixel_post_agenciesTool := mcp.NewTool("adspixel_post_agencies",
		mcp.WithDescription("POST agencies for AdsPixel"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
					"required":    true,
				},
				"permitted_tasks": map[string]any{
					"type":        "array",
					"description": "permitted_tasks parameter",
					"required":    true,
					"enum":        []string{"ADVERTISE", "ANALYZE", "EDIT", "UPLOAD"},
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required], permitted_tasks (array<enum>) [ADVERTISE, ANALYZE, EDIT, UPLOAD] [required]"),
		),
	)
	tools = append(tools, adspixel_post_agenciesTool)

	// adspixel_post_ahp_configs tool
	// Params object accepts: applink_autosetup (bool)
	adspixel_post_ahp_configsTool := mcp.NewTool("adspixel_post_ahp_configs",
		mcp.WithDescription("POST ahp_configs for AdsPixel"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"applink_autosetup": map[string]any{
					"type":        "boolean",
					"description": "applink_autosetup parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: applink_autosetup (boolean) [required]"),
		),
	)
	tools = append(tools, adspixel_post_ahp_configsTool)

	// adspixel_get_assigned_users tool
	// Available fields for AssignedUser: business, id, name, user_type
	// Params object accepts: business (string)
	adspixel_get_assigned_usersTool := mcp.NewTool("adspixel_get_assigned_users",
		mcp.WithDescription("GET assigned_users for AdsPixel"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AssignedUser objects. Available fields: business, id, name, user_type"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adspixel_get_assigned_usersTool)

	// adspixel_post_assigned_users tool
	// Params object accepts: tasks (list<adspixelassigned_users_tasks_enum_param>), user (int)
	adspixel_post_assigned_usersTool := mcp.NewTool("adspixel_post_assigned_users",
		mcp.WithDescription("POST assigned_users for AdsPixel"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"tasks": map[string]any{
					"type":        "array",
					"description": "tasks parameter",
					"required":    true,
					"enum":        []string{"AA_ANALYZE", "ADVERTISE", "ANALYZE", "EDIT", "UPLOAD"},
					"items":       map[string]any{"type": "string"},
				},
				"user": map[string]any{
					"type":        "integer",
					"description": "user parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: tasks (array<enum>) [AA_ANALYZE, ADVERTISE, ANALYZE, EDIT, UPLOAD] [required], user (integer) [required]"),
		),
	)
	tools = append(tools, adspixel_post_assigned_usersTool)

	// adspixel_get_da_checks tool
	// Available fields for DACheck: action_uri, description, key, result, title, user_message
	// Params object accepts: checks (list<string>), connection_method (adspixelda_checks_connection_method_enum_param)
	adspixel_get_da_checksTool := mcp.NewTool("adspixel_get_da_checks",
		mcp.WithDescription("GET da_checks for AdsPixel"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"checks": map[string]any{
					"type":        "array",
					"description": "checks parameter",
					"items":       map[string]any{"type": "string"},
				},
				"connection_method": map[string]any{
					"type":        "string",
					"description": "connection_method parameter",
					"enum":        []string{"ALL", "APP", "BROWSER", "SERVER"},
				},
			}),
			mcp.Description("Parameters object containing: checks (array<string>), connection_method (enum) [ALL, APP, BROWSER, SERVER]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for DACheck objects. Available fields: action_uri, description, key, result, title, user_message"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adspixel_get_da_checksTool)

	// adspixel_post_events tool
	// Params object accepts: data (list<string>), namespace_id (string), partner_agent (string), platforms (list<map>), progress (Object), test_event_code (string), trace (unsigned int), upload_id (string), upload_source (string), upload_tag (string)
	adspixel_post_eventsTool := mcp.NewTool("adspixel_post_events",
		mcp.WithDescription("POST events for AdsPixel"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"data": map[string]any{
					"type":        "array",
					"description": "data parameter",
					"required":    true,
					"items":       map[string]any{"type": "string"},
				},
				"namespace_id": map[string]any{
					"type":        "string",
					"description": "namespace_id parameter",
				},
				"partner_agent": map[string]any{
					"type":        "string",
					"description": "partner_agent parameter",
				},
				"platforms": map[string]any{
					"type":        "array",
					"description": "platforms parameter",
					"items":       map[string]any{"type": "object"},
				},
				"progress": map[string]any{
					"type":        "object",
					"description": "progress parameter",
				},
				"test_event_code": map[string]any{
					"type":        "string",
					"description": "test_event_code parameter",
				},
				"trace": map[string]any{
					"type":        "integer",
					"description": "trace parameter",
				},
				"upload_id": map[string]any{
					"type":        "string",
					"description": "upload_id parameter",
				},
				"upload_source": map[string]any{
					"type":        "string",
					"description": "upload_source parameter",
				},
				"upload_tag": map[string]any{
					"type":        "string",
					"description": "upload_tag parameter",
				},
			}),
			mcp.Description("Parameters object containing: data (array<string>) [required], namespace_id (string), partner_agent (string), platforms (array<object>), progress (object), test_event_code (string), trace (integer), upload_id (string), upload_source (string), upload_tag (string)"),
		),
	)
	tools = append(tools, adspixel_post_eventsTool)

	// adspixel_get_offline_event_uploads tool
	// Available fields for OfflineConversionDataSetUpload: api_calls, creation_time, duplicate_entries, event_stats, event_time_max, event_time_min, first_upload_time, id, is_excluded_for_lift, last_upload_time, match_rate_approx, matched_entries, upload_tag, valid_entries
	// Params object accepts: end_time (datetime), order (adspixeloffline_event_uploads_order_enum_param), sort_by (adspixeloffline_event_uploads_sort_by_enum_param), start_time (datetime), upload_tag (string)
	adspixel_get_offline_event_uploadsTool := mcp.NewTool("adspixel_get_offline_event_uploads",
		mcp.WithDescription("GET offline_event_uploads for AdsPixel"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"end_time": map[string]any{
					"type":        "string",
					"description": "end_time parameter",
				},
				"order": map[string]any{
					"type":        "string",
					"description": "order parameter",
					"enum":        []string{"ASCENDING", "DESCENDING"},
				},
				"sort_by": map[string]any{
					"type":        "string",
					"description": "sort_by parameter",
					"enum":        []string{"API_CALLS", "CREATION_TIME", "EVENT_TIME_MAX", "EVENT_TIME_MIN", "FIRST_UPLOAD_TIME", "IS_EXCLUDED_FOR_LIFT", "LAST_UPLOAD_TIME"},
				},
				"start_time": map[string]any{
					"type":        "string",
					"description": "start_time parameter",
				},
				"upload_tag": map[string]any{
					"type":        "string",
					"description": "upload_tag parameter",
				},
			}),
			mcp.Description("Parameters object containing: end_time (datetime), order (enum) [ASCENDING, DESCENDING], sort_by (enum) [API_CALLS, CREATION_TIME, EVENT_TIME_MAX, EVENT_TIME_MIN, FIRST_UPLOAD_TIME, ...], start_time (datetime), upload_tag (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for OfflineConversionDataSetUpload objects. Available fields: api_calls, creation_time, duplicate_entries, event_stats, event_time_max, event_time_min, first_upload_time, id, is_excluded_for_lift, last_upload_time, match_rate_approx, matched_entries, upload_tag, valid_entries"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adspixel_get_offline_event_uploadsTool)

	// adspixel_get_openbridge_configurations tool
	// Available fields for OpenBridgeConfiguration: active, cloud_provider, cloud_region, destination_id, endpoint, fallback_domain, first_party_domain, host_business_id, id, instance_id, instance_version, is_sgw_instance, is_sgw_pixel_from_meta_pixel, partner_name, pixel_id, sgw_account_id, sgw_instance_url, sgw_pixel_id
	adspixel_get_openbridge_configurationsTool := mcp.NewTool("adspixel_get_openbridge_configurations",
		mcp.WithDescription("GET openbridge_configurations for AdsPixel"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for OpenBridgeConfiguration objects. Available fields: active, cloud_provider, cloud_region, destination_id, endpoint, fallback_domain, first_party_domain, host_business_id, id, instance_id, instance_version, is_sgw_instance, is_sgw_pixel_from_meta_pixel, partner_name, pixel_id (and 3 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adspixel_get_openbridge_configurationsTool)

	// adspixel_post_shadowtraffichelper tool
	adspixel_post_shadowtraffichelperTool := mcp.NewTool("adspixel_post_shadowtraffichelper",
		mcp.WithDescription("POST shadowtraffichelper for AdsPixel"),
	)
	tools = append(tools, adspixel_post_shadowtraffichelperTool)

	// adspixel_delete_shared_accounts tool
	// Params object accepts: account_id (string), business (string)
	adspixel_delete_shared_accountsTool := mcp.NewTool("adspixel_delete_shared_accounts",
		mcp.WithDescription("DELETE shared_accounts for AdsPixel"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"account_id": map[string]any{
					"type":        "string",
					"description": "account_id parameter",
					"required":    true,
				},
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: account_id (string) [required], business (string) [required]"),
		),
	)
	tools = append(tools, adspixel_delete_shared_accountsTool)

	// adspixel_get_shared_accounts tool
	// Available fields for AdAccount: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state, business_street, business_street2, business_zip, can_create_brand_lift_study, capabilities, created_time, currency, custom_audience_info, default_dsa_beneficiary, default_dsa_payor, disable_reason, end_advertiser, end_advertiser_name, existing_customers, expired_funding_source_details, extended_credit_invoice_group, failed_delivery_checks, fb_entity, funding_source, funding_source_details, has_migrated_permissions, has_page_authorized_adaccount, id, io_number, is_attribution_spec_system_default, is_ba_skip_delayed_eligible, is_direct_deals_enabled, is_in_3ds_authorization_enabled_market, is_notifications_enabled, is_personal, is_prepay_account, is_tax_id_required, liable_address, line_numbers, media_agency, min_campaign_group_spend_cap, min_daily_budget, name, offsite_pixels_tos_accepted, owner, owner_business, partner, rf_spec, send_bill_to_address, show_checkout_experience, sold_to_address, spend_cap, tax_id, tax_id_status, tax_id_type, timezone_id, timezone_name, timezone_offset_hours_utc, tos_accepted, user_access_expire_time, user_tasks, user_tos_accepted, viewable_business
	// Params object accepts: business (string)
	adspixel_get_shared_accountsTool := mcp.NewTool("adspixel_get_shared_accounts",
		mcp.WithDescription("GET shared_accounts for AdsPixel"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccount objects. Available fields: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state (and 58 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adspixel_get_shared_accountsTool)

	// adspixel_post_shared_accounts tool
	// Params object accepts: account_id (string), business (string)
	adspixel_post_shared_accountsTool := mcp.NewTool("adspixel_post_shared_accounts",
		mcp.WithDescription("POST shared_accounts for AdsPixel"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"account_id": map[string]any{
					"type":        "string",
					"description": "account_id parameter",
					"required":    true,
				},
				"business": map[string]any{
					"type":        "string",
					"description": "business parameter",
					"required":    true,
				},
			}),
			mcp.Description("Parameters object containing: account_id (string) [required], business (string) [required]"),
		),
	)
	tools = append(tools, adspixel_post_shared_accountsTool)

	// adspixel_get_shared_agencies tool
	// Available fields for Business: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id, two_factor_type, updated_by, updated_time, user_access_expire_time, verification_status, vertical, vertical_id
	adspixel_get_shared_agenciesTool := mcp.NewTool("adspixel_get_shared_agencies",
		mcp.WithDescription("GET shared_agencies for AdsPixel"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Business objects. Available fields: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id (and 7 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adspixel_get_shared_agenciesTool)

	// adspixel_get_stats tool
	// Available fields for AdsPixelStatsResult: aggregation, data, start_time
	// Params object accepts: aggregation (adspixelstats_aggregation_enum_param), end_time (datetime), event (string), event_source (string), start_time (datetime)
	adspixel_get_statsTool := mcp.NewTool("adspixel_get_stats",
		mcp.WithDescription("GET stats for AdsPixel"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"aggregation": map[string]any{
					"type":        "string",
					"description": "aggregation parameter",
					"enum":        []string{"browser_type", "custom_data_field", "device_os", "device_type", "event", "event_detection_method", "event_processing_results", "event_source", "event_total_counts", "event_value_count", "had_pii", "host", "match_keys", "pixel_fire", "url", "url_by_rule"},
				},
				"end_time": map[string]any{
					"type":        "string",
					"description": "end_time parameter",
				},
				"event": map[string]any{
					"type":        "string",
					"description": "event parameter",
				},
				"event_source": map[string]any{
					"type":        "string",
					"description": "event_source parameter",
				},
				"start_time": map[string]any{
					"type":        "string",
					"description": "start_time parameter",
				},
			}),
			mcp.Description("Parameters object containing: aggregation (enum) [browser_type, custom_data_field, device_os, device_type, event, ...], end_time (datetime), event (string), event_source (string), start_time (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdsPixelStatsResult objects. Available fields: aggregation, data, start_time"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adspixel_get_statsTool)

	// adspixel_get_ tool
	// Available fields for AdsPixel: automatic_matching_fields, can_proxy, code, config, creation_time, creator, data_use_setting, description, duplicate_entries, enable_auto_assign_to_accounts, enable_automatic_matching, event_stats, event_time_max, event_time_min, first_party_cookie_status, has_1p_pixel_event, id, is_consolidated_container, is_created_by_business, is_crm, is_mta_use, is_restricted_use, is_unavailable, last_fired_time, last_upload_app, last_upload_app_changed_time, match_rate_approx, matched_entries, name, owner_ad_account, owner_business, usage, user_access_expire_time, valid_entries
	adspixel_get_Tool := mcp.NewTool("adspixel_get_",
		mcp.WithDescription("GET  for AdsPixel"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdsPixel objects. Available fields: automatic_matching_fields, can_proxy, code, config, creation_time, creator, data_use_setting, description, duplicate_entries, enable_auto_assign_to_accounts, enable_automatic_matching, event_stats, event_time_max, event_time_min, first_party_cookie_status (and 19 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, adspixel_get_Tool)

	// adspixel_post_ tool
	// Params object accepts: automatic_matching_fields (list<adspixel_automatic_matching_fields>), data_use_setting (adspixel_data_use_setting), enable_automatic_matching (bool), first_party_cookie_status (adspixel_first_party_cookie_status), name (string), server_events_business_ids (list<string>)
	adspixel_post_Tool := mcp.NewTool("adspixel_post_",
		mcp.WithDescription("POST  for AdsPixel"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"automatic_matching_fields": map[string]any{
					"type":        "array",
					"description": "automatic_matching_fields parameter",
					"enum":        []string{"country", "ct", "db", "em", "external_id", "fn", "ge", "ln", "ph", "st", "zp"},
					"items":       map[string]any{"type": "string"},
				},
				"data_use_setting": map[string]any{
					"type":        "string",
					"description": "data_use_setting parameter",
					"enum":        []string{"ADVERTISING_AND_ANALYTICS", "ANALYTICS_ONLY", "EMPTY"},
				},
				"enable_automatic_matching": map[string]any{
					"type":        "boolean",
					"description": "enable_automatic_matching parameter",
				},
				"first_party_cookie_status": map[string]any{
					"type":        "string",
					"description": "first_party_cookie_status parameter",
					"enum":        []string{"EMPTY", "FIRST_PARTY_COOKIE_DISABLED", "FIRST_PARTY_COOKIE_ENABLED"},
				},
				"name": map[string]any{
					"type":        "string",
					"description": "name parameter",
				},
				"server_events_business_ids": map[string]any{
					"type":        "array",
					"description": "server_events_business_ids parameter",
					"items":       map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: automatic_matching_fields (array<adspixel_automatic_matching_fields>) [country, ct, db, em, external_id, ...], data_use_setting (adspixel_data_use_setting) [ADVERTISING_AND_ANALYTICS, ANALYTICS_ONLY, EMPTY], enable_automatic_matching (boolean), first_party_cookie_status (adspixel_first_party_cookie_status) [EMPTY, FIRST_PARTY_COOKIE_DISABLED, FIRST_PARTY_COOKIE_ENABLED], name (string), server_events_business_ids (array<string>)"),
		),
	)
	tools = append(tools, adspixel_post_Tool)

	return tools
}

// AdsPixel handlers

// HandleAdspixel_get_adaccounts handles the adspixel_get_adaccounts tool with context-based auth
func HandleAdspixel_get_adaccounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adspixel_get_adaccounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_get_adaccounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_delete_agencies handles the adspixel_delete_agencies tool with context-based auth
func HandleAdspixel_delete_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adspixel_delete_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_delete_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_get_agencies handles the adspixel_get_agencies tool with context-based auth
func HandleAdspixel_get_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adspixel_get_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_get_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_post_agencies handles the adspixel_post_agencies tool with context-based auth
func HandleAdspixel_post_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adspixel_post_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_post_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_post_ahp_configs handles the adspixel_post_ahp_configs tool with context-based auth
func HandleAdspixel_post_ahp_configs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adspixel_post_ahp_configs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_post_ahp_configs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_get_assigned_users handles the adspixel_get_assigned_users tool with context-based auth
func HandleAdspixel_get_assigned_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adspixel_get_assigned_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_get_assigned_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_post_assigned_users handles the adspixel_post_assigned_users tool with context-based auth
func HandleAdspixel_post_assigned_users(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adspixel_post_assigned_users(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_post_assigned_users: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_get_da_checks handles the adspixel_get_da_checks tool with context-based auth
func HandleAdspixel_get_da_checks(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adspixel_get_da_checks(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_get_da_checks: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_post_events handles the adspixel_post_events tool with context-based auth
func HandleAdspixel_post_events(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adspixel_post_events(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_post_events: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_get_offline_event_uploads handles the adspixel_get_offline_event_uploads tool with context-based auth
func HandleAdspixel_get_offline_event_uploads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adspixel_get_offline_event_uploads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_get_offline_event_uploads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_get_openbridge_configurations handles the adspixel_get_openbridge_configurations tool with context-based auth
func HandleAdspixel_get_openbridge_configurations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adspixel_get_openbridge_configurations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_get_openbridge_configurations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_post_shadowtraffichelper handles the adspixel_post_shadowtraffichelper tool with context-based auth
func HandleAdspixel_post_shadowtraffichelper(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Adspixel_post_shadowtraffichelper(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_post_shadowtraffichelper: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_delete_shared_accounts handles the adspixel_delete_shared_accounts tool with context-based auth
func HandleAdspixel_delete_shared_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adspixel_delete_shared_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_delete_shared_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_get_shared_accounts handles the adspixel_get_shared_accounts tool with context-based auth
func HandleAdspixel_get_shared_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adspixel_get_shared_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_get_shared_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_post_shared_accounts handles the adspixel_post_shared_accounts tool with context-based auth
func HandleAdspixel_post_shared_accounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Call the client method
	result, err := client.Adspixel_post_shared_accounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_post_shared_accounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_get_shared_agencies handles the adspixel_get_shared_agencies tool with context-based auth
func HandleAdspixel_get_shared_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adspixel_get_shared_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_get_shared_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_get_stats handles the adspixel_get_stats tool with context-based auth
func HandleAdspixel_get_stats(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adspixel_get_stats(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_get_stats: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_get_ handles the adspixel_get_ tool with context-based auth
func HandleAdspixel_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}

	// Call the client method
	result, err := client.Adspixel_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleAdspixel_post_ handles the adspixel_post_ tool with context-based auth
func HandleAdspixel_post_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewAdsPixelClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Call the client method
	result, err := client.Adspixel_post_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute adspixel_post_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}
