// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetIGUserTools returns MCP tools for IGUser
func GetIGUserTools() []mcp.Tool {
	var tools []mcp.Tool


	// iguser_get_agencies tool
	// Available fields for Business: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id, two_factor_type, updated_by, updated_time, user_access_expire_time, verification_status, vertical, vertical_id
	iguser_get_agenciesTool := mcp.NewTool("iguser_get_agencies",
		mcp.WithDescription("GET agencies for IGUser"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Business objects. Available fields: block_offline_analytics, collaborative_ads_managed_partner_business_info, collaborative_ads_managed_partner_eligibility, collaborative_ads_partner_premium_options, created_by, created_time, extended_updated_time, id, is_hidden, link, name, payment_account_id, primary_page, profile_picture_uri, timezone_id (and 7 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_agenciesTool)

	// iguser_get_authorized_adaccounts tool
	// Available fields for AdAccount: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state, business_street, business_street2, business_zip, can_create_brand_lift_study, capabilities, created_time, currency, custom_audience_info, default_dsa_beneficiary, default_dsa_payor, disable_reason, end_advertiser, end_advertiser_name, existing_customers, expired_funding_source_details, extended_credit_invoice_group, failed_delivery_checks, fb_entity, funding_source, funding_source_details, has_migrated_permissions, has_page_authorized_adaccount, id, io_number, is_attribution_spec_system_default, is_ba_skip_delayed_eligible, is_direct_deals_enabled, is_in_3ds_authorization_enabled_market, is_notifications_enabled, is_personal, is_prepay_account, is_tax_id_required, liable_address, line_numbers, media_agency, min_campaign_group_spend_cap, min_daily_budget, name, offsite_pixels_tos_accepted, owner, owner_business, partner, rf_spec, send_bill_to_address, show_checkout_experience, sold_to_address, spend_cap, tax_id, tax_id_status, tax_id_type, timezone_id, timezone_name, timezone_offset_hours_utc, tos_accepted, user_access_expire_time, user_tasks, user_tos_accepted, viewable_business
	// Params object accepts: business (string)
	iguser_get_authorized_adaccountsTool := mcp.NewTool("iguser_get_authorized_adaccounts",
		mcp.WithDescription("GET authorized_adaccounts for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"business": map[string]any{
					"type": "string",
					"description": "business parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: business (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for AdAccount objects. Available fields: account_id, account_status, ad_account_promotable_objects, age, agency_client_declaration, all_capabilities, amount_spent, attribution_spec, balance, brand_safety_content_filter_levels, business, business_city, business_country_code, business_name, business_state (and 58 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_authorized_adaccountsTool)

	// iguser_post_authorized_adaccounts tool
	// Params object accepts: account_id (string), business (string)
	iguser_post_authorized_adaccountsTool := mcp.NewTool("iguser_post_authorized_adaccounts",
		mcp.WithDescription("POST authorized_adaccounts for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"account_id": map[string]any{
					"type": "string",
					"description": "account_id parameter",
					"required": true,
				},
				"business": map[string]any{
					"type": "string",
					"description": "business parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: account_id (string) [required], business (string) [required]"),
		),
	)
	tools = append(tools, iguser_post_authorized_adaccountsTool)

	// iguser_get_available_catalogs tool
	// Available fields for UserAvailableCatalogs: catalog_id, catalog_name, product_count, shop_name
	iguser_get_available_catalogsTool := mcp.NewTool("iguser_get_available_catalogs",
		mcp.WithDescription("GET available_catalogs for IGUser"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for UserAvailableCatalogs objects. Available fields: catalog_id, catalog_name, product_count, shop_name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_available_catalogsTool)

	// iguser_get_branded_content_ad_permissions tool
	// Available fields for IGBCAdsPermission: id, permission_type, status
	iguser_get_branded_content_ad_permissionsTool := mcp.NewTool("iguser_get_branded_content_ad_permissions",
		mcp.WithDescription("GET branded_content_ad_permissions for IGUser"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGBCAdsPermission objects. Available fields: id, permission_type, status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_branded_content_ad_permissionsTool)

	// iguser_post_branded_content_ad_permissions tool
	// Params object accepts: creator_instagram_account (string), creator_instagram_username (string), revoke (bool)
	iguser_post_branded_content_ad_permissionsTool := mcp.NewTool("iguser_post_branded_content_ad_permissions",
		mcp.WithDescription("POST branded_content_ad_permissions for IGUser"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"creator_instagram_account": map[string]any{
					"type": "string",
					"description": "creator_instagram_account parameter",
				},
				"creator_instagram_username": map[string]any{
					"type": "string",
					"description": "creator_instagram_username parameter",
				},
				"revoke": map[string]any{
					"type": "boolean",
					"description": "revoke parameter",
				},
			}),
			mcp.Description("Parameters object containing: creator_instagram_account (string), creator_instagram_username (string), revoke (boolean)"),
		),
	)
	tools = append(tools, iguser_post_branded_content_ad_permissionsTool)

	// iguser_get_branded_content_advertisable_medias tool
	// Available fields for BrandedContentShadowIGMediaID: eligibility_errors, has_permission_for_partnership_ad, id, owner_id, permalink, recommended_campaign_objectives
	// Params object accepts: ad_code (string), creator_username (string), only_fetch_allowlisted (bool), only_fetch_recommended_content (bool), permalinks (list<string>)
	iguser_get_branded_content_advertisable_mediasTool := mcp.NewTool("iguser_get_branded_content_advertisable_medias",
		mcp.WithDescription("GET branded_content_advertisable_medias for IGUser"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"ad_code": map[string]any{
					"type": "string",
					"description": "ad_code parameter",
				},
				"creator_username": map[string]any{
					"type": "string",
					"description": "creator_username parameter",
				},
				"only_fetch_allowlisted": map[string]any{
					"type": "boolean",
					"description": "only_fetch_allowlisted parameter",
				},
				"only_fetch_recommended_content": map[string]any{
					"type": "boolean",
					"description": "only_fetch_recommended_content parameter",
				},
				"permalinks": map[string]any{
					"type": "array",
					"description": "permalinks parameter",
					"items": map[string]any{"type": "string"},
				},
			}),
			mcp.Description("Parameters object containing: ad_code (string), creator_username (string), only_fetch_allowlisted (boolean), only_fetch_recommended_content (boolean), permalinks (array<string>)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for BrandedContentShadowIGMediaID objects. Available fields: eligibility_errors, has_permission_for_partnership_ad, id, owner_id, permalink, recommended_campaign_objectives"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_branded_content_advertisable_mediasTool)

	// iguser_delete_branded_content_tag_approval tool
	// Params object accepts: user_ids (list<unsigned int>)
	iguser_delete_branded_content_tag_approvalTool := mcp.NewTool("iguser_delete_branded_content_tag_approval",
		mcp.WithDescription("DELETE branded_content_tag_approval for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"user_ids": map[string]any{
					"type": "array",
					"description": "user_ids parameter",
					"required": true,
					"items": map[string]any{"type": "integer"},
				},
			}),
			mcp.Description("Parameters object containing: user_ids (array<integer>) [required]"),
		),
	)
	tools = append(tools, iguser_delete_branded_content_tag_approvalTool)

	// iguser_get_branded_content_tag_approval tool
	// Available fields for BrandedContentShadowIGUserID: id
	// Params object accepts: user_ids (list<unsigned int>)
	iguser_get_branded_content_tag_approvalTool := mcp.NewTool("iguser_get_branded_content_tag_approval",
		mcp.WithDescription("GET branded_content_tag_approval for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"user_ids": map[string]any{
					"type": "array",
					"description": "user_ids parameter",
					"required": true,
					"items": map[string]any{"type": "integer"},
				},
			}),
			mcp.Description("Parameters object containing: user_ids (array<integer>) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for BrandedContentShadowIGUserID objects. Available fields: id"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_branded_content_tag_approvalTool)

	// iguser_post_branded_content_tag_approval tool
	// Params object accepts: user_ids (list<unsigned int>)
	iguser_post_branded_content_tag_approvalTool := mcp.NewTool("iguser_post_branded_content_tag_approval",
		mcp.WithDescription("POST branded_content_tag_approval for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"user_ids": map[string]any{
					"type": "array",
					"description": "user_ids parameter",
					"required": true,
					"items": map[string]any{"type": "integer"},
				},
			}),
			mcp.Description("Parameters object containing: user_ids (array<integer>) [required]"),
		),
	)
	tools = append(tools, iguser_post_branded_content_tag_approvalTool)

	// iguser_get_catalog_product_search tool
	// Available fields for ShadowIGUserCatalogProductSearch: image_url, is_checkout_flow, merchant_id, product_id, product_name, product_variants, retailer_id, review_status
	// Params object accepts: catalog_id (string), q (string)
	iguser_get_catalog_product_searchTool := mcp.NewTool("iguser_get_catalog_product_search",
		mcp.WithDescription("GET catalog_product_search for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"catalog_id": map[string]any{
					"type": "string",
					"description": "catalog_id parameter",
					"required": true,
				},
				"q": map[string]any{
					"type": "string",
					"description": "q parameter",
				},
			}),
			mcp.Description("Parameters object containing: catalog_id (string) [required], q (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ShadowIGUserCatalogProductSearch objects. Available fields: image_url, is_checkout_flow, merchant_id, product_id, product_name, product_variants, retailer_id, review_status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_catalog_product_searchTool)

	// iguser_get_connected_threads_user tool
	// Available fields for ThreadsUser: threads_user_id, threads_user_profile_pic
	iguser_get_connected_threads_userTool := mcp.NewTool("iguser_get_connected_threads_user",
		mcp.WithDescription("GET connected_threads_user for IGUser"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ThreadsUser objects. Available fields: threads_user_id, threads_user_profile_pic"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_connected_threads_userTool)

	// iguser_get_content_publishing_limit tool
	// Available fields for ContentPublishingLimitResponse: config, quota_usage
	// Params object accepts: since (datetime)
	iguser_get_content_publishing_limitTool := mcp.NewTool("iguser_get_content_publishing_limit",
		mcp.WithDescription("GET content_publishing_limit for IGUser"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"since": map[string]any{
					"type": "string",
					"description": "since parameter",
				},
			}),
			mcp.Description("Parameters object containing: since (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ContentPublishingLimitResponse objects. Available fields: config, quota_usage"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_content_publishing_limitTool)

	// iguser_get_dataset tool
	// Available fields for Dataset: id, name
	iguser_get_datasetTool := mcp.NewTool("iguser_get_dataset",
		mcp.WithDescription("GET dataset for IGUser"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for Dataset objects. Available fields: id, name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_datasetTool)

	// iguser_post_dataset tool
	// Params object accepts: dataset_name (string)
	iguser_post_datasetTool := mcp.NewTool("iguser_post_dataset",
		mcp.WithDescription("POST dataset for IGUser"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"dataset_name": map[string]any{
					"type": "string",
					"description": "dataset_name parameter",
				},
			}),
			mcp.Description("Parameters object containing: dataset_name (string)"),
		),
	)
	tools = append(tools, iguser_post_datasetTool)

	// iguser_get_insights tool
	// Available fields for InstagramInsightsResult: description, id, name, period, title, total_value, values
	// Params object accepts: breakdown (list<shadowiguserinsights_breakdown_enum_param>), metric (list<shadowiguserinsights_metric_enum_param>), metric_type (shadowiguserinsights_metric_type_enum_param), period (list<shadowiguserinsights_period_enum_param>), since (datetime), timeframe (shadowiguserinsights_timeframe_enum_param), until (datetime)
	iguser_get_insightsTool := mcp.NewTool("iguser_get_insights",
		mcp.WithDescription("GET insights for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"breakdown": map[string]any{
					"type": "array",
					"description": "breakdown parameter",
					"enum": []string{ "age", "city", "contact_button_type", "country", "follow_type", "gender", "media_product_type" },
					"items": map[string]any{"type": "string"},
				},
				"metric": map[string]any{
					"type": "array",
					"description": "metric parameter",
					"required": true,
					"enum": []string{ "accounts_engaged", "comments", "content_views", "engaged_audience_demographics", "follower_count", "follower_demographics", "follows_and_unfollows", "impressions", "likes", "online_followers", "profile_links_taps", "profile_views", "quotes", "reach", "reached_audience_demographics", "replies", "reposts", "saves", "shares", "threads_follower_demographics", "threads_followers", "threads_likes", "threads_replies", "threads_views", "total_interactions", "views", "website_clicks" },
					"items": map[string]any{"type": "string"},
				},
				"metric_type": map[string]any{
					"type": "string",
					"description": "metric_type parameter",
					"enum": []string{ "default", "time_series", "total_value" },
				},
				"period": map[string]any{
					"type": "array",
					"description": "period parameter",
					"required": true,
					"enum": []string{ "day", "days_28", "lifetime", "month", "total_over_range", "week" },
					"items": map[string]any{"type": "string"},
				},
				"since": map[string]any{
					"type": "string",
					"description": "since parameter",
				},
				"timeframe": map[string]any{
					"type": "string",
					"description": "timeframe parameter",
					"enum": []string{ "last_14_days", "last_30_days", "last_90_days", "prev_month", "this_month", "this_week" },
				},
				"until": map[string]any{
					"type": "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: breakdown (array<enum>) [age, city, contact_button_type, country, follow_type, ...], metric (array<enum>) [accounts_engaged, comments, content_views, engaged_audience_demographics, follower_count, ...] [required], metric_type (enum) [default, time_series, total_value], period (array<enum>) [day, days_28, lifetime, month, total_over_range, ...] [required], since (datetime), timeframe (enum) [last_14_days, last_30_days, last_90_days, prev_month, this_month, ...], until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for InstagramInsightsResult objects. Available fields: description, id, name, period, title, total_value, values"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_insightsTool)

	// iguser_get_instagram_backed_threads_user tool
	// Available fields for ThreadsUser: threads_user_id, threads_user_profile_pic
	iguser_get_instagram_backed_threads_userTool := mcp.NewTool("iguser_get_instagram_backed_threads_user",
		mcp.WithDescription("GET instagram_backed_threads_user for IGUser"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ThreadsUser objects. Available fields: threads_user_id, threads_user_profile_pic"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_instagram_backed_threads_userTool)

	// iguser_get_live_media tool
	// Available fields for IGMedia: alt_text, boost_eligibility_info, caption, comments_count, copyright_check_information, id, ig_id, is_comment_enabled, is_shared_to_feed, legacy_instagram_media_id, like_count, media_product_type, media_type, media_url, owner, permalink, shortcode, thumbnail_url, timestamp, username, view_count
	// Params object accepts: since (datetime), until (datetime)
	iguser_get_live_mediaTool := mcp.NewTool("iguser_get_live_media",
		mcp.WithDescription("GET live_media for IGUser"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"since": map[string]any{
					"type": "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type": "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: since (datetime), until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGMedia objects. Available fields: alt_text, boost_eligibility_info, caption, comments_count, copyright_check_information, id, ig_id, is_comment_enabled, is_shared_to_feed, legacy_instagram_media_id, like_count, media_product_type, media_type, media_url, owner (and 6 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_live_mediaTool)

	// iguser_get_media tool
	// Available fields for IGMedia: alt_text, boost_eligibility_info, caption, comments_count, copyright_check_information, id, ig_id, is_comment_enabled, is_shared_to_feed, legacy_instagram_media_id, like_count, media_product_type, media_type, media_url, owner, permalink, shortcode, thumbnail_url, timestamp, username, view_count
	// Params object accepts: since (datetime), until (datetime)
	iguser_get_mediaTool := mcp.NewTool("iguser_get_media",
		mcp.WithDescription("GET media for IGUser"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"since": map[string]any{
					"type": "string",
					"description": "since parameter",
				},
				"until": map[string]any{
					"type": "string",
					"description": "until parameter",
				},
			}),
			mcp.Description("Parameters object containing: since (datetime), until (datetime)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGMedia objects. Available fields: alt_text, boost_eligibility_info, caption, comments_count, copyright_check_information, id, ig_id, is_comment_enabled, is_shared_to_feed, legacy_instagram_media_id, like_count, media_product_type, media_type, media_url, owner (and 6 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_mediaTool)

	// iguser_post_media tool
	// Params object accepts: alt_text (string), audio_name (string), caption (string), children (list<string>), collaborators (list<string>), cover_url (string), image_url (string), is_carousel_item (bool), location_id (string), media_type (string), product_tags (list<map>), share_to_feed (bool), thumb_offset (string), upload_type (string), user_tags (list<map>), video_url (string)
	iguser_post_mediaTool := mcp.NewTool("iguser_post_media",
		mcp.WithDescription("POST media for IGUser"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"alt_text": map[string]any{
					"type": "string",
					"description": "alt_text parameter",
				},
				"audio_name": map[string]any{
					"type": "string",
					"description": "audio_name parameter",
				},
				"caption": map[string]any{
					"type": "string",
					"description": "caption parameter",
				},
				"children": map[string]any{
					"type": "array",
					"description": "children parameter",
					"items": map[string]any{"type": "string"},
				},
				"collaborators": map[string]any{
					"type": "array",
					"description": "collaborators parameter",
					"items": map[string]any{"type": "string"},
				},
				"cover_url": map[string]any{
					"type": "string",
					"description": "cover_url parameter",
				},
				"image_url": map[string]any{
					"type": "string",
					"description": "image_url parameter",
				},
				"is_carousel_item": map[string]any{
					"type": "boolean",
					"description": "is_carousel_item parameter",
				},
				"location_id": map[string]any{
					"type": "string",
					"description": "location_id parameter",
				},
				"media_type": map[string]any{
					"type": "string",
					"description": "media_type parameter",
				},
				"product_tags": map[string]any{
					"type": "array",
					"description": "product_tags parameter",
					"items": map[string]any{"type": "object"},
				},
				"share_to_feed": map[string]any{
					"type": "boolean",
					"description": "share_to_feed parameter",
				},
				"thumb_offset": map[string]any{
					"type": "string",
					"description": "thumb_offset parameter",
				},
				"upload_type": map[string]any{
					"type": "string",
					"description": "upload_type parameter",
				},
				"user_tags": map[string]any{
					"type": "array",
					"description": "user_tags parameter",
					"items": map[string]any{"type": "object"},
				},
				"video_url": map[string]any{
					"type": "string",
					"description": "video_url parameter",
				},
			}),
			mcp.Description("Parameters object containing: alt_text (string), audio_name (string), caption (string), children (array<string>), collaborators (array<string>), cover_url (string), image_url (string), is_carousel_item (boolean), location_id (string), media_type (string), product_tags (array<object>), share_to_feed (boolean), thumb_offset (string), upload_type (string), user_tags (array<object>), video_url (string)"),
		),
	)
	tools = append(tools, iguser_post_mediaTool)

	// iguser_post_media_publish tool
	// Params object accepts: creation_id (unsigned int)
	iguser_post_media_publishTool := mcp.NewTool("iguser_post_media_publish",
		mcp.WithDescription("POST media_publish for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"creation_id": map[string]any{
					"type": "integer",
					"description": "creation_id parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: creation_id (integer) [required]"),
		),
	)
	tools = append(tools, iguser_post_media_publishTool)

	// iguser_post_mentions tool
	// Params object accepts: comment_id (string), media_id (string), message (string)
	iguser_post_mentionsTool := mcp.NewTool("iguser_post_mentions",
		mcp.WithDescription("POST mentions for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"comment_id": map[string]any{
					"type": "string",
					"description": "comment_id parameter",
				},
				"media_id": map[string]any{
					"type": "string",
					"description": "media_id parameter",
					"required": true,
				},
				"message": map[string]any{
					"type": "string",
					"description": "message parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: comment_id (string), media_id (string) [required], message (string) [required]"),
		),
	)
	tools = append(tools, iguser_post_mentionsTool)

	// iguser_get_notification_message_tokens tool
	// Available fields for UserPageOneTimeOptInTokenSettings: creation_timestamp, next_eligible_time, notification_messages_frequency, notification_messages_reoptin, notification_messages_timezone, notification_messages_token, recipient_id, token_expiry_timestamp, topic_title, user_token_status
	iguser_get_notification_message_tokensTool := mcp.NewTool("iguser_get_notification_message_tokens",
		mcp.WithDescription("GET notification_message_tokens for IGUser"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for UserPageOneTimeOptInTokenSettings objects. Available fields: creation_timestamp, next_eligible_time, notification_messages_frequency, notification_messages_reoptin, notification_messages_timezone, notification_messages_token, recipient_id, token_expiry_timestamp, topic_title, user_token_status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_notification_message_tokensTool)

	// iguser_get_product_appeal tool
	// Available fields for IGShoppingProductAppeal: eligible_for_appeal, product_appeal_status, product_id, rejection_reasons, review_status
	// Params object accepts: product_id (string)
	iguser_get_product_appealTool := mcp.NewTool("iguser_get_product_appeal",
		mcp.WithDescription("GET product_appeal for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"product_id": map[string]any{
					"type": "string",
					"description": "product_id parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: product_id (string) [required]"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGShoppingProductAppeal objects. Available fields: eligible_for_appeal, product_appeal_status, product_id, rejection_reasons, review_status"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_product_appealTool)

	// iguser_post_product_appeal tool
	// Params object accepts: appeal_reason (string), product_id (string)
	iguser_post_product_appealTool := mcp.NewTool("iguser_post_product_appeal",
		mcp.WithDescription("POST product_appeal for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"appeal_reason": map[string]any{
					"type": "string",
					"description": "appeal_reason parameter",
					"required": true,
				},
				"product_id": map[string]any{
					"type": "string",
					"description": "product_id parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: appeal_reason (string) [required], product_id (string) [required]"),
		),
	)
	tools = append(tools, iguser_post_product_appealTool)

	// iguser_get_recently_searched_hashtags tool
	// Available fields for ShadowIGHashtag: id, name
	iguser_get_recently_searched_hashtagsTool := mcp.NewTool("iguser_get_recently_searched_hashtags",
		mcp.WithDescription("GET recently_searched_hashtags for IGUser"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ShadowIGHashtag objects. Available fields: id, name"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_recently_searched_hashtagsTool)

	// iguser_get_stories tool
	// Available fields for IGMedia: alt_text, boost_eligibility_info, caption, comments_count, copyright_check_information, id, ig_id, is_comment_enabled, is_shared_to_feed, legacy_instagram_media_id, like_count, media_product_type, media_type, media_url, owner, permalink, shortcode, thumbnail_url, timestamp, username, view_count
	iguser_get_storiesTool := mcp.NewTool("iguser_get_stories",
		mcp.WithDescription("GET stories for IGUser"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGMedia objects. Available fields: alt_text, boost_eligibility_info, caption, comments_count, copyright_check_information, id, ig_id, is_comment_enabled, is_shared_to_feed, legacy_instagram_media_id, like_count, media_product_type, media_type, media_url, owner (and 6 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_storiesTool)

	// iguser_get_tags tool
	// Available fields for IGMedia: alt_text, boost_eligibility_info, caption, comments_count, copyright_check_information, id, ig_id, is_comment_enabled, is_shared_to_feed, legacy_instagram_media_id, like_count, media_product_type, media_type, media_url, owner, permalink, shortcode, thumbnail_url, timestamp, username, view_count
	iguser_get_tagsTool := mcp.NewTool("iguser_get_tags",
		mcp.WithDescription("GET tags for IGUser"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGMedia objects. Available fields: alt_text, boost_eligibility_info, caption, comments_count, copyright_check_information, id, ig_id, is_comment_enabled, is_shared_to_feed, legacy_instagram_media_id, like_count, media_product_type, media_type, media_url, owner (and 6 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_tagsTool)

	// iguser_get_upcoming_events tool
	// Available fields for IGUpcomingEvent: end_time, id, notification_subtypes, notification_target_time, start_time, title
	iguser_get_upcoming_eventsTool := mcp.NewTool("iguser_get_upcoming_events",
		mcp.WithDescription("GET upcoming_events for IGUser"),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGUpcomingEvent objects. Available fields: end_time, id, notification_subtypes, notification_target_time, start_time, title"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_upcoming_eventsTool)

	// iguser_post_upcoming_events tool
	// Params object accepts: end_time (datetime), notification_subtypes (list<shadowiguserupcoming_events_notification_subtypes_enum_param>), start_time (datetime), title (string)
	iguser_post_upcoming_eventsTool := mcp.NewTool("iguser_post_upcoming_events",
		mcp.WithDescription("POST upcoming_events for IGUser"),
		mcp.WithObject("params",
			mcp.Required(),
			mcp.Properties(map[string]any{
				"end_time": map[string]any{
					"type": "string",
					"description": "end_time parameter",
				},
				"notification_subtypes": map[string]any{
					"type": "array",
					"description": "notification_subtypes parameter",
					"enum": []string{ "AFTER_EVENT_1DAY", "AFTER_EVENT_2DAY", "AFTER_EVENT_3DAY", "AFTER_EVENT_4DAY", "AFTER_EVENT_5DAY", "AFTER_EVENT_6DAY", "AFTER_EVENT_7DAY", "BEFORE_EVENT_15MIN", "BEFORE_EVENT_1DAY", "BEFORE_EVENT_1HOUR", "BEFORE_EVENT_2DAY", "EVENT_START", "RESCHEDULED" },
					"items": map[string]any{"type": "string"},
				},
				"start_time": map[string]any{
					"type": "string",
					"description": "start_time parameter",
					"required": true,
				},
				"title": map[string]any{
					"type": "string",
					"description": "title parameter",
					"required": true,
				},
			}),
			mcp.Description("Parameters object containing: end_time (datetime), notification_subtypes (array<enum>) [AFTER_EVENT_1DAY, AFTER_EVENT_2DAY, AFTER_EVENT_3DAY, AFTER_EVENT_4DAY, AFTER_EVENT_5DAY, ...], start_time (datetime) [required], title (string) [required]"),
		),
	)
	tools = append(tools, iguser_post_upcoming_eventsTool)

	// iguser_get_welcome_message_flows tool
	// Available fields for ShadowIGUserCTXPartnerAppWelcomeMessageFlow: compatible_platforms, eligible_platforms, id, is_ig_only_flow, is_used_in_ad, last_update_time, name, welcome_message_flow
	// Params object accepts: app_id (string), flow_id (string)
	iguser_get_welcome_message_flowsTool := mcp.NewTool("iguser_get_welcome_message_flows",
		mcp.WithDescription("GET welcome_message_flows for IGUser"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"app_id": map[string]any{
					"type": "string",
					"description": "app_id parameter",
				},
				"flow_id": map[string]any{
					"type": "string",
					"description": "flow_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: app_id (string), flow_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for ShadowIGUserCTXPartnerAppWelcomeMessageFlow objects. Available fields: compatible_platforms, eligible_platforms, id, is_ig_only_flow, is_used_in_ad, last_update_time, name, welcome_message_flow"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_welcome_message_flowsTool)

	// iguser_get_ tool
	// Available fields for IGUser: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url, shopping_product_tag_eligibility, shopping_review_status, username, website
	// Params object accepts: adgroup_id (string)
	iguser_get_Tool := mcp.NewTool("iguser_get_",
		mcp.WithDescription("GET  for IGUser"),
		mcp.WithObject("params",
			mcp.Properties(map[string]any{
				"adgroup_id": map[string]any{
					"type": "string",
					"description": "adgroup_id parameter",
				},
			}),
			mcp.Description("Parameters object containing: adgroup_id (string)"),
		),
		mcp.WithArray("fields",
			mcp.Description("Array of fields to return for IGUser objects. Available fields: biography, business_discovery, followers_count, follows_count, has_profile_pic, id, ig_id, is_published, legacy_instagram_user_id, media_count, mentioned_comment, mentioned_media, name, owner_business, profile_picture_url (and 4 more)"),
		),
		mcp.WithNumber("limit",
			mcp.Description("Maximum number of results to return (default: 25, max: 500)"),
		),
		mcp.WithString("after",
			mcp.Description("Cursor for pagination (use 'next' cursor from previous response)"),
		),
		mcp.WithString("before",
			mcp.Description("Cursor for pagination (use 'previous' cursor from previous response)"),
		),
	)
	tools = append(tools, iguser_get_Tool)


	return tools
}

// IGUser handlers


// HandleIguser_get_agencies handles the iguser_get_agencies tool with context-based auth
func HandleIguser_get_agencies(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_agencies(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_agencies: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_authorized_adaccounts handles the iguser_get_authorized_adaccounts tool with context-based auth
func HandleIguser_get_authorized_adaccounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_authorized_adaccounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_authorized_adaccounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_post_authorized_adaccounts handles the iguser_post_authorized_adaccounts tool with context-based auth
func HandleIguser_post_authorized_adaccounts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguser_post_authorized_adaccounts(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_post_authorized_adaccounts: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_available_catalogs handles the iguser_get_available_catalogs tool with context-based auth
func HandleIguser_get_available_catalogs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_available_catalogs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_available_catalogs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_branded_content_ad_permissions handles the iguser_get_branded_content_ad_permissions tool with context-based auth
func HandleIguser_get_branded_content_ad_permissions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_branded_content_ad_permissions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_branded_content_ad_permissions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_post_branded_content_ad_permissions handles the iguser_post_branded_content_ad_permissions tool with context-based auth
func HandleIguser_post_branded_content_ad_permissions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Iguser_post_branded_content_ad_permissions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_post_branded_content_ad_permissions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_branded_content_advertisable_medias handles the iguser_get_branded_content_advertisable_medias tool with context-based auth
func HandleIguser_get_branded_content_advertisable_medias(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_branded_content_advertisable_medias(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_branded_content_advertisable_medias: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_delete_branded_content_tag_approval handles the iguser_delete_branded_content_tag_approval tool with context-based auth
func HandleIguser_delete_branded_content_tag_approval(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguser_delete_branded_content_tag_approval(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_delete_branded_content_tag_approval: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_branded_content_tag_approval handles the iguser_get_branded_content_tag_approval tool with context-based auth
func HandleIguser_get_branded_content_tag_approval(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_branded_content_tag_approval(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_branded_content_tag_approval: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_post_branded_content_tag_approval handles the iguser_post_branded_content_tag_approval tool with context-based auth
func HandleIguser_post_branded_content_tag_approval(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguser_post_branded_content_tag_approval(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_post_branded_content_tag_approval: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_catalog_product_search handles the iguser_get_catalog_product_search tool with context-based auth
func HandleIguser_get_catalog_product_search(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_catalog_product_search(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_catalog_product_search: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_connected_threads_user handles the iguser_get_connected_threads_user tool with context-based auth
func HandleIguser_get_connected_threads_user(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_connected_threads_user(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_connected_threads_user: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_content_publishing_limit handles the iguser_get_content_publishing_limit tool with context-based auth
func HandleIguser_get_content_publishing_limit(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_content_publishing_limit(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_content_publishing_limit: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_dataset handles the iguser_get_dataset tool with context-based auth
func HandleIguser_get_dataset(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_dataset(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_dataset: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_post_dataset handles the iguser_post_dataset tool with context-based auth
func HandleIguser_post_dataset(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Iguser_post_dataset(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_post_dataset: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_insights handles the iguser_get_insights tool with context-based auth
func HandleIguser_get_insights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_insights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_insights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_instagram_backed_threads_user handles the iguser_get_instagram_backed_threads_user tool with context-based auth
func HandleIguser_get_instagram_backed_threads_user(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_instagram_backed_threads_user(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_instagram_backed_threads_user: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_live_media handles the iguser_get_live_media tool with context-based auth
func HandleIguser_get_live_media(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_live_media(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_live_media: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_media handles the iguser_get_media tool with context-based auth
func HandleIguser_get_media(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_media(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_media: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_post_media handles the iguser_post_media tool with context-based auth
func HandleIguser_post_media(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}



	// Call the client method
	result, err := client.Iguser_post_media(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_post_media: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_post_media_publish handles the iguser_post_media_publish tool with context-based auth
func HandleIguser_post_media_publish(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguser_post_media_publish(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_post_media_publish: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_post_mentions handles the iguser_post_mentions tool with context-based auth
func HandleIguser_post_mentions(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguser_post_mentions(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_post_mentions: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_notification_message_tokens handles the iguser_get_notification_message_tokens tool with context-based auth
func HandleIguser_get_notification_message_tokens(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_notification_message_tokens(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_notification_message_tokens: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_product_appeal handles the iguser_get_product_appeal tool with context-based auth
func HandleIguser_get_product_appeal(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_product_appeal(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_product_appeal: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_post_product_appeal handles the iguser_post_product_appeal tool with context-based auth
func HandleIguser_post_product_appeal(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguser_post_product_appeal(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_post_product_appeal: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_recently_searched_hashtags handles the iguser_get_recently_searched_hashtags tool with context-based auth
func HandleIguser_get_recently_searched_hashtags(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_recently_searched_hashtags(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_recently_searched_hashtags: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_stories handles the iguser_get_stories tool with context-based auth
func HandleIguser_get_stories(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_stories(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_stories: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_tags handles the iguser_get_tags tool with context-based auth
func HandleIguser_get_tags(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_tags(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_tags: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_upcoming_events handles the iguser_get_upcoming_events tool with context-based auth
func HandleIguser_get_upcoming_events(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_upcoming_events(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_upcoming_events: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_post_upcoming_events handles the iguser_post_upcoming_events tool with context-based auth
func HandleIguser_post_upcoming_events(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: params
	params, err := request.RequireString("params")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter params: %v", err)), nil
	}
	// Parse required params object and extract parameters
	var paramsObj map[string]interface{}
	if err := json.Unmarshal([]byte(params), &paramsObj); err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("invalid params object: %v", err)), nil
	}
	for key, value := range paramsObj {
		args[key] = value
	}



	// Call the client method
	result, err := client.Iguser_post_upcoming_events(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_post_upcoming_events: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_welcome_message_flows handles the iguser_get_welcome_message_flows tool with context-based auth
func HandleIguser_get_welcome_message_flows(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_welcome_message_flows(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_welcome_message_flows: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}


// HandleIguser_get_ handles the iguser_get_ tool with context-based auth
func HandleIguser_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewIGUserClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: params
	// Object parameter - expecting JSON string
	if val := request.GetString("params", ""); val != "" {
		// Parse params object and extract individual parameters
		var params map[string]interface{}
		if err := json.Unmarshal([]byte(val), &params); err == nil {
			for key, value := range params {
				args[key] = value
			}
		}
	}

	// Optional: fields
	// Array parameter - expecting JSON string
	if val := request.GetString("fields", ""); val != "" {
		// Parse array of fields and convert to comma-separated string
		var fields []string
		if err := json.Unmarshal([]byte(val), &fields); err == nil && len(fields) > 0 {
			args["fields"] = strings.Join(fields, ",")
		}
	}

	// Optional: limit
	if val := request.GetInt("limit", 0); val != 0 {
		args["limit"] = val
	}

	// Optional: after
	if val := request.GetString("after", ""); val != "" {
		args["after"] = val
	}

	// Optional: before
	if val := request.GetString("before", ""); val != "" {
		args["before"] = val
	}



	// Call the client method
	result, err := client.Iguser_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute iguser_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

