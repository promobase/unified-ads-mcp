// Code generated by Facebook Business API codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/mark3labs/mcp-go/mcp"
	"unified-ads-mcp/internal/facebook/generated/client"
	"unified-ads-mcp/internal/shared"
)

// GetProductFeedTools returns MCP tools for ProductFeed
func GetProductFeedTools(accessToken string) []mcp.Tool {
	var tools []mcp.Tool

	// productfeed_get_automotive_models tool
	productfeed_get_automotive_modelsTool := mcp.NewTool("productfeed_get_automotive_models",
		mcp.WithDescription("GET automotive_models for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for automotive_models"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for automotive_models"),
		),
	)
	tools = append(tools, productfeed_get_automotive_modelsTool)

	// productfeed_get_destinations tool
	productfeed_get_destinationsTool := mcp.NewTool("productfeed_get_destinations",
		mcp.WithDescription("GET destinations for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for destinations"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for destinations"),
		),
	)
	tools = append(tools, productfeed_get_destinationsTool)

	// productfeed_get_flights tool
	productfeed_get_flightsTool := mcp.NewTool("productfeed_get_flights",
		mcp.WithDescription("GET flights for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for flights"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for flights"),
		),
	)
	tools = append(tools, productfeed_get_flightsTool)

	// productfeed_get_home_listings tool
	productfeed_get_home_listingsTool := mcp.NewTool("productfeed_get_home_listings",
		mcp.WithDescription("GET home_listings for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for home_listings"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for home_listings"),
		),
	)
	tools = append(tools, productfeed_get_home_listingsTool)

	// productfeed_get_hotels tool
	productfeed_get_hotelsTool := mcp.NewTool("productfeed_get_hotels",
		mcp.WithDescription("GET hotels for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for hotels"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for hotels"),
		),
	)
	tools = append(tools, productfeed_get_hotelsTool)

	// productfeed_get_media_titles tool
	productfeed_get_media_titlesTool := mcp.NewTool("productfeed_get_media_titles",
		mcp.WithDescription("GET media_titles for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for media_titles"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for media_titles"),
		),
	)
	tools = append(tools, productfeed_get_media_titlesTool)

	// productfeed_get_products tool
	productfeed_get_productsTool := mcp.NewTool("productfeed_get_products",
		mcp.WithDescription("GET products for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for products"),
		),
		mcp.WithString("error_priority",
			mcp.Description("error_priority parameter for products"),
			mcp.Enum("HIGH", "LOW", "MEDIUM"),
		),
		mcp.WithString("error_type",
			mcp.Description("error_type parameter for products"),
			mcp.Enum("ADDRESS_BLOCKLISTED_IN_MARKET", "AGGREGATED_LOCALIZATION_ISSUES", "APP_HAS_NO_AEM_SETUP", "AR_DELETED_DUE_TO_UPDATE", "AR_POLICY_VIOLATED", "AVAILABLE", "BAD_QUALITY_IMAGE", "BIG_CATALOG_WITH_ALL_ITEMS_IN_STOCK", "BIZ_MSG_AI_AGENT_DISABLED_BY_USER", "BIZ_MSG_GEN_AI_POLICY_VIOLATED", "CANNOT_EDIT_SUBSCRIPTION_PRODUCTS", "CATALOG_NOT_CONNECTED_TO_EVENT_SOURCE", "CHECKOUT_DISABLED_BY_USER", "COMMERCE_ACCOUNT_LEGAL_ADDRESS_INVALID", "COMMERCE_ACCOUNT_NOT_LEGALLY_COMPLIANT", "CRAWLED_AVAILABILITY_MISMATCH", "DA_DISABLED_BY_USER", "DA_POLICY_UNFIT_FOR_AUDIENCE", "DA_POLICY_VIOLATION", "DELETED_ITEM", "DIGITAL_GOODS_NOT_AVAILABLE_FOR_CHECKOUT", "DUPLICATE_IMAGES", "DUPLICATE_TITLE_AND_DESCRIPTION", "EMPTY_AVAILABILITY", "EMPTY_CONDITION", "EMPTY_DESCRIPTION", "EMPTY_IMAGE_URL", "EMPTY_PRICE", "EMPTY_PRODUCT_URL", "EMPTY_SELLER_DESCRIPTION", "EMPTY_TITLE", "EXTERNAL_MERCHANT_ID_MISMATCH", "GENERIC_INVALID_FIELD", "GROUPS_DISABLED_BY_USER", "HIDDEN_UNTIL_PRODUCT_LAUNCH", "ILLEGAL_PRODUCT_CATEGORY", "IMAGE_FETCH_FAILED", "IMAGE_FETCH_FAILED_BAD_GATEWAY", "IMAGE_FETCH_FAILED_FILE_SIZE_EXCEEDED", "IMAGE_FETCH_FAILED_FORBIDDEN", "IMAGE_FETCH_FAILED_LINK_BROKEN", "IMAGE_FETCH_FAILED_TIMED_OUT", "IMAGE_RESOLUTION_LOW", "INACTIVE_SHOPIFY_PRODUCT", "INVALID_COMMERCE_TAX_CATEGORY", "INVALID_CONSOLIDATED_LOCALITY_INFORMATION", "INVALID_CONTENT_ID", "INVALID_DEALER_COMMUNICATION_PARAMETERS", "INVALID_DMA_CODES", "INVALID_FB_PAGE_ID", "INVALID_IMAGES", "INVALID_MONETIZER_RETURN_POLICY", "INVALID_OFFER_DISCLAIMER_URL", "INVALID_OFFER_END_DATE", "INVALID_PRE_ORDER_PARAMS", "INVALID_RANGE_FOR_AREA_SIZE", "INVALID_RANGE_FOR_BUILT_UP_AREA_SIZE", "INVALID_RANGE_FOR_NUM_OF_BATHS", "INVALID_RANGE_FOR_NUM_OF_BEDS", "INVALID_RANGE_FOR_NUM_OF_ROOMS", "INVALID_RANGE_FOR_PARKING_SPACES", "INVALID_SHELTER_PAGE_ID", "INVALID_SHIPPING_PROFILE_PARAMS", "INVALID_SUBSCRIPTION_DISABLE_PARAMS", "INVALID_SUBSCRIPTION_ENABLE_PARAMS", "INVALID_SUBSCRIPTION_PARAMS", "INVALID_TAX_EXTENSION_STATE", "INVALID_VEHICLE_STATE", "INVALID_VIRTUAL_TOUR_URL_DOMAIN", "INVENTORY_ZERO_AVAILABILITY_IN_STOCK", "IN_ANOTHER_PRODUCT_LAUNCH", "ITEM_GROUP_NOT_SPECIFIED", "ITEM_NOT_SHIPPABLE_FOR_SCA_SHOP", "ITEM_OVERRIDE_EMPTY_AVAILABILITY", "ITEM_OVERRIDE_EMPTY_PRICE", "ITEM_OVERRIDE_NOT_VISIBLE", "ITEM_PRICE_NOT_POSITIVE", "ITEM_STALE_OUT_OF_STOCK", "MARKETPLACE_DISABLED_BY_USER", "MARKETPLACE_PARTNER_AUCTION_NO_BID_CLOSE_TIME", "MARKETPLACE_PARTNER_CURRENCY_NOT_VALID", "MARKETPLACE_PARTNER_LISTING_COUNTRY_NOT_MATCH_CATALOG", "MARKETPLACE_PARTNER_LISTING_LIMIT_EXCEEDED", "MARKETPLACE_PARTNER_MISSING_LATLONG", "MARKETPLACE_PARTNER_MISSING_SHIPPING_COST", "MARKETPLACE_PARTNER_NOT_LOCAL_ITEM", "MARKETPLACE_PARTNER_NOT_SHIPPED_ITEM", "MARKETPLACE_PARTNER_POLICY_VIOLATION", "MARKETPLACE_PARTNER_RULE_LISTING_LIMIT_EXCEEDED", "MARKETPLACE_PARTNER_SELLER_BANNED", "MARKETPLACE_PARTNER_SELLER_NOT_VALID", "MINI_SHOPS_DISABLED_BY_USER", "MISSING_CHECKOUT", "MISSING_CHECKOUT_CURRENCY", "MISSING_COLOR", "MISSING_COUNTRY_OVERRIDE_IN_SHIPPING_PROFILE", "MISSING_EVENT", "MISSING_INDIA_COMPLIANCE_FIELDS", "MISSING_SHIPPING_PROFILE", "MISSING_SIZE", "MISSING_TAX_CATEGORY", "NEGATIVE_COMMUNITY_FEEDBACK", "NEGATIVE_PRICE", "NOT_ENOUGH_IMAGES", "NOT_ENOUGH_UNIQUE_PRODUCTS", "NO_CONTENT_ID", "OVERLAY_DISCLAIMER_EXCEEDED_MAX_LENGTH", "PART_OF_PRODUCT_LAUNCH", "PASSING_MULTIPLE_CONTENT_IDS", "PRODUCT_DOMINANT_CURRENCY_MISMATCH", "PRODUCT_EXPIRED", "PRODUCT_ITEM_HIDDEN_FROM_ALL_SHOPS", "PRODUCT_ITEM_INVALID_PARTNER_TOKENS", "PRODUCT_ITEM_NOT_INCLUDED_IN_ANY_SHOP", "PRODUCT_ITEM_NOT_VISIBLE", "PRODUCT_NOT_APPROVED", "PRODUCT_NOT_DOMINANT_CURRENCY", "PRODUCT_OUT_OF_STOCK", "PRODUCT_URL_EQUALS_DOMAIN", "PROPERTY_PRICE_CURRENCY_NOT_SUPPORTED", "PROPERTY_PRICE_TOO_HIGH", "PROPERTY_PRICE_TOO_LOW", "PROPERTY_UNIT_PRICE_CURRENCY_MISMATCH_ITEM_PRICE_CURRENCY", "PROPERTY_VALUE_CONTAINS_HTML_TAGS", "PROPERTY_VALUE_DESCRIPTION_CONTAINS_OFF_PLATFORM_LINK", "PROPERTY_VALUE_FORMAT", "PROPERTY_VALUE_MISSING", "PROPERTY_VALUE_MISSING_WARNING", "PROPERTY_VALUE_NON_POSITIVE", "PROPERTY_VALUE_STRING_EXCEEDS_LENGTH", "PROPERTY_VALUE_STRING_TOO_SHORT", "PROPERTY_VALUE_UPPERCASE", "PROPERTY_VALUE_UPPERCASE_WARNING", "PURCHASE_RATE_BELOW_ADDTOCART", "PURCHASE_RATE_BELOW_VIEWCONTENT", "QUALITY_DUPLICATED_DESCRIPTION", "QUALITY_ITEM_LINK_BROKEN", "QUALITY_ITEM_LINK_REDIRECTING", "RETAILER_ID_NOT_PROVIDED", "SHOPIFY_INVALID_RETAILER_ID", "SHOPIFY_ITEM_MISSING_SHIPPING_PROFILE", "SHOPS_POLICY_VIOLATION", "SUBSCRIPTION_INFO_NOT_ENABLED_FOR_FEED", "TAX_CATEGORY_NOT_SUPPORTED_IN_UK", "UNIQUE_PRODUCT_IDENTIFIER_MISSING", "UNMATCHED_EVENTS", "UNSUPPORTED_PRODUCT_CATEGORY", "VARIANT_ATTRIBUTE_ISSUE", "VIDEO_FETCH_FAILED", "VIDEO_FETCH_FAILED_BAD_GATEWAY", "VIDEO_FETCH_FAILED_FILE_SIZE_EXCEEDED", "VIDEO_FETCH_FAILED_FORBIDDEN", "VIDEO_FETCH_FAILED_LINK_BROKEN", "VIDEO_FETCH_FAILED_TIMED_OUT", "VIDEO_NOT_DOWNLOADABLE", "WHATSAPP_DISABLED_BY_USER", "WHATSAPP_MARKETING_MESSAGE_DISABLED_BY_USER", "WHATSAPP_MARKETING_MESSAGE_POLICY_VIOLATION", "WHATSAPP_POLICY_VIOLATION"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for products"),
		),
	)
	tools = append(tools, productfeed_get_productsTool)

	// productfeed_get_rules tool
	productfeed_get_rulesTool := mcp.NewTool("productfeed_get_rules",
		mcp.WithDescription("GET rules for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
	)
	tools = append(tools, productfeed_get_rulesTool)

	// productfeed_post_rules tool
	productfeed_post_rulesTool := mcp.NewTool("productfeed_post_rules",
		mcp.WithDescription("POST rules for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithString("attribute",
			mcp.Required(),
			mcp.Description("attribute parameter for rules"),
		),
		mcp.WithString("params",
			mcp.Description("params parameter for rules"),
		),
		mcp.WithString("rule_type",
			mcp.Required(),
			mcp.Description("rule_type parameter for rules"),
			mcp.Enum("fallback_rule", "letter_case_rule", "mapping_rule", "regex_replace_rule", "value_mapping_rule"),
		),
	)
	tools = append(tools, productfeed_post_rulesTool)

	// productfeed_post_supplementary_feed_assocs tool
	productfeed_post_supplementary_feed_assocsTool := mcp.NewTool("productfeed_post_supplementary_feed_assocs",
		mcp.WithDescription("POST supplementary_feed_assocs for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithString("assoc_data",
			mcp.Required(),
			mcp.Description("assoc_data parameter for supplementary_feed_assocs"),
		),
	)
	tools = append(tools, productfeed_post_supplementary_feed_assocsTool)

	// productfeed_get_upload_schedules tool
	productfeed_get_upload_schedulesTool := mcp.NewTool("productfeed_get_upload_schedules",
		mcp.WithDescription("GET upload_schedules for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
	)
	tools = append(tools, productfeed_get_upload_schedulesTool)

	// productfeed_post_upload_schedules tool
	productfeed_post_upload_schedulesTool := mcp.NewTool("productfeed_post_upload_schedules",
		mcp.WithDescription("POST upload_schedules for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithString("upload_schedule",
			mcp.Description("upload_schedule parameter for upload_schedules"),
		),
	)
	tools = append(tools, productfeed_post_upload_schedulesTool)

	// productfeed_get_uploads tool
	productfeed_get_uploadsTool := mcp.NewTool("productfeed_get_uploads",
		mcp.WithDescription("GET uploads for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
	)
	tools = append(tools, productfeed_get_uploadsTool)

	// productfeed_post_uploads tool
	productfeed_post_uploadsTool := mcp.NewTool("productfeed_post_uploads",
		mcp.WithDescription("POST uploads for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithString("fbe_external_business_id",
			mcp.Description("fbe_external_business_id parameter for uploads"),
		),
		mcp.WithString("file",
			mcp.Description("file parameter for uploads"),
		),
		mcp.WithString("password",
			mcp.Description("password parameter for uploads"),
		),
		mcp.WithBoolean("update_only",
			mcp.Description("update_only parameter for uploads"),
		),
		mcp.WithString("url",
			mcp.Description("url parameter for uploads"),
		),
		mcp.WithString("username",
			mcp.Description("username parameter for uploads"),
		),
	)
	tools = append(tools, productfeed_post_uploadsTool)

	// productfeed_get_vehicle_offers tool
	productfeed_get_vehicle_offersTool := mcp.NewTool("productfeed_get_vehicle_offers",
		mcp.WithDescription("GET vehicle_offers for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for vehicle_offers"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for vehicle_offers"),
		),
	)
	tools = append(tools, productfeed_get_vehicle_offersTool)

	// productfeed_get_vehicles tool
	productfeed_get_vehiclesTool := mcp.NewTool("productfeed_get_vehicles",
		mcp.WithDescription("GET vehicles for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for vehicles"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for vehicles"),
		),
	)
	tools = append(tools, productfeed_get_vehiclesTool)

	// productfeed_delete_ tool
	productfeed_delete_Tool := mcp.NewTool("productfeed_delete_",
		mcp.WithDescription("DELETE  for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
	)
	tools = append(tools, productfeed_delete_Tool)

	// productfeed_get_ tool
	productfeed_get_Tool := mcp.NewTool("productfeed_get_",
		mcp.WithDescription("GET  for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
	)
	tools = append(tools, productfeed_get_Tool)

	// productfeed_post_ tool
	productfeed_post_Tool := mcp.NewTool("productfeed_post_",
		mcp.WithDescription("POST  for ProductFeed"),
		mcp.WithString("access_token",
			mcp.Required(),
			mcp.Description("Facebook access token for authentication"),
		),
		mcp.WithString("default_currency",
			mcp.Description("default_currency parameter for "),
		),
		mcp.WithBoolean("deletion_enabled",
			mcp.Description("deletion_enabled parameter for "),
		),
		mcp.WithString("delimiter",
			mcp.Description("delimiter parameter for "),
			mcp.Enum("AUTODETECT", "BAR", "COMMA", "SEMICOLON", "TAB", "TILDE"),
		),
		mcp.WithString("encoding",
			mcp.Description("encoding parameter for "),
			mcp.Enum("AUTODETECT", "LATIN1", "UTF16BE", "UTF16LE", "UTF32BE", "UTF32LE", "UTF8"),
		),
		mcp.WithString("migrated_from_feed_id",
			mcp.Description("migrated_from_feed_id parameter for "),
		),
		mcp.WithString("name",
			mcp.Description("name parameter for "),
		),
		mcp.WithString("quoted_fields_mode",
			mcp.Description("quoted_fields_mode parameter for "),
			mcp.Enum("autodetect", "off", "on"),
		),
		mcp.WithString("schedule",
			mcp.Description("schedule parameter for "),
		),
		mcp.WithString("update_schedule",
			mcp.Description("update_schedule parameter for "),
		),
	)
	tools = append(tools, productfeed_post_Tool)

	return tools
}

// GetProductFeedToolsWithoutAuth returns MCP tools for ProductFeed without access_token parameter
func GetProductFeedToolsWithoutAuth() []mcp.Tool {
	var tools []mcp.Tool

	// productfeed_get_automotive_models tool
	productfeed_get_automotive_modelsTool := mcp.NewTool("productfeed_get_automotive_models",
		mcp.WithDescription("GET automotive_models for ProductFeed"),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for automotive_models"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for automotive_models"),
		),
	)
	tools = append(tools, productfeed_get_automotive_modelsTool)

	// productfeed_get_destinations tool
	productfeed_get_destinationsTool := mcp.NewTool("productfeed_get_destinations",
		mcp.WithDescription("GET destinations for ProductFeed"),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for destinations"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for destinations"),
		),
	)
	tools = append(tools, productfeed_get_destinationsTool)

	// productfeed_get_flights tool
	productfeed_get_flightsTool := mcp.NewTool("productfeed_get_flights",
		mcp.WithDescription("GET flights for ProductFeed"),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for flights"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for flights"),
		),
	)
	tools = append(tools, productfeed_get_flightsTool)

	// productfeed_get_home_listings tool
	productfeed_get_home_listingsTool := mcp.NewTool("productfeed_get_home_listings",
		mcp.WithDescription("GET home_listings for ProductFeed"),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for home_listings"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for home_listings"),
		),
	)
	tools = append(tools, productfeed_get_home_listingsTool)

	// productfeed_get_hotels tool
	productfeed_get_hotelsTool := mcp.NewTool("productfeed_get_hotels",
		mcp.WithDescription("GET hotels for ProductFeed"),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for hotels"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for hotels"),
		),
	)
	tools = append(tools, productfeed_get_hotelsTool)

	// productfeed_get_media_titles tool
	productfeed_get_media_titlesTool := mcp.NewTool("productfeed_get_media_titles",
		mcp.WithDescription("GET media_titles for ProductFeed"),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for media_titles"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for media_titles"),
		),
	)
	tools = append(tools, productfeed_get_media_titlesTool)

	// productfeed_get_products tool
	productfeed_get_productsTool := mcp.NewTool("productfeed_get_products",
		mcp.WithDescription("GET products for ProductFeed"),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for products"),
		),
		mcp.WithString("error_priority",
			mcp.Description("error_priority parameter for products"),
			mcp.Enum("HIGH", "LOW", "MEDIUM"),
		),
		mcp.WithString("error_type",
			mcp.Description("error_type parameter for products"),
			mcp.Enum("ADDRESS_BLOCKLISTED_IN_MARKET", "AGGREGATED_LOCALIZATION_ISSUES", "APP_HAS_NO_AEM_SETUP", "AR_DELETED_DUE_TO_UPDATE", "AR_POLICY_VIOLATED", "AVAILABLE", "BAD_QUALITY_IMAGE", "BIG_CATALOG_WITH_ALL_ITEMS_IN_STOCK", "BIZ_MSG_AI_AGENT_DISABLED_BY_USER", "BIZ_MSG_GEN_AI_POLICY_VIOLATED", "CANNOT_EDIT_SUBSCRIPTION_PRODUCTS", "CATALOG_NOT_CONNECTED_TO_EVENT_SOURCE", "CHECKOUT_DISABLED_BY_USER", "COMMERCE_ACCOUNT_LEGAL_ADDRESS_INVALID", "COMMERCE_ACCOUNT_NOT_LEGALLY_COMPLIANT", "CRAWLED_AVAILABILITY_MISMATCH", "DA_DISABLED_BY_USER", "DA_POLICY_UNFIT_FOR_AUDIENCE", "DA_POLICY_VIOLATION", "DELETED_ITEM", "DIGITAL_GOODS_NOT_AVAILABLE_FOR_CHECKOUT", "DUPLICATE_IMAGES", "DUPLICATE_TITLE_AND_DESCRIPTION", "EMPTY_AVAILABILITY", "EMPTY_CONDITION", "EMPTY_DESCRIPTION", "EMPTY_IMAGE_URL", "EMPTY_PRICE", "EMPTY_PRODUCT_URL", "EMPTY_SELLER_DESCRIPTION", "EMPTY_TITLE", "EXTERNAL_MERCHANT_ID_MISMATCH", "GENERIC_INVALID_FIELD", "GROUPS_DISABLED_BY_USER", "HIDDEN_UNTIL_PRODUCT_LAUNCH", "ILLEGAL_PRODUCT_CATEGORY", "IMAGE_FETCH_FAILED", "IMAGE_FETCH_FAILED_BAD_GATEWAY", "IMAGE_FETCH_FAILED_FILE_SIZE_EXCEEDED", "IMAGE_FETCH_FAILED_FORBIDDEN", "IMAGE_FETCH_FAILED_LINK_BROKEN", "IMAGE_FETCH_FAILED_TIMED_OUT", "IMAGE_RESOLUTION_LOW", "INACTIVE_SHOPIFY_PRODUCT", "INVALID_COMMERCE_TAX_CATEGORY", "INVALID_CONSOLIDATED_LOCALITY_INFORMATION", "INVALID_CONTENT_ID", "INVALID_DEALER_COMMUNICATION_PARAMETERS", "INVALID_DMA_CODES", "INVALID_FB_PAGE_ID", "INVALID_IMAGES", "INVALID_MONETIZER_RETURN_POLICY", "INVALID_OFFER_DISCLAIMER_URL", "INVALID_OFFER_END_DATE", "INVALID_PRE_ORDER_PARAMS", "INVALID_RANGE_FOR_AREA_SIZE", "INVALID_RANGE_FOR_BUILT_UP_AREA_SIZE", "INVALID_RANGE_FOR_NUM_OF_BATHS", "INVALID_RANGE_FOR_NUM_OF_BEDS", "INVALID_RANGE_FOR_NUM_OF_ROOMS", "INVALID_RANGE_FOR_PARKING_SPACES", "INVALID_SHELTER_PAGE_ID", "INVALID_SHIPPING_PROFILE_PARAMS", "INVALID_SUBSCRIPTION_DISABLE_PARAMS", "INVALID_SUBSCRIPTION_ENABLE_PARAMS", "INVALID_SUBSCRIPTION_PARAMS", "INVALID_TAX_EXTENSION_STATE", "INVALID_VEHICLE_STATE", "INVALID_VIRTUAL_TOUR_URL_DOMAIN", "INVENTORY_ZERO_AVAILABILITY_IN_STOCK", "IN_ANOTHER_PRODUCT_LAUNCH", "ITEM_GROUP_NOT_SPECIFIED", "ITEM_NOT_SHIPPABLE_FOR_SCA_SHOP", "ITEM_OVERRIDE_EMPTY_AVAILABILITY", "ITEM_OVERRIDE_EMPTY_PRICE", "ITEM_OVERRIDE_NOT_VISIBLE", "ITEM_PRICE_NOT_POSITIVE", "ITEM_STALE_OUT_OF_STOCK", "MARKETPLACE_DISABLED_BY_USER", "MARKETPLACE_PARTNER_AUCTION_NO_BID_CLOSE_TIME", "MARKETPLACE_PARTNER_CURRENCY_NOT_VALID", "MARKETPLACE_PARTNER_LISTING_COUNTRY_NOT_MATCH_CATALOG", "MARKETPLACE_PARTNER_LISTING_LIMIT_EXCEEDED", "MARKETPLACE_PARTNER_MISSING_LATLONG", "MARKETPLACE_PARTNER_MISSING_SHIPPING_COST", "MARKETPLACE_PARTNER_NOT_LOCAL_ITEM", "MARKETPLACE_PARTNER_NOT_SHIPPED_ITEM", "MARKETPLACE_PARTNER_POLICY_VIOLATION", "MARKETPLACE_PARTNER_RULE_LISTING_LIMIT_EXCEEDED", "MARKETPLACE_PARTNER_SELLER_BANNED", "MARKETPLACE_PARTNER_SELLER_NOT_VALID", "MINI_SHOPS_DISABLED_BY_USER", "MISSING_CHECKOUT", "MISSING_CHECKOUT_CURRENCY", "MISSING_COLOR", "MISSING_COUNTRY_OVERRIDE_IN_SHIPPING_PROFILE", "MISSING_EVENT", "MISSING_INDIA_COMPLIANCE_FIELDS", "MISSING_SHIPPING_PROFILE", "MISSING_SIZE", "MISSING_TAX_CATEGORY", "NEGATIVE_COMMUNITY_FEEDBACK", "NEGATIVE_PRICE", "NOT_ENOUGH_IMAGES", "NOT_ENOUGH_UNIQUE_PRODUCTS", "NO_CONTENT_ID", "OVERLAY_DISCLAIMER_EXCEEDED_MAX_LENGTH", "PART_OF_PRODUCT_LAUNCH", "PASSING_MULTIPLE_CONTENT_IDS", "PRODUCT_DOMINANT_CURRENCY_MISMATCH", "PRODUCT_EXPIRED", "PRODUCT_ITEM_HIDDEN_FROM_ALL_SHOPS", "PRODUCT_ITEM_INVALID_PARTNER_TOKENS", "PRODUCT_ITEM_NOT_INCLUDED_IN_ANY_SHOP", "PRODUCT_ITEM_NOT_VISIBLE", "PRODUCT_NOT_APPROVED", "PRODUCT_NOT_DOMINANT_CURRENCY", "PRODUCT_OUT_OF_STOCK", "PRODUCT_URL_EQUALS_DOMAIN", "PROPERTY_PRICE_CURRENCY_NOT_SUPPORTED", "PROPERTY_PRICE_TOO_HIGH", "PROPERTY_PRICE_TOO_LOW", "PROPERTY_UNIT_PRICE_CURRENCY_MISMATCH_ITEM_PRICE_CURRENCY", "PROPERTY_VALUE_CONTAINS_HTML_TAGS", "PROPERTY_VALUE_DESCRIPTION_CONTAINS_OFF_PLATFORM_LINK", "PROPERTY_VALUE_FORMAT", "PROPERTY_VALUE_MISSING", "PROPERTY_VALUE_MISSING_WARNING", "PROPERTY_VALUE_NON_POSITIVE", "PROPERTY_VALUE_STRING_EXCEEDS_LENGTH", "PROPERTY_VALUE_STRING_TOO_SHORT", "PROPERTY_VALUE_UPPERCASE", "PROPERTY_VALUE_UPPERCASE_WARNING", "PURCHASE_RATE_BELOW_ADDTOCART", "PURCHASE_RATE_BELOW_VIEWCONTENT", "QUALITY_DUPLICATED_DESCRIPTION", "QUALITY_ITEM_LINK_BROKEN", "QUALITY_ITEM_LINK_REDIRECTING", "RETAILER_ID_NOT_PROVIDED", "SHOPIFY_INVALID_RETAILER_ID", "SHOPIFY_ITEM_MISSING_SHIPPING_PROFILE", "SHOPS_POLICY_VIOLATION", "SUBSCRIPTION_INFO_NOT_ENABLED_FOR_FEED", "TAX_CATEGORY_NOT_SUPPORTED_IN_UK", "UNIQUE_PRODUCT_IDENTIFIER_MISSING", "UNMATCHED_EVENTS", "UNSUPPORTED_PRODUCT_CATEGORY", "VARIANT_ATTRIBUTE_ISSUE", "VIDEO_FETCH_FAILED", "VIDEO_FETCH_FAILED_BAD_GATEWAY", "VIDEO_FETCH_FAILED_FILE_SIZE_EXCEEDED", "VIDEO_FETCH_FAILED_FORBIDDEN", "VIDEO_FETCH_FAILED_LINK_BROKEN", "VIDEO_FETCH_FAILED_TIMED_OUT", "VIDEO_NOT_DOWNLOADABLE", "WHATSAPP_DISABLED_BY_USER", "WHATSAPP_MARKETING_MESSAGE_DISABLED_BY_USER", "WHATSAPP_MARKETING_MESSAGE_POLICY_VIOLATION", "WHATSAPP_POLICY_VIOLATION"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for products"),
		),
	)
	tools = append(tools, productfeed_get_productsTool)

	// productfeed_get_rules tool
	productfeed_get_rulesTool := mcp.NewTool("productfeed_get_rules",
		mcp.WithDescription("GET rules for ProductFeed"),
	)
	tools = append(tools, productfeed_get_rulesTool)

	// productfeed_post_rules tool
	productfeed_post_rulesTool := mcp.NewTool("productfeed_post_rules",
		mcp.WithDescription("POST rules for ProductFeed"),
		mcp.WithString("attribute",
			mcp.Required(),
			mcp.Description("attribute parameter for rules"),
		),
		mcp.WithString("params",
			mcp.Description("params parameter for rules"),
		),
		mcp.WithString("rule_type",
			mcp.Required(),
			mcp.Description("rule_type parameter for rules"),
			mcp.Enum("fallback_rule", "letter_case_rule", "mapping_rule", "regex_replace_rule", "value_mapping_rule"),
		),
	)
	tools = append(tools, productfeed_post_rulesTool)

	// productfeed_post_supplementary_feed_assocs tool
	productfeed_post_supplementary_feed_assocsTool := mcp.NewTool("productfeed_post_supplementary_feed_assocs",
		mcp.WithDescription("POST supplementary_feed_assocs for ProductFeed"),
		mcp.WithString("assoc_data",
			mcp.Required(),
			mcp.Description("assoc_data parameter for supplementary_feed_assocs"),
		),
	)
	tools = append(tools, productfeed_post_supplementary_feed_assocsTool)

	// productfeed_get_upload_schedules tool
	productfeed_get_upload_schedulesTool := mcp.NewTool("productfeed_get_upload_schedules",
		mcp.WithDescription("GET upload_schedules for ProductFeed"),
	)
	tools = append(tools, productfeed_get_upload_schedulesTool)

	// productfeed_post_upload_schedules tool
	productfeed_post_upload_schedulesTool := mcp.NewTool("productfeed_post_upload_schedules",
		mcp.WithDescription("POST upload_schedules for ProductFeed"),
		mcp.WithString("upload_schedule",
			mcp.Description("upload_schedule parameter for upload_schedules"),
		),
	)
	tools = append(tools, productfeed_post_upload_schedulesTool)

	// productfeed_get_uploads tool
	productfeed_get_uploadsTool := mcp.NewTool("productfeed_get_uploads",
		mcp.WithDescription("GET uploads for ProductFeed"),
	)
	tools = append(tools, productfeed_get_uploadsTool)

	// productfeed_post_uploads tool
	productfeed_post_uploadsTool := mcp.NewTool("productfeed_post_uploads",
		mcp.WithDescription("POST uploads for ProductFeed"),
		mcp.WithString("fbe_external_business_id",
			mcp.Description("fbe_external_business_id parameter for uploads"),
		),
		mcp.WithString("file",
			mcp.Description("file parameter for uploads"),
		),
		mcp.WithString("password",
			mcp.Description("password parameter for uploads"),
		),
		mcp.WithBoolean("update_only",
			mcp.Description("update_only parameter for uploads"),
		),
		mcp.WithString("url",
			mcp.Description("url parameter for uploads"),
		),
		mcp.WithString("username",
			mcp.Description("username parameter for uploads"),
		),
	)
	tools = append(tools, productfeed_post_uploadsTool)

	// productfeed_get_vehicle_offers tool
	productfeed_get_vehicle_offersTool := mcp.NewTool("productfeed_get_vehicle_offers",
		mcp.WithDescription("GET vehicle_offers for ProductFeed"),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for vehicle_offers"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for vehicle_offers"),
		),
	)
	tools = append(tools, productfeed_get_vehicle_offersTool)

	// productfeed_get_vehicles tool
	productfeed_get_vehiclesTool := mcp.NewTool("productfeed_get_vehicles",
		mcp.WithDescription("GET vehicles for ProductFeed"),
		mcp.WithBoolean("bulk_pagination",
			mcp.Description("bulk_pagination parameter for vehicles"),
		),
		mcp.WithString("filter",
			mcp.Description("filter parameter for vehicles"),
		),
	)
	tools = append(tools, productfeed_get_vehiclesTool)

	// productfeed_delete_ tool
	productfeed_delete_Tool := mcp.NewTool("productfeed_delete_",
		mcp.WithDescription("DELETE  for ProductFeed"),
	)
	tools = append(tools, productfeed_delete_Tool)

	// productfeed_get_ tool
	productfeed_get_Tool := mcp.NewTool("productfeed_get_",
		mcp.WithDescription("GET  for ProductFeed"),
	)
	tools = append(tools, productfeed_get_Tool)

	// productfeed_post_ tool
	productfeed_post_Tool := mcp.NewTool("productfeed_post_",
		mcp.WithDescription("POST  for ProductFeed"),
		mcp.WithString("default_currency",
			mcp.Description("default_currency parameter for "),
		),
		mcp.WithBoolean("deletion_enabled",
			mcp.Description("deletion_enabled parameter for "),
		),
		mcp.WithString("delimiter",
			mcp.Description("delimiter parameter for "),
			mcp.Enum("AUTODETECT", "BAR", "COMMA", "SEMICOLON", "TAB", "TILDE"),
		),
		mcp.WithString("encoding",
			mcp.Description("encoding parameter for "),
			mcp.Enum("AUTODETECT", "LATIN1", "UTF16BE", "UTF16LE", "UTF32BE", "UTF32LE", "UTF8"),
		),
		mcp.WithString("migrated_from_feed_id",
			mcp.Description("migrated_from_feed_id parameter for "),
		),
		mcp.WithString("name",
			mcp.Description("name parameter for "),
		),
		mcp.WithString("quoted_fields_mode",
			mcp.Description("quoted_fields_mode parameter for "),
			mcp.Enum("autodetect", "off", "on"),
		),
		mcp.WithString("schedule",
			mcp.Description("schedule parameter for "),
		),
		mcp.WithString("update_schedule",
			mcp.Description("update_schedule parameter for "),
		),
	)
	tools = append(tools, productfeed_post_Tool)

	return tools
}

// ProductFeed handlers

// HandleProductfeed_get_automotive_models handles the productfeed_get_automotive_models tool
func HandleProductfeed_get_automotive_models(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_automotive_models(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_automotive_models: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_destinations handles the productfeed_get_destinations tool
func HandleProductfeed_get_destinations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_destinations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_destinations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_flights handles the productfeed_get_flights tool
func HandleProductfeed_get_flights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_flights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_flights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_home_listings handles the productfeed_get_home_listings tool
func HandleProductfeed_get_home_listings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_home_listings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_home_listings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_hotels handles the productfeed_get_hotels tool
func HandleProductfeed_get_hotels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_hotels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_hotels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_media_titles handles the productfeed_get_media_titles tool
func HandleProductfeed_get_media_titles(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_media_titles(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_media_titles: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_products handles the productfeed_get_products tool
func HandleProductfeed_get_products(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: error_priority
	if val := request.GetString("error_priority", ""); val != "" {
		args["error_priority"] = val
	}

	// Optional: error_type
	if val := request.GetString("error_type", ""); val != "" {
		args["error_type"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_products(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_products: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_rules handles the productfeed_get_rules tool
func HandleProductfeed_get_rules(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Productfeed_get_rules(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_rules: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_post_rules handles the productfeed_post_rules tool
func HandleProductfeed_post_rules(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: attribute
	attribute, err := request.RequireString("attribute")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter attribute: %v", err)), nil
	}
	args["attribute"] = attribute

	// Optional: params
	if val := request.GetString("params", ""); val != "" {
		args["params"] = val
	}

	// Required: rule_type
	rule_type, err := request.RequireString("rule_type")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter rule_type: %v", err)), nil
	}
	args["rule_type"] = rule_type

	// Call the client method
	result, err := client.Productfeed_post_rules(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_post_rules: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_post_supplementary_feed_assocs handles the productfeed_post_supplementary_feed_assocs tool
func HandleProductfeed_post_supplementary_feed_assocs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: assoc_data
	assoc_data, err := request.RequireString("assoc_data")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter assoc_data: %v", err)), nil
	}
	args["assoc_data"] = assoc_data

	// Call the client method
	result, err := client.Productfeed_post_supplementary_feed_assocs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_post_supplementary_feed_assocs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_upload_schedules handles the productfeed_get_upload_schedules tool
func HandleProductfeed_get_upload_schedules(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Productfeed_get_upload_schedules(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_upload_schedules: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_post_upload_schedules handles the productfeed_post_upload_schedules tool
func HandleProductfeed_post_upload_schedules(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: upload_schedule
	if val := request.GetString("upload_schedule", ""); val != "" {
		args["upload_schedule"] = val
	}

	// Call the client method
	result, err := client.Productfeed_post_upload_schedules(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_post_upload_schedules: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_uploads handles the productfeed_get_uploads tool
func HandleProductfeed_get_uploads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Productfeed_get_uploads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_uploads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_post_uploads handles the productfeed_post_uploads tool
func HandleProductfeed_post_uploads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fbe_external_business_id
	if val := request.GetString("fbe_external_business_id", ""); val != "" {
		args["fbe_external_business_id"] = val
	}

	// Optional: file
	if val := request.GetString("file", ""); val != "" {
		args["file"] = val
	}

	// Optional: password
	if val := request.GetString("password", ""); val != "" {
		args["password"] = val
	}

	// Optional: update_only
	if val := request.GetBool("update_only", false); val {
		args["update_only"] = val
	}

	// Optional: url
	if val := request.GetString("url", ""); val != "" {
		args["url"] = val
	}

	// Optional: username
	if val := request.GetString("username", ""); val != "" {
		args["username"] = val
	}

	// Call the client method
	result, err := client.Productfeed_post_uploads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_post_uploads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_vehicle_offers handles the productfeed_get_vehicle_offers tool
func HandleProductfeed_get_vehicle_offers(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_vehicle_offers(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_vehicle_offers: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_vehicles handles the productfeed_get_vehicles tool
func HandleProductfeed_get_vehicles(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_vehicles(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_vehicles: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_delete_ handles the productfeed_delete_ tool
func HandleProductfeed_delete_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Productfeed_delete_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_delete_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_get_ handles the productfeed_get_ tool
func HandleProductfeed_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Productfeed_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleProductfeed_post_ handles the productfeed_post_ tool
func HandleProductfeed_post_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token
	accessToken, err := request.RequireString("access_token")
	if err != nil {
		return mcp.NewToolResultError("missing required parameter: access_token"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: default_currency
	if val := request.GetString("default_currency", ""); val != "" {
		args["default_currency"] = val
	}

	// Optional: deletion_enabled
	if val := request.GetBool("deletion_enabled", false); val {
		args["deletion_enabled"] = val
	}

	// Optional: delimiter
	if val := request.GetString("delimiter", ""); val != "" {
		args["delimiter"] = val
	}

	// Optional: encoding
	if val := request.GetString("encoding", ""); val != "" {
		args["encoding"] = val
	}

	// Optional: migrated_from_feed_id
	if val := request.GetString("migrated_from_feed_id", ""); val != "" {
		args["migrated_from_feed_id"] = val
	}

	// Optional: name
	if val := request.GetString("name", ""); val != "" {
		args["name"] = val
	}

	// Optional: quoted_fields_mode
	if val := request.GetString("quoted_fields_mode", ""); val != "" {
		args["quoted_fields_mode"] = val
	}

	// Optional: schedule
	if val := request.GetString("schedule", ""); val != "" {
		args["schedule"] = val
	}

	// Optional: update_schedule
	if val := request.GetString("update_schedule", ""); val != "" {
		args["update_schedule"] = val
	}

	// Call the client method
	result, err := client.Productfeed_post_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_post_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// Context-aware handlers

// HandleContextProductfeed_get_automotive_models handles the productfeed_get_automotive_models tool with context-based auth
func HandleContextProductfeed_get_automotive_models(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_automotive_models(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_automotive_models: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_destinations handles the productfeed_get_destinations tool with context-based auth
func HandleContextProductfeed_get_destinations(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_destinations(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_destinations: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_flights handles the productfeed_get_flights tool with context-based auth
func HandleContextProductfeed_get_flights(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_flights(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_flights: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_home_listings handles the productfeed_get_home_listings tool with context-based auth
func HandleContextProductfeed_get_home_listings(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_home_listings(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_home_listings: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_hotels handles the productfeed_get_hotels tool with context-based auth
func HandleContextProductfeed_get_hotels(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_hotels(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_hotels: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_media_titles handles the productfeed_get_media_titles tool with context-based auth
func HandleContextProductfeed_get_media_titles(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_media_titles(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_media_titles: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_products handles the productfeed_get_products tool with context-based auth
func HandleContextProductfeed_get_products(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: error_priority
	if val := request.GetString("error_priority", ""); val != "" {
		args["error_priority"] = val
	}

	// Optional: error_type
	if val := request.GetString("error_type", ""); val != "" {
		args["error_type"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_products(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_products: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_rules handles the productfeed_get_rules tool with context-based auth
func HandleContextProductfeed_get_rules(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Productfeed_get_rules(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_rules: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_post_rules handles the productfeed_post_rules tool with context-based auth
func HandleContextProductfeed_post_rules(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: attribute
	attribute, err := request.RequireString("attribute")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter attribute: %v", err)), nil
	}
	args["attribute"] = attribute

	// Optional: params
	if val := request.GetString("params", ""); val != "" {
		args["params"] = val
	}

	// Required: rule_type
	rule_type, err := request.RequireString("rule_type")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter rule_type: %v", err)), nil
	}
	args["rule_type"] = rule_type

	// Call the client method
	result, err := client.Productfeed_post_rules(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_post_rules: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_post_supplementary_feed_assocs handles the productfeed_post_supplementary_feed_assocs tool with context-based auth
func HandleContextProductfeed_post_supplementary_feed_assocs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Required: assoc_data
	assoc_data, err := request.RequireString("assoc_data")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("missing required parameter assoc_data: %v", err)), nil
	}
	args["assoc_data"] = assoc_data

	// Call the client method
	result, err := client.Productfeed_post_supplementary_feed_assocs(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_post_supplementary_feed_assocs: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_upload_schedules handles the productfeed_get_upload_schedules tool with context-based auth
func HandleContextProductfeed_get_upload_schedules(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Productfeed_get_upload_schedules(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_upload_schedules: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_post_upload_schedules handles the productfeed_post_upload_schedules tool with context-based auth
func HandleContextProductfeed_post_upload_schedules(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: upload_schedule
	if val := request.GetString("upload_schedule", ""); val != "" {
		args["upload_schedule"] = val
	}

	// Call the client method
	result, err := client.Productfeed_post_upload_schedules(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_post_upload_schedules: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_uploads handles the productfeed_get_uploads tool with context-based auth
func HandleContextProductfeed_get_uploads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Productfeed_get_uploads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_uploads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_post_uploads handles the productfeed_post_uploads tool with context-based auth
func HandleContextProductfeed_post_uploads(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: fbe_external_business_id
	if val := request.GetString("fbe_external_business_id", ""); val != "" {
		args["fbe_external_business_id"] = val
	}

	// Optional: file
	if val := request.GetString("file", ""); val != "" {
		args["file"] = val
	}

	// Optional: password
	if val := request.GetString("password", ""); val != "" {
		args["password"] = val
	}

	// Optional: update_only
	if val := request.GetBool("update_only", false); val {
		args["update_only"] = val
	}

	// Optional: url
	if val := request.GetString("url", ""); val != "" {
		args["url"] = val
	}

	// Optional: username
	if val := request.GetString("username", ""); val != "" {
		args["username"] = val
	}

	// Call the client method
	result, err := client.Productfeed_post_uploads(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_post_uploads: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_vehicle_offers handles the productfeed_get_vehicle_offers tool with context-based auth
func HandleContextProductfeed_get_vehicle_offers(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_vehicle_offers(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_vehicle_offers: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_vehicles handles the productfeed_get_vehicles tool with context-based auth
func HandleContextProductfeed_get_vehicles(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: bulk_pagination
	if val := request.GetBool("bulk_pagination", false); val {
		args["bulk_pagination"] = val
	}

	// Optional: filter
	// object type - using string
	if val := request.GetString("filter", ""); val != "" {
		args["filter"] = val
	}

	// Call the client method
	result, err := client.Productfeed_get_vehicles(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_vehicles: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_delete_ handles the productfeed_delete_ tool with context-based auth
func HandleContextProductfeed_delete_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Productfeed_delete_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_delete_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_get_ handles the productfeed_get_ tool with context-based auth
func HandleContextProductfeed_get_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Call the client method
	result, err := client.Productfeed_get_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_get_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// HandleContextProductfeed_post_ handles the productfeed_post_ tool with context-based auth
func HandleContextProductfeed_post_(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get access token from context
	accessToken, ok := shared.FacebookAccessTokenFromContext(ctx)
	if !ok {
		return mcp.NewToolResultError("Facebook access token not found in context"), nil
	}

	// Create client
	client := client.NewProductFeedClient(accessToken)

	// Build arguments map
	args := make(map[string]interface{})

	// Optional: default_currency
	if val := request.GetString("default_currency", ""); val != "" {
		args["default_currency"] = val
	}

	// Optional: deletion_enabled
	if val := request.GetBool("deletion_enabled", false); val {
		args["deletion_enabled"] = val
	}

	// Optional: delimiter
	if val := request.GetString("delimiter", ""); val != "" {
		args["delimiter"] = val
	}

	// Optional: encoding
	if val := request.GetString("encoding", ""); val != "" {
		args["encoding"] = val
	}

	// Optional: migrated_from_feed_id
	if val := request.GetString("migrated_from_feed_id", ""); val != "" {
		args["migrated_from_feed_id"] = val
	}

	// Optional: name
	if val := request.GetString("name", ""); val != "" {
		args["name"] = val
	}

	// Optional: quoted_fields_mode
	if val := request.GetString("quoted_fields_mode", ""); val != "" {
		args["quoted_fields_mode"] = val
	}

	// Optional: schedule
	if val := request.GetString("schedule", ""); val != "" {
		args["schedule"] = val
	}

	// Optional: update_schedule
	if val := request.GetString("update_schedule", ""); val != "" {
		args["update_schedule"] = val
	}

	// Call the client method
	result, err := client.Productfeed_post_(args)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to execute productfeed_post_: %v", err)), nil
	}

	// Return the result as JSON
	resultJSON, err := json.Marshal(result)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("failed to marshal result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}
