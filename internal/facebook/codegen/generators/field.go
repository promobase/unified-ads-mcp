package generators

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type Field struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

type APISpec struct {
	Fields []Field `json:"fields"`
}

type FieldGenerator struct {
	specs      map[string]*APISpec
	enumTypes  map[string]bool
	outputPath string
}

func NewFieldGenerator(outputPath string) *FieldGenerator {
	return &FieldGenerator{
		specs:      make(map[string]*APISpec),
		enumTypes:  make(map[string]bool),
		outputPath: outputPath,
	}
}

func (g *FieldGenerator) LoadEnumTypes(path string) error {
	data, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read enum types: %w", err)
	}

	var enums []struct {
		Name string `json:"name"`
	}
	if err := json.Unmarshal(data, &enums); err != nil {
		return fmt.Errorf("failed to parse enum types: %w", err)
	}

	for _, enum := range enums {
		g.enumTypes[enum.Name] = true
	}

	log.Printf("Loaded %d enum types for field generation", len(g.enumTypes))
	return nil
}

func (g *FieldGenerator) LoadAPISpecs(specsDir string) error {
	entries, err := os.ReadDir(specsDir)
	if err != nil {
		return fmt.Errorf("failed to read specs directory: %w", err)
	}

	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".json") && entry.Name() != "enum_types.json" {
			specPath := filepath.Join(specsDir, entry.Name())
			data, err := os.ReadFile(specPath)
			if err != nil {
				log.Printf("Warning: failed to read %s: %v", specPath, err)
				continue
			}

			var spec APISpec
			if err := json.Unmarshal(data, &spec); err != nil {
				log.Printf("Warning: failed to parse %s: %v", specPath, err)
				continue
			}

			objectName := strings.TrimSuffix(entry.Name(), ".json")
			g.specs[objectName] = &spec
		}
	}

	log.Printf("Loaded %d API specs with fields", len(g.specs))
	return nil
}

func (g *FieldGenerator) Generate() error {
	// Create output directory
	if err := os.MkdirAll(g.outputPath, 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate fields file
	if err := g.generateFields(); err != nil {
		return fmt.Errorf("failed to generate fields: %w", err)
	}

	return nil
}

func (g *FieldGenerator) generateFields() error {
	var sb strings.Builder
	sb.WriteString("// Code generated by codegen. DO NOT EDIT.\n\n")
	sb.WriteString("package generated\n\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"time\"\n")
	sb.WriteString(")\n\n")

	// Sort object names for consistent output
	var objectNames []string
	for name := range g.specs {
		objectNames = append(objectNames, name)
	}
	sort.Strings(objectNames)

	// Generate structs for each object
	for _, objectName := range objectNames {
		spec := g.specs[objectName]

		// Generate struct
		sb.WriteString(fmt.Sprintf("// %s represents the Facebook %s object\n", objectName, objectName))
		sb.WriteString(fmt.Sprintf("type %s struct {\n", objectName))

		if len(spec.Fields) > 0 {
			// Sort fields for consistent output
			sort.Slice(spec.Fields, func(i, j int) bool {
				return spec.Fields[i].Name < spec.Fields[j].Name
			})

			for _, field := range spec.Fields {
				fieldName := toGoFieldName(field.Name)
				fieldType := g.mapFieldType(field.Type)
				jsonTag := field.Name

				sb.WriteString(fmt.Sprintf("\t%s %s `json:\"%s,omitempty\"`\n", fieldName, fieldType, jsonTag))
			}
		}

		sb.WriteString("}\n\n")
	}

	// Write statistics
	totalFields := 0
	for _, spec := range g.specs {
		totalFields += len(spec.Fields)
	}
	sb.WriteString(fmt.Sprintf("// Total objects with fields: %d\n", len(objectNames)))
	sb.WriteString(fmt.Sprintf("// Total fields: %d\n", totalFields))

	return os.WriteFile(filepath.Join(g.outputPath, "fields.go"), []byte(sb.String()), 0o644)
}

func (g *FieldGenerator) mapFieldType(fieldType string) string {
	// Handle generic types
	if strings.HasPrefix(fieldType, "list<") && strings.HasSuffix(fieldType, ">") {
		innerType := strings.TrimSuffix(strings.TrimPrefix(fieldType, "list<"), ">")
		return "[]" + g.mapFieldType(innerType)
	}

	if strings.HasPrefix(fieldType, "map<") && strings.HasSuffix(fieldType, ">") {
		// Parse map type like "map<string, unsigned int>"
		inner := strings.TrimSuffix(strings.TrimPrefix(fieldType, "map<"), ">")
		parts := strings.SplitN(inner, ",", 2)
		if len(parts) == 2 {
			keyType := g.mapFieldType(strings.TrimSpace(parts[0]))
			valueType := g.mapFieldType(strings.TrimSpace(parts[1]))

			// Maps can only have comparable types as keys
			// If key type is not a basic type, use string
			if strings.Contains(keyType, "map") || strings.Contains(keyType, "[]") || strings.Contains(keyType, "interface{}") {
				keyType = "string"
			}

			return fmt.Sprintf("map[%s]%s", keyType, valueType)
		}
		return "map[string]interface{}"
	}

	// Check if it's an enum
	if g.isEnumType(fieldType) {
		return ToGoTypeName(fieldType)
	}

	// Check if it's a known object type
	if g.isKnownObjectType(fieldType) {
		return "*" + fieldType // Pointer to avoid circular dependencies
	}

	// Map basic types
	switch fieldType {
	case "string":
		return "string"
	case "int", "integer":
		return "int"
	case "unsigned int", "uint":
		return "uint"
	case "float", "double", "number":
		return "float64"
	case "bool", "boolean":
		return "bool"
	case "datetime", "timestamp":
		return "time.Time"
	case "Object", "object", "map", "Map":
		return "map[string]interface{}"
	default:
		// If we don't recognize the type, treat it as interface{}
		return "interface{}"
	}
}

func (g *FieldGenerator) isEnumType(typeName string) bool {
	return g.enumTypes[typeName]
}

func (g *FieldGenerator) isKnownObjectType(typeName string) bool {
	_, exists := g.specs[typeName]
	return exists
}

// toGoFieldName converts field names to Go field names
func toGoFieldName(s string) string {
	// Replace dots with underscores
	s = strings.ReplaceAll(s, ".", "_")

	// Handle fields that start with numbers
	if len(s) > 0 && s[0] >= '0' && s[0] <= '9' {
		s = "X" + s // Prefix with X for fields starting with numbers
	}

	// Split by underscores
	parts := strings.Split(s, "_")

	// Capitalize each part
	for i, part := range parts {
		if part != "" {
			parts[i] = strings.Title(part)
		}
	}

	// Handle common acronyms
	result := strings.Join(parts, "")
	result = strings.ReplaceAll(result, "Id", "ID")
	result = strings.ReplaceAll(result, "Url", "URL")
	result = strings.ReplaceAll(result, "Api", "API")
	result = strings.ReplaceAll(result, "Ios", "IOS")
	result = strings.ReplaceAll(result, "Http", "HTTP")
	result = strings.ReplaceAll(result, "Https", "HTTPS")

	// Ensure it starts with a capital letter
	if len(result) > 0 && result[0] >= 'a' && result[0] <= 'z' {
		result = strings.ToUpper(string(result[0])) + result[1:]
	}

	return result
}
