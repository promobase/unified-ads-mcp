package generators

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type EnumType struct {
	Name         string   `json:"name"`
	Node         string   `json:"node"`
	FieldOrParam string   `json:"field_or_param"`
	Values       []string `json:"values"`
}

type EnumGenerator struct {
	enumTypes  []EnumType
	outputPath string
}

func NewEnumGenerator(outputPath string) *EnumGenerator {
	return &EnumGenerator{
		outputPath: outputPath,
	}
}

func (g *EnumGenerator) LoadEnumTypes(path string) error {
	data, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read enum types: %w", err)
	}

	if err := json.Unmarshal(data, &g.enumTypes); err != nil {
		return fmt.Errorf("failed to parse enum types: %w", err)
	}

	log.Printf("Loaded %d enum types", len(g.enumTypes))
	return nil
}

func (g *EnumGenerator) Generate() error {
	// Create output directory
	if err := os.MkdirAll(g.outputPath, 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate enums file
	if err := g.generateEnums(); err != nil {
		return fmt.Errorf("failed to generate enums: %w", err)
	}

	return nil
}

func (g *EnumGenerator) generateEnums() error {
	var sb strings.Builder
	sb.WriteString("// Code generated by codegen. DO NOT EDIT.\n\n")
	sb.WriteString("package generated\n\n")

	// Sort enums by name for consistent output
	sort.Slice(g.enumTypes, func(i, j int) bool {
		return g.enumTypes[i].Name < g.enumTypes[j].Name
	})

	// Track generated type names to avoid duplicates
	generatedTypes := make(map[string]bool)

	// Group enums by their Go type name to handle conflicts
	enumsByTypeName := make(map[string][]EnumType)

	for _, enum := range g.enumTypes {
		typeName := ToGoTypeName(enum.Name)
		enumsByTypeName[typeName] = append(enumsByTypeName[typeName], enum)
	}

	// Generate each unique enum type
	for typeName, enums := range enumsByTypeName {
		// Skip if already generated
		if generatedTypes[typeName] {
			continue
		}
		generatedTypes[typeName] = true

		// Use the first enum in the group (they should have the same values)
		enum := enums[0]

		// Add comment showing all enum names that map to this type
		if len(enums) > 1 {
			sb.WriteString(fmt.Sprintf("// %s represents the following enum types:\n", typeName))
			for _, e := range enums {
				sb.WriteString(fmt.Sprintf("//   - %s (used in %s.%s)\n", e.Name, e.Node, e.FieldOrParam))
			}
		} else {
			sb.WriteString(fmt.Sprintf("// %s represents %s (used in %s.%s)\n", typeName, enum.Name, enum.Node, enum.FieldOrParam))
		}

		sb.WriteString(fmt.Sprintf("type %s string\n\n", typeName))
		sb.WriteString(fmt.Sprintf("const (\n"))

		// Track generated constants to avoid duplicates
		generatedConsts := make(map[string]bool)

		for _, value := range enum.Values {
			constName := fmt.Sprintf("%s_%s", typeName, ToGoConstName(value))

			// Skip if constant already generated (can happen with duplicate values)
			if generatedConsts[constName] {
				continue
			}
			generatedConsts[constName] = true

			sb.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, typeName, value))
		}
		sb.WriteString(")\n\n")
	}

	// Write some statistics as comments
	sb.WriteString(fmt.Sprintf("// Total enum types: %d\n", len(g.enumTypes)))
	sb.WriteString(fmt.Sprintf("// Total unique Go types: %d\n", len(generatedTypes)))

	return os.WriteFile(filepath.Join(g.outputPath, "enums.go"), []byte(sb.String()), 0o644)
}

// ToGoTypeName converts enum names to Go type names
func ToGoTypeName(s string) string {
	// Handle special cases first
	if s == "" {
		return "UnknownEnum"
	}

	parts := strings.Split(s, "_")
	for i, part := range parts {
		parts[i] = strings.Title(strings.ToLower(part))
	}
	result := strings.Join(parts, "")

	// Ensure it starts with a letter
	if len(result) > 0 && (result[0] >= '0' && result[0] <= '9') {
		result = "Enum" + result
	}

	return result
}

// ToGoConstName converts enum values to Go constant names
func ToGoConstName(s string) string {
	s = strings.ToUpper(s)
	s = strings.ReplaceAll(s, " ", "_")
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, "(", "_")
	s = strings.ReplaceAll(s, ")", "_")
	s = strings.ReplaceAll(s, "&", "_AND_")
	s = strings.ReplaceAll(s, "/", "_")
	s = strings.ReplaceAll(s, "\\", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, ",", "_")
	s = strings.ReplaceAll(s, "'", "_")
	s = strings.ReplaceAll(s, "\"", "_")
	s = strings.ReplaceAll(s, "+", "_PLUS_")
	s = strings.ReplaceAll(s, ":", "_")
	s = strings.ReplaceAll(s, ";", "_")
	s = strings.ReplaceAll(s, "?", "_")
	s = strings.ReplaceAll(s, "!", "_")
	s = strings.ReplaceAll(s, "@", "_AT_")
	s = strings.ReplaceAll(s, "#", "_HASH_")
	s = strings.ReplaceAll(s, "$", "_DOLLAR_")
	s = strings.ReplaceAll(s, "%", "_PERCENT_")
	s = strings.ReplaceAll(s, "^", "_")
	s = strings.ReplaceAll(s, "*", "_STAR_")
	s = strings.ReplaceAll(s, "=", "_EQUALS_")
	s = strings.ReplaceAll(s, "{", "_")
	s = strings.ReplaceAll(s, "}", "_")
	s = strings.ReplaceAll(s, "[", "_")
	s = strings.ReplaceAll(s, "]", "_")
	s = strings.ReplaceAll(s, "|", "_")
	s = strings.ReplaceAll(s, "<", "_LT_")
	s = strings.ReplaceAll(s, ">", "_GT_")
	s = strings.ReplaceAll(s, "~", "_")
	s = strings.ReplaceAll(s, "`", "_")

	// Remove consecutive underscores
	for strings.Contains(s, "__") {
		s = strings.ReplaceAll(s, "__", "_")
	}

	// Trim leading/trailing underscores
	s = strings.Trim(s, "_")

	// If empty or starts with digit, prefix with underscore
	if s == "" || (s[0] >= '0' && s[0] <= '9') {
		s = "_" + s
	}

	return s
}
