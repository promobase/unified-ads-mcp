package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type APISpec struct {
	APIs   []APIMethod `json:"apis"`
	Fields []Field     `json:"fields"`
}

type APIMethod struct {
	Method   string  `json:"method"`
	Endpoint string  `json:"endpoint"`
	Return   string  `json:"return"`
	Params   []Param `json:"params"`
	Name     string  `json:"name,omitempty"`
}

type Param struct {
	Name     string `json:"name"`
	Required bool   `json:"required"`
	Type     string `json:"type"`
}

type Field struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

type EnumType struct {
	Name         string   `json:"name"`
	Node         string   `json:"node"`
	FieldOrParam string   `json:"field_or_param"`
	Values       []string `json:"values"`
}

type CodeGenerator struct {
	enumTypes  map[string]EnumType
	specs      map[string]*APISpec
	outputPath string
}

func NewCodeGenerator(outputPath string) *CodeGenerator {
	return &CodeGenerator{
		enumTypes:  make(map[string]EnumType),
		specs:      make(map[string]*APISpec),
		outputPath: outputPath,
	}
}

func (g *CodeGenerator) LoadEnumTypes(path string) error {
	data, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read enum types: %w", err)
	}

	var enums []EnumType
	if err := json.Unmarshal(data, &enums); err != nil {
		return fmt.Errorf("failed to parse enum types: %w", err)
	}

	for _, enum := range enums {
		g.enumTypes[enum.Name] = enum
	}

	log.Printf("Loaded %d enum types", len(g.enumTypes))
	return nil
}

func (g *CodeGenerator) LoadAPISpecs(specsDir string) error {
	entries, err := os.ReadDir(specsDir)
	if err != nil {
		return fmt.Errorf("failed to read specs directory: %w", err)
	}

	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".json") && entry.Name() != "enum_types.json" {
			specPath := filepath.Join(specsDir, entry.Name())
			data, err := os.ReadFile(specPath)
			if err != nil {
				log.Printf("Warning: failed to read %s: %v", specPath, err)
				continue
			}

			var spec APISpec
			if err := json.Unmarshal(data, &spec); err != nil {
				log.Printf("Warning: failed to parse %s: %v", specPath, err)
				continue
			}

			objectName := strings.TrimSuffix(entry.Name(), ".json")
			g.specs[objectName] = &spec
		}
	}

	log.Printf("Loaded %d API specs", len(g.specs))
	return nil
}

func (g *CodeGenerator) Generate() error {
	// Create output directory
	if err := os.MkdirAll(g.outputPath, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Generate types file
	if err := g.generateTypes(); err != nil {
		return fmt.Errorf("failed to generate types: %w", err)
	}

	// Generate tools for each ad object
	for objectName, spec := range g.specs {
		if err := g.generateToolsForObject(objectName, spec); err != nil {
			log.Printf("Warning: failed to generate tools for %s: %v", objectName, err)
		}
	}

	// Generate main tools registration file
	if err := g.generateMainToolsFile(); err != nil {
		return fmt.Errorf("failed to generate main tools file: %w", err)
	}

	return nil
}

func (g *CodeGenerator) generateTypes() error {
	var sb strings.Builder
	sb.WriteString("// Code generated by codegen. DO NOT EDIT.\n\n")
	sb.WriteString("package generated\n\n")

	// Generate enum types
	sb.WriteString("// Enum types\n")
	
	// Track generated type names to avoid duplicates
	generatedTypes := make(map[string]bool)
	
	for _, enum := range g.enumTypes {
		typeName := toGoTypeName(enum.Name)
		
		// Skip if already generated
		if generatedTypes[typeName] {
			continue
		}
		generatedTypes[typeName] = true
		
		sb.WriteString(fmt.Sprintf("type %s string\n\n", typeName))
		sb.WriteString(fmt.Sprintf("const (\n"))
		for _, value := range enum.Values {
			constName := fmt.Sprintf("%s_%s", typeName, toGoConstName(value))
			sb.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, typeName, value))
		}
		sb.WriteString(")\n\n")
	}

	return os.WriteFile(filepath.Join(g.outputPath, "types.go"), []byte(sb.String()), 0644)
}

func (g *CodeGenerator) generateToolsForObject(objectName string, spec *APISpec) error {
	var sb strings.Builder
	sb.WriteString("// Code generated by codegen. DO NOT EDIT.\n\n")
	sb.WriteString("package generated\n\n")
	
	// Only include imports that are actually used
	sb.WriteString("import (\n")
	if len(spec.APIs) > 0 {
		// context and mcp are only needed when we have API methods
		sb.WriteString("\t\"context\"\n")
		sb.WriteString("\t\"github.com/mark3labs/mcp-go/mcp\"\n")
	}
	// server is always needed for the Register function
	sb.WriteString("\t\"github.com/mark3labs/mcp-go/server\"\n")
	sb.WriteString(")\n\n")

	// Generate tools for each API method
	for _, api := range spec.APIs {
		toolName := g.generateToolName(objectName, api)
		sb.WriteString(g.generateToolFunction(toolName, objectName, api))
	}

	// Generate registration function
	sb.WriteString(g.generateObjectRegistration(objectName, spec))

	fileName := fmt.Sprintf("%s_tools.go", toSnakeCase(objectName))
	return os.WriteFile(filepath.Join(g.outputPath, fileName), []byte(sb.String()), 0644)
}

func (g *CodeGenerator) generateToolName(objectName string, api APIMethod) string {
	if api.Name != "" {
		// Handle special methods like #get, #update, #delete
		methodName := strings.TrimPrefix(api.Name, "#")
		return fmt.Sprintf("fb_%s_%s", toSnakeCase(objectName), methodName)
	}
	return fmt.Sprintf("fb_%s_%s_%s", toSnakeCase(objectName), strings.ToLower(api.Method), api.Endpoint)
}

func (g *CodeGenerator) generateToolFunction(toolName, objectName string, api APIMethod) string {
	var sb strings.Builder
	
	// Generate tool creation function
	sb.WriteString(fmt.Sprintf("func Create%sTool() mcp.Tool {\n", toCamelCase(toolName)))
	sb.WriteString(fmt.Sprintf("\treturn mcp.NewTool(\"%s\",\n", toolName))
	
	// Add description
	description := g.generateDescription(objectName, api)
	sb.WriteString(fmt.Sprintf("\t\tmcp.WithDescription(\"%s\"),\n", description))
	
	// Add parameters
	for _, param := range api.Params {
		sb.WriteString(g.generateParameter(param))
	}
	
	sb.WriteString("\t)\n")
	sb.WriteString("}\n\n")
	
	// Generate handler function
	sb.WriteString(fmt.Sprintf("func Handle%s(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n", toCamelCase(toolName)))
	sb.WriteString("\t// TODO: Implement handler logic\n")
	sb.WriteString("\treturn mcp.NewToolResultText(\"Not implemented\"), nil\n")
	sb.WriteString("}\n\n")
	
	return sb.String()
}

func (g *CodeGenerator) generateDescription(objectName string, api APIMethod) string {
	if api.Name != "" {
		methodName := strings.TrimPrefix(api.Name, "#")
		return fmt.Sprintf("%s %s", strings.Title(methodName), objectName)
	}
	return fmt.Sprintf("%s %s %s", api.Method, objectName, api.Endpoint)
}

func (g *CodeGenerator) generateParameter(param Param) string {
	var sb strings.Builder
	
	// First check if it's a known object type or enum
	baseType, isList := g.extractBaseType(param.Type)
	isEnum := g.isEnumType(param.Type)
	isKnownObject := g.isKnownObjectType(baseType)
	
	// Determine the MCP parameter type
	var mcpType string
	if isList {
		mcpType = "array"
	} else if isEnum {
		mcpType = "string" // Enums are strings
	} else if isKnownObject {
		mcpType = "object"
	} else {
		mcpType = g.mapBasicType(baseType)
	}
	
	// Generate parameter based on type
	switch mcpType {
	case "string":
		sb.WriteString(fmt.Sprintf("\t\tmcp.WithString(\"%s\",\n", param.Name))
	case "number":
		sb.WriteString(fmt.Sprintf("\t\tmcp.WithNumber(\"%s\",\n", param.Name))
	case "boolean":
		sb.WriteString(fmt.Sprintf("\t\tmcp.WithBoolean(\"%s\",\n", param.Name))
	case "array":
		sb.WriteString(fmt.Sprintf("\t\tmcp.WithArray(\"%s\",\n", param.Name))
	case "object":
		sb.WriteString(fmt.Sprintf("\t\tmcp.WithObject(\"%s\",\n", param.Name))
	default:
		sb.WriteString(fmt.Sprintf("\t\tmcp.WithString(\"%s\",\n", param.Name))
	}
	
	// Add description
	description := g.generateParamDescription(param)
	sb.WriteString(fmt.Sprintf("\t\t\tmcp.Description(\"%s\"),\n", description))
	
	if param.Required {
		sb.WriteString("\t\t\tmcp.Required(),\n")
	}
	
	// Add enum values if it's an enum type
	if isEnum {
		if enum, ok := g.enumTypes[param.Type]; ok && len(enum.Values) > 0 {
			values := make([]string, len(enum.Values))
			for i, v := range enum.Values {
				values[i] = fmt.Sprintf("\"%s\"", v)
			}
			sb.WriteString(fmt.Sprintf("\t\t\tmcp.Enum(%s),\n", strings.Join(values, ", ")))
		}
	}
	
	sb.WriteString("\t\t),\n")
	
	return sb.String()
}

func (g *CodeGenerator) extractBaseType(paramType string) (baseType string, isList bool) {
	// Handle list types
	if strings.HasPrefix(paramType, "list<") && strings.HasSuffix(paramType, ">") {
		return strings.TrimSuffix(strings.TrimPrefix(paramType, "list<"), ">"), true
	}
	return paramType, false
}

func (g *CodeGenerator) mapBasicType(paramType string) string {
	switch paramType {
	case "string", "datetime":
		return "string"
	case "int", "unsigned int", "float", "double":
		return "number"
	case "bool":
		return "boolean"
	case "map", "Map", "Object":
		return "object"
	default:
		return "string"
	}
}

func (g *CodeGenerator) isKnownObjectType(typeName string) bool {
	// Check if it's a known Facebook object type
	_, exists := g.specs[typeName]
	return exists
}

func (g *CodeGenerator) generateParamDescription(param Param) string {
	description := param.Name
	
	// Add type information for complex types
	if strings.HasPrefix(param.Type, "list<") {
		description = fmt.Sprintf("%s (array of %s)", param.Name, strings.TrimSuffix(strings.TrimPrefix(param.Type, "list<"), ">"))
	} else if g.isKnownObjectType(param.Type) {
		description = fmt.Sprintf("%s (%s object)", param.Name, param.Type)
	}
	
	return description
}

func (g *CodeGenerator) isEnumType(paramType string) bool {
	_, exists := g.enumTypes[paramType]
	return exists
}

func (g *CodeGenerator) generateObjectRegistration(objectName string, spec *APISpec) string {
	var sb strings.Builder
	
	sb.WriteString(fmt.Sprintf("func Register%sTools(s *server.MCPServer) {\n", objectName))
	
	for _, api := range spec.APIs {
		toolName := g.generateToolName(objectName, api)
		handlerName := fmt.Sprintf("Handle%s", toCamelCase(toolName))
		createFuncName := fmt.Sprintf("Create%sTool", toCamelCase(toolName))
		sb.WriteString(fmt.Sprintf("\ts.AddTool(%s(), %s)\n", createFuncName, handlerName))
	}
	
	sb.WriteString("}\n")
	
	return sb.String()
}

func (g *CodeGenerator) generateMainToolsFile() error {
	var sb strings.Builder
	sb.WriteString("// Code generated by codegen. DO NOT EDIT.\n\n")
	sb.WriteString("package generated\n\n")
	sb.WriteString("import (\n")
	sb.WriteString("\t\"github.com/mark3labs/mcp-go/server\"\n")
	sb.WriteString(")\n\n")
	
	sb.WriteString("// RegisterAllTools registers all generated Facebook API tools\n")
	sb.WriteString("func RegisterAllTools(s *server.MCPServer) {\n")
	
	// Sort object names for consistent output
	var objectNames []string
	for name := range g.specs {
		objectNames = append(objectNames, name)
	}
	sort.Strings(objectNames)
	
	for _, objectName := range objectNames {
		sb.WriteString(fmt.Sprintf("\tRegister%sTools(s)\n", objectName))
	}
	
	sb.WriteString("}\n")
	
	return os.WriteFile(filepath.Join(g.outputPath, "register.go"), []byte(sb.String()), 0644)
}

// Helper functions
func toGoTypeName(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		parts[i] = strings.Title(strings.ToLower(part))
	}
	return strings.Join(parts, "")
}

func toGoConstName(s string) string {
	s = strings.ToUpper(s)
	s = strings.ReplaceAll(s, " ", "_")
	s = strings.ReplaceAll(s, "-", "_")
	s = strings.ReplaceAll(s, "(", "_")
	s = strings.ReplaceAll(s, ")", "_")
	s = strings.ReplaceAll(s, "&", "_AND_")
	s = strings.ReplaceAll(s, "/", "_")
	s = strings.ReplaceAll(s, "\\", "_")
	s = strings.ReplaceAll(s, ".", "_")
	s = strings.ReplaceAll(s, ",", "_")
	s = strings.ReplaceAll(s, "'", "_")
	s = strings.ReplaceAll(s, "\"", "_")
	s = strings.ReplaceAll(s, "+", "_PLUS_")
	s = strings.ReplaceAll(s, ":", "_")
	s = strings.ReplaceAll(s, ";", "_")
	s = strings.ReplaceAll(s, "?", "_")
	s = strings.ReplaceAll(s, "!", "_")
	s = strings.ReplaceAll(s, "@", "_AT_")
	s = strings.ReplaceAll(s, "#", "_HASH_")
	s = strings.ReplaceAll(s, "$", "_DOLLAR_")
	s = strings.ReplaceAll(s, "%", "_PERCENT_")
	s = strings.ReplaceAll(s, "^", "_")
	s = strings.ReplaceAll(s, "*", "_STAR_")
	s = strings.ReplaceAll(s, "=", "_EQUALS_")
	s = strings.ReplaceAll(s, "{", "_")
	s = strings.ReplaceAll(s, "}", "_")
	s = strings.ReplaceAll(s, "[", "_")
	s = strings.ReplaceAll(s, "]", "_")
	s = strings.ReplaceAll(s, "|", "_")
	s = strings.ReplaceAll(s, "<", "_LT_")
	s = strings.ReplaceAll(s, ">", "_GT_")
	s = strings.ReplaceAll(s, "~", "_")
	s = strings.ReplaceAll(s, "`", "_")
	// Remove consecutive underscores
	for strings.Contains(s, "__") {
		s = strings.ReplaceAll(s, "__", "_")
	}
	// Trim leading/trailing underscores
	s = strings.Trim(s, "_")
	// If empty or starts with digit, prefix with underscore
	if s == "" || (s[0] >= '0' && s[0] <= '9') {
		s = "_" + s
	}
	return s
}

func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		parts[i] = strings.Title(part)
	}
	return strings.Join(parts, "")
}

func main() {
	if len(os.Args) < 2 {
		log.Fatal("Usage: go run main.go <specs_directory>")
	}

	specsDir := os.Args[1]
	outputPath := filepath.Join(filepath.Dir(specsDir), "..", "generated")

	generator := NewCodeGenerator(outputPath)

	// Load enum types first
	enumPath := filepath.Join(specsDir, "enum_types.json")
	if err := generator.LoadEnumTypes(enumPath); err != nil {
		log.Fatalf("Failed to load enum types: %v", err)
	}

	// Load API specs
	if err := generator.LoadAPISpecs(specsDir); err != nil {
		log.Fatalf("Failed to load API specs: %v", err)
	}

	// Generate code
	if err := generator.Generate(); err != nil {
		log.Fatalf("Failed to generate code: %v", err)
	}

	log.Printf("Code generation completed successfully. Output in: %s", outputPath)
}