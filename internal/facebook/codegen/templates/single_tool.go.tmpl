// Code generated by codegen. DO NOT EDIT.

package tools

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
	"unified-ads-mcp/internal/facebook/generated/common"
)

// {{.ToolName}}Args defines the typed arguments for {{.ToolName}}
type {{.ToolName}}Args struct {
{{- if .NeedsID}}
	ID string `json:"id" jsonschema:"required,description={{.ObjectName}} ID,pattern=^[0-9]+$"`
{{- end}}
{{- range .TypedParams}}
	{{.GoName}} {{.GoType}} `json:"{{.JSONName}}{{if .JSONTag}},{{.JSONTag}}{{end}}" jsonschema:"{{.JSONSchemaTag}}"`
{{- end}}
}

// Register{{.HandlerName}} registers the {{.ToolName}} tool
func Register{{.HandlerName}}(s *server.MCPServer) error {
	tool := mcp.NewToolWithRawSchema(
		"{{.ToolName}}",
		"{{.Description}}",
		json.RawMessage(`{{.RawSchema}}`),
	)
	
	s.AddTool(tool, {{.HandlerName}})
	return nil
}

// {{.HandlerName}} handles the {{.ToolName}} tool
func {{.HandlerName}}(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	var args {{.ToolName}}Args
	if err := request.BindArguments(&args); err != nil {
		return common.HandleBindError(err)
	}

	{{- if .NeedsID}}
	endpoint := fmt.Sprintf("/%s{{if .Endpoint}}/{{.Endpoint}}{{end}}", args.ID)
	{{- else if .Endpoint}}
	endpoint := "/{{.Endpoint}}"
	{{- else}}
	// Root endpoint for object operations
	endpoint := ""
	{{- end}}

	{{- if eq .Method "GET" "DELETE"}}
	// Prepare query parameters
	params := make(map[string]string)
	{{- if .NeedsID}}
	// ID is part of path, not query params
	{{- end}}
	{{- range .TypedParams}}
	{{- if eq .GoName "Fields"}}
	if len(args.Fields) > 0 {
		params["fields"] = strings.Join(args.Fields, ",")
	}
	{{- else if eq .GoName "Limit"}}
	if args.Limit > 0 {
		params["limit"] = fmt.Sprintf("%d", args.Limit)
	}
	{{- else if eq .GoType "string"}}
	if args.{{.GoName}} != "" {
		params["{{.JSONName}}"] = args.{{.GoName}}
	}
	{{- else if eq .GoType "int"}}
	if args.{{.GoName}} > 0 {
		params["{{.JSONName}}"] = fmt.Sprintf("%d", args.{{.GoName}})
	}
	{{- else if eq .GoType "bool"}}
	params["{{.JSONName}}"] = fmt.Sprintf("%v", args.{{.GoName}})
	{{- else if contains .GoType "[]string"}}
	if len(args.{{.GoName}}) > 0 {
		params["{{.JSONName}}"] = strings.Join(args.{{.GoName}}, ",")
	}
	{{- else}}
	// TODO: Handle {{.GoType}} for {{.GoName}}
	{{- end}}
	{{- end}}

	result, err := common.MakeGraphAPIRequest(ctx, "{{.Method}}", endpoint, params, nil)
	{{- else}}
	// Prepare request body
	body := make(map[string]interface{})
	{{- range .TypedParams}}
	{{- if eq .GoType "string"}}
	if args.{{.GoName}} != "" {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}
	{{- else if contains .GoType "[]"}}
	if len(args.{{.GoName}}) > 0 {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}
	{{- else if contains .GoType "*"}}
	if args.{{.GoName}} != nil {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}
	{{- else if eq .GoType "int"}}
	if args.{{.GoName}} > 0 {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}
	{{- else}}
	body["{{.JSONName}}"] = args.{{.GoName}}
	{{- end}}
	{{- end}}

	result, err := common.MakeGraphAPIRequest(ctx, "{{.Method}}", endpoint, nil, body)
	{{- end}}

	if err != nil {
		return common.HandleAPIError(err)
	}

	return &mcp.CallToolResult{
		Content: []mcp.Content{
			mcp.NewTextContent(string(result)),
		},
	}, nil
}