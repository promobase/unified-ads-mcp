// Code generated by codegen. DO NOT EDIT.

package generated

import (
	"context"
	"fmt"
	"reflect"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)

{{/* Generate typed argument structs for each tool */}}
{{range .Tools}}
// {{.ToolName}}Args defines the typed arguments for {{.ToolName}}
type {{.ToolName}}Args struct {
{{if .NeedsID}}	ID string `json:"id" jsonschema:"required,description={{.ObjectName}} ID,pattern=^[0-9]+$"`
{{end}}{{range .TypedParams}}	{{.GoName}} {{.GoType}} `json:"{{.JSONName}}{{if .JSONTag}},{{.JSONTag}}{{end}}" jsonschema:"{{.JSONSchemaTag}}"`
{{end}}}

{{end}}

{{/* Generate schema variables for each tool */}}
var (
{{range .Tools}}
	{{.ToolName}}Schema = generateSchemaForType(reflect.TypeOf({{.ToolName}}Args{}))
{{end}}
)

{{/* Generate typed handlers for each tool */}}
{{range .Tools}}
// {{.HandlerName}} handles {{.ToolName}} with typed arguments
func {{.HandlerName}}(ctx context.Context, request mcp.CallToolRequest, args {{.ToolName}}Args) (*mcp.CallToolResult, error) {
	{{if and (eq .Method "GET") (not .HasComplexLogic)}}
	// Build query parameters
	query := BuildQueryParameters()
	
	{{if .NeedsID}}
	if args.ID == "" {
		return mcp.NewToolResultError("id is required"), nil
	}
	{{end}}
	
	// Handle fields parameter
	if len(args.Fields) > 0 {
		query.Set("fields", strings.Join(args.Fields, ","))
	} else {
		// Use default fields
		{{if and .Return (ne .Return "") (ne .Return "Object")}}defaultFields := GetDefaultFields("{{.Return}}"){{else}}defaultFields := GetDefaultFields("{{.ObjectName}}"){{end}}
		if len(defaultFields) > 0 {
			query.Set("fields", strings.Join(defaultFields, ","))
		}
	}
	
	// Add other parameters
	{{range .TypedParams}}
	{{if eq .GoType "string"}}if args.{{.GoName}} != "" {
		query.Set("{{.JSONName}}", args.{{.GoName}})
	}{{else if eq .GoType "int"}}if args.{{.GoName}} > 0 {
		query.Set("{{.JSONName}}", fmt.Sprintf("%d", args.{{.GoName}}))
	}{{else if eq .GoType "bool"}}if args.{{.GoName}} {
		query.Set("{{.JSONName}}", "true")
	}{{else if eq .GoType "[]string"}}if len(args.{{.GoName}}) > 0 {
		query.Set("{{.JSONName}}", strings.Join(args.{{.GoName}}, ","))
	}{{else if eq .GoType "map[string]interface{}"}}// Handle {{.GoName}} map parameter
	for k, v := range args.{{.GoName}} {
		query.Set(k, fmt.Sprintf("%v", v))
	}{{end}}
	{{end}}
	
	// Build URL and execute
	{{if .NeedsID}}baseURL := buildGraphURL(args.ID, "{{.Endpoint}}"){{else}}baseURL := buildGraphURL("", "{{.Endpoint}}"){{end}}
	fullURL := BuildURLWithQuery(baseURL, query)
	
	return ExecuteGETRequest(ctx, fullURL)
	{{else if and (eq .Method "POST") (not .HasComplexLogic)}}
	// Build request body
	body := make(map[string]interface{})
	
	{{if .NeedsID}}
	if args.ID == "" {
		return mcp.NewToolResultError("id is required"), nil
	}
	{{end}}
	
	// Add parameters to body
	{{range .TypedParams}}
	{{if eq .GoType "string"}}if args.{{.GoName}} != "" {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{else if eq .GoType "int"}}if args.{{.GoName}} > 0 {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{else if eq .GoType "float64"}}if args.{{.GoName}} != 0 {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{else if eq .GoType "bool"}}body["{{.JSONName}}"] = args.{{.GoName}}{{else if or (eq .GoType "[]string") (eq .GoType "[]*AdLabel")}}if len(args.{{.GoName}}) > 0 {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{else if eq .GoType "[]map[string]interface{}"}}if len(args.{{.GoName}}) > 0 {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{else}}if args.{{.GoName}} != nil {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{end}}
	{{end}}
	
	// Build URL and execute
	{{if .NeedsID}}url := buildGraphURL(args.ID, "{{.Endpoint}}"){{else}}url := buildGraphURL("", "{{.Endpoint}}"){{end}}
	
	return ExecutePOSTRequest(ctx, url, body)
	{{else if and (eq .Method "DELETE") (not .HasComplexLogic)}}
	{{if .NeedsID}}
	if args.ID == "" {
		return mcp.NewToolResultError("id is required"), nil
	}
	
	url := buildGraphURL(args.ID, "{{.Endpoint}}")
	return ExecuteDELETERequest(ctx, url)
	{{end}}
	{{else}}
	// Complex logic handler - implement custom logic here
	return mcp.NewToolResultError("Handler not implemented"), nil
	{{end}}
}

{{end}}

// generateSchemaForType is implemented in tools_common.go to avoid redeclaration

// Register{{.ObjectName}}Tools registers all {{.ObjectName}} tools with the MCP server
func Register{{.ObjectName}}Tools(s *server.MCPServer) error {
	{{range .Tools}}
	// Register {{.ToolName}} using raw schema
	s.AddTool(
		mcp.NewToolWithRawSchema("{{.ToolName}}", "{{.Description}}", {{.ToolName}}Schema),
		mcp.NewTypedToolHandler({{.HandlerName}}),
	)
	{{end}}
	
	return nil
}

// {{.ObjectName}} tools: {{.TotalTools}} endpoints