// Code generated by codegen. DO NOT EDIT.

package generated

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)

{{/* Generate typed argument structs for each tool */}}
{{range .Tools}}
// {{.ToolName}}Args defines the typed arguments for {{.ToolName}}
type {{.ToolName}}Args struct {
{{if .NeedsID}}	ID string `json:"id"`
{{end}}{{range .TypedParams}}	{{.GoName}} {{.GoType}} `json:"{{.JSONName}}{{if .JSONTag}},{{.JSONTag}}{{end}}"`
{{end}}}

{{end}}

{{/* Generate typed handlers for each tool */}}
{{range .Tools}}
// {{.HandlerName}} handles {{.ToolName}} with typed arguments
func {{.HandlerName}}(ctx context.Context, request mcp.CallToolRequest, args {{.ToolName}}Args) (*mcp.CallToolResult, error) {
	{{if and (eq .Method "GET") (not .HasComplexLogic)}}
	// Build query parameters
	query := BuildQueryParameters()
	
	{{if .NeedsID}}
	if args.ID == "" {
		return mcp.NewToolResultError("id is required"), nil
	}
	{{end}}
	
	// Handle fields parameter
	if len(args.Fields) > 0 {
		query.Set("fields", strings.Join(args.Fields, ","))
	} else {
		// Use default fields for the return type
		{{if and .Return (ne .Return "") (ne .Return "Object")}}defaultFields := GetDefaultFields("{{.Return}}")
		log.Printf("Using default fields for {{.Return}} (return type): %v", defaultFields){{else}}defaultFields := GetDefaultFields("{{.ObjectName}}")
		log.Printf("Using default fields for {{.ObjectName}} (object type): %v", defaultFields){{end}}
		if len(defaultFields) > 0 {
			query.Set("fields", strings.Join(defaultFields, ","))
		}
	}
	
	// Add other parameters
	{{range .TypedParams}}
	{{if eq .GoType "string"}}if args.{{.GoName}} != "" {
		query.Set("{{.JSONName}}", args.{{.GoName}})
	}{{else if eq .GoType "int"}}if args.{{.GoName}} > 0 {
		query.Set("{{.JSONName}}", fmt.Sprintf("%d", args.{{.GoName}}))
	}{{else if eq .GoType "bool"}}if args.{{.GoName}} {
		query.Set("{{.JSONName}}", "true")
	}{{else if eq .GoType "[]string"}}if len(args.{{.GoName}}) > 0 {
		query.Set("{{.JSONName}}", strings.Join(args.{{.GoName}}, ","))
	}{{else if eq .GoType "map[string]interface{}"}}// Handle {{.GoName}} map parameter
	for k, v := range args.{{.GoName}} {
		query.Set(k, fmt.Sprintf("%v", v))
	}{{end}}
	{{end}}
	
	// Build URL and execute
	{{if .NeedsID}}baseURL := buildGraphURL(args.ID, "{{.Endpoint}}"){{else}}baseURL := buildGraphURL("", "{{.Endpoint}}"){{end}}
	fullURL := BuildURLWithQuery(baseURL, query)
	
	return ExecuteGETRequest(ctx, fullURL)
	{{else if and (eq .Method "POST") (not .HasComplexLogic)}}
	// Build request body
	body := make(map[string]interface{})
	
	{{if .NeedsID}}
	if args.ID == "" {
		return mcp.NewToolResultError("id is required"), nil
	}
	{{end}}
	
	// Add parameters to body
	{{range .TypedParams}}
	{{if eq .GoType "string"}}if args.{{.GoName}} != "" {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{else if eq .GoType "int"}}if args.{{.GoName}} > 0 {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{else if eq .GoType "float64"}}if args.{{.GoName}} != 0 {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{else if eq .GoType "bool"}}body["{{.JSONName}}"] = args.{{.GoName}}{{else if or (eq .GoType "[]string") (eq .GoType "[]*AdLabel")}}if len(args.{{.GoName}}) > 0 {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{else if eq .GoType "[]map[string]interface{}"}}if len(args.{{.GoName}}) > 0 {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{else}}if args.{{.GoName}} != nil {
		body["{{.JSONName}}"] = args.{{.GoName}}
	}{{end}}
	{{end}}
	
	// Build URL and execute
	{{if .NeedsID}}url := buildGraphURL(args.ID, "{{.Endpoint}}"){{else}}url := buildGraphURL("", "{{.Endpoint}}"){{end}}
	
	return ExecutePOSTRequest(ctx, url, body)
	{{else if and (eq .Method "DELETE") (not .HasComplexLogic)}}
	{{if .NeedsID}}
	if args.ID == "" {
		return mcp.NewToolResultError("id is required"), nil
	}
	{{end}}
	
	// Build URL and execute
	{{if .NeedsID}}url := buildGraphURL(args.ID, "{{.Endpoint}}"){{else}}url := buildGraphURL("", "{{.Endpoint}}"){{end}}
	
	return ExecuteDELETERequest(ctx, url)
	{{else}}
	// Custom implementation for complex logic
	// TODO: Implement custom logic for {{.ToolName}}
	return mcp.NewToolResultError("Custom implementation required"), nil
	{{end}}
}

{{end}}

// Register{{.ObjectName}}Tools registers all {{.ObjectName}} tools with the MCP server
func Register{{.ObjectName}}Tools(s *server.MCPServer) error {
	{{range .Tools}}
	// Register {{.ToolName}}
	s.AddTool(
		mcp.NewTool("{{.ToolName}}",
			mcp.WithDescription("{{.Description}}"),
			{{if .NeedsID}}mcp.WithString("id",
				mcp.Required(),
				mcp.Description("{{.ObjectName}} ID"),
			),
			{{end}}{{range .SchemaParams}}{{if eq .SchemaType "string"}}mcp.WithString("{{.JSONName}}",
				{{if .Required}}mcp.Required(),
				{{end}}mcp.Description("{{.Description}}"),
			),
			{{else if eq .SchemaType "number"}}mcp.WithNumber("{{.JSONName}}",
				{{if .Required}}mcp.Required(),
				{{end}}mcp.Description("{{.Description}}"),
			),
			{{else if eq .SchemaType "boolean"}}mcp.WithBoolean("{{.JSONName}}",
				{{if .Required}}mcp.Required(),
				{{end}}mcp.Description("{{.Description}}"),
			),
			{{else if eq .SchemaType "array"}}mcp.WithArray("{{.JSONName}}",
				{{if .Required}}mcp.Required(),
				{{end}}mcp.Description("{{.Description}}"),
				mcp.Items(map[string]any{"type": "{{.ItemsType}}"}),
			),
			{{else if eq .SchemaType "object"}}mcp.WithObject("{{.JSONName}}",
				{{if .Required}}mcp.Required(),
				{{end}}mcp.Description("{{.Description}}"),
				mcp.AdditionalProperties(true),
			),
			{{end}}{{end}}
		),
		mcp.NewTypedToolHandler({{.HandlerName}}),
	)
	{{end}}
	
	return nil
}

// {{.ObjectName}} tools: {{.TotalTools}} endpoints